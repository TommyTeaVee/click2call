var __b_release_mode = true;
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
// Base64 code from Tyler Akins -- http://rumkin.com

var Base64 = (function () {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    var obj = {
        /**
         * Encodes a string in base64
         * @param {String} input The string to encode in base64.
         */
        encode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
            } while (i < input.length);

            return output;
        },

        /**
         * Decodes a base64 string.
         * @param {String} input The string to decode.
         */
        decode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }
            } while (i < input.length);

            return output;
        }
    };

    return obj;
})();

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
// convert a string to a integer buffer
// each char will be converted to it's conresponding utf-16 value
function tsk_buff_str2ib(s_str) {
    if (!s_str) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }
    var len = s_str.length;
    var ib = new Array(len);
    for (var i = 0; i < len; ++i) {
        ib[i] = s_str.charCodeAt(i);
    }
    return ib;
}

function tsk_buff_ab2str(buff) {
    return tsk_buff_u8b2ascii(new Uint8Array(buff));
}

function tsk_buff_u8b2ascii(au8_buff) {
    // return Array.prototype.slice.call(au8_buff).join("");
    var str = new String();
    var i_length = au8_buff.byteLength == undefined ? au8_buff.length : au8_buff.byteLength;
    for (var i = 0; i < i_length; ++i) {
        str += String.fromCharCode(au8_buff[i] & 0xff);
    }
    return str;
}

function tsk_buff_u8b2utf8(au8_buff) {
    try {
        var str = new String();
        var c_char;
        var i_length = au8_buff.byteLength == undefined ? au8_buff.length : au8_buff.byteLength;
        for (var i = 0; i < i_length; ) {
            c_char = au8_buff[i];
            if (c_char < 0x80) {
                str += String.fromCharCode(c_char); ++i;
            }
            else if ((c_char > 0xbf) && (c_char < 0xe0)) {
                str += String.fromCharCode(((c_char & 0x1f) << 6) | (au8_buff[i + 1] & 0x3f)); i += 2;
            }
            else {
                str += String.fromCharCode(((c_char & 0x0f) << 12) | ((au8_buff[i + 1] & 0x3f) << 6) | (au8_buff[i + 2] & 0x3f)); i += 3;
            }
        }
        return str;
    }
    catch (e) {
        tsk_utils_log_error(e);
        return tsk_buff_u8b2ascii(au8_buff);
    }
}

function tsk_buff_str2u8b(s_str) {
    var array = new Uint8Array(s_str.length);
    for (var i = 0; i < s_str.length; ++i) {
        array[i] = s_str[i].charCodeAt(0) & 0xff;
    }
    return array;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsk_fsm.prototype.__i_state_any = -0xFFFF;
tsk_fsm.prototype.__i_state_default = -0xFFF0;
tsk_fsm.prototype.__i_state_none = -0xFF00;
tsk_fsm.prototype.__i_state_final = -0xF000;
tsk_fsm.prototype.__i_action_any = -0xFFFF;

// fn_onterm = bool fn(o_usr_data)
function tsk_fsm(i_state_curr, i_state_term, fn_onterm, o_usr_data) {
    this.i_state_curr = i_state_curr;
    this.i_state_term = i_state_term;
    this.fn_onterm = fn_onterm;
    this.o_usr_data = o_usr_data;
    this.ao_entries = new Array();
    this.b_debug = false;
}

tsk_fsm.prototype.is_terminated = function () {
    return this.i_state_curr == this.i_state_term;
}

tsk_fsm.prototype.is_debug_enabled = function () {
    return this.b_debug;
}

tsk_fsm.prototype.set_debug_enabled = function (b_enable) {
    this.b_debug = b_enable;
}

tsk_fsm.prototype.set_onterm_callback = function (fn_callback, o_usr_data) {
    this.fn_onterm = fn_callback;
    this.o_usr_data = o_usr_data;
}

tsk_fsm.prototype.get_usr_data = function () {
    return this.o_usr_data;
}

// set( ...entries)
tsk_fsm.prototype.set = function () {
    for (var i = 0; i < arguments.length; ++i) {
        if (arguments[i]) {
            this.ao_entries.push(arguments[i]);
        }
    }
    this.ao_entries.sort(tsk_fsm_entry_compare);
    return 0;
}

// tsk_fsm_act(i_action, o_cond_obj1, o_cond_obj2, ...exec_args)
tsk_fsm.prototype.act = function (i_action, o_cond_obj1, o_cond_obj2) {
    var b_found = false;
    var b_terminates = false;
    var i_ret_exec = 0;
    var o_entry;

    if (this.is_terminated()) {
        tsk_utils_log_warn("The FSM is in the final state");
        return -2;
    }

    // FIXME: deadlock
    // while (this.b_locked) tsk_utils_log_info("locked");
    this.b_locked = true;

    for (var i = 0; i < this.ao_entries.length; ++i) {
        if (!(o_entry = this.ao_entries[i])) {
            continue;
        }
        if ((o_entry.i_state_from != tsk_fsm.prototype.__i_state_any) && (o_entry.i_state_from != this.i_state_curr)) {
            continue;
        }
        if ((o_entry.i_action != tsk_fsm.prototype.__i_action_any) && (o_entry.i_action != i_action)) {
            continue;
        }

        // check condition
        if (!o_entry.fn_condition || o_entry.fn_condition(o_cond_obj1, o_cond_obj2)) {
            if (this.is_debug_enabled()) {
                tsk_utils_log_info("State machine: " + o_entry.s_description);
            }
            if (o_entry.i_state_to != tsk_fsm.prototype.__i_state_any) {
                this.i_state_curr = o_entry.i_state_to;
            }
            if (o_entry.fn_execute) {
                try {
                    if ((i_ret_exec = o_entry.fn_execute(Array.prototype.slice.call(arguments, 3)))) {
                        tsk_utils_log_info("State machine: Exec function failed. Moving to the termnial state");
                    }
                }
                catch (e) {
                    tsk_utils_log_error(e);
                    i_ret_exec = -3;
                }
            }
            else {
                i_ret_exec = 0;
            }
            b_terminates = (i_ret_exec != 0 || (this.i_state_curr == this.i_state_term));
            b_found = true;
            break;
        }
    }

    if (b_terminates) {
        this.i_state_curr = this.i_state_term;
        if (this.fn_onterm) {
            this.fn_onterm(this.o_usr_data);
        }
    }

    this.b_locked = false;

    return i_ret_exec;
}


// fn_condition = bool fn(o_1, o_2)
// fn_execute = int fn(exec_args[])
function tsk_fsm_entry(i_state_from, i_action, fn_condition, i_state_to, fn_execute, s_description) {
    this.i_state_from = i_state_from;
    this.i_action = i_action;
    this.fn_condition = fn_condition;
    this.i_state_to = i_state_to;
    this.fn_execute = fn_execute;
    this.s_description = s_description;
}

tsk_fsm_entry.prototype.Create = function (i_state_from, i_action, fn_condition, i_state_to, fn_execute, s_description) {
    return new tsk_fsm_entry(i_state_from, i_action, fn_condition, i_state_to, fn_execute, s_description);
}

tsk_fsm_entry.prototype.CreateAlways = function(i_state_from, i_action, i_state_to, fn_execute, s_description) {
    return new tsk_fsm_entry(i_state_from, i_action, null, i_state_to, fn_execute, s_description);
}

tsk_fsm_entry.prototype.CreateNothing = function(i_state_from, i_action, fn_condition, s_description) {
    return new tsk_fsm_entry(i_state_from, i_action, fn_condition, i_state_from, null, s_description);
}

tsk_fsm_entry.prototype.CreateAlwaysNothing = function(i_state_from, s_description) {
    return new tsk_fsm_entry(i_state_from, tsk_fsm.prototype.__i_action_any, null, i_state_from, null, s_description);
}

function tsk_fsm_entry_compare(o_entry1, o_entry2) {
    if (o_entry1 && o_entry2) {
        if (o_entry1.i_state_from == tsk_fsm.prototype.__i_state_any) {
            return +20;
        }
        else if (o_entry2.i_state_from == tsk_fsm.prototype.__i_state_any) {
            return -20;
        }

        // put "any" actions at the bottom (weak)
        if (o_entry1.i_action == tsk_fsm.prototype.__i_action_any) {
            return +10;
        }
        else if (o_entry2.i_action == tsk_fsm.prototype.__i_action_any) {
            return -10;
        }
        // put conditions first
        return o_entry1.fn_condition ? -1 : (o_entry2.fn_condition ? 1 : 0);
    }
   
    return 0
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var MD5 = (function () {
    /*
     * Configurable variables. You may need to tweak these to be compatible with
     * the server-side, but the defaults work in most cases.
     */
    var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase */
    var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance */
    var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode */

    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    var safe_add = function (x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    };

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    var bit_rol = function (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    };

    /*
     * Convert a string to an array of little-endian words
     * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
     */
    var str2binl = function (str) {
        var bin = [];
        var mask = (1 << chrsz) - 1;
        for(var i = 0; i < str.length * chrsz; i += chrsz)
        {
            bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
        }
        return bin;
    };

    /*
     * Convert an array of little-endian words to a string
     */
    var binl2str = function (bin) {
        var str = "";
        var mask = (1 << chrsz) - 1;
        for(var i = 0; i < bin.length * 32; i += chrsz)
        {
            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a hex string.
     */
    var binl2hex = function (binarray) {
        var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
        var str = "";
        for(var i = 0; i < binarray.length * 4; i++)
        {
            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a base-64 string
     */
    var binl2b64 = function (binarray) {
        var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var str = "";
        var triplet, j;
        for(var i = 0; i < binarray.length * 4; i += 3)
        {
            triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16) |
                (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 ) |
                ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
            for(j = 0; j < 4; j++)
            {
                if(i * 8 + j * 6 > binarray.length * 32) { str += b64pad; }
                else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
            }
        }
        return str;
    };

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    var md5_cmn = function (q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
    };

    var md5_ff = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    };

    var md5_gg = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    };

    var md5_hh = function (a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };

    var md5_ii = function (a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    };

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length
     */
    var core_md5 = function (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var a =  1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d =  271733878;

        var olda, oldb, oldc, oldd;
        for (var i = 0; i < x.length; i += 16)
        {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    };


    /*
     * Calculate the HMAC-MD5, of a key and some data
     */
    var core_hmac_md5 = function (key, data) {
        var bkey = str2binl(key);
        if(bkey.length > 16) { bkey = core_md5(bkey, key.length * chrsz); }

        var ipad = new Array(16), opad = new Array(16);
        for(var i = 0; i < 16; i++)
        {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }

        var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
        return core_md5(opad.concat(hash), 512 + 128);
    };

    var obj = {
        /*
         * These are the functions you'll usually want to call.
         * They take string arguments and return either hex or base-64 encoded
         * strings.
         */
        hexdigest: function (s) {
            return binl2hex(core_md5(str2binl(s), s.length * chrsz));
        },

        b64digest: function (s) {
            return binl2b64(core_md5(str2binl(s), s.length * chrsz));
        },

        hash: function (s) {
            return binl2str(core_md5(str2binl(s), s.length * chrsz));
        },

        hmac_hexdigest: function (key, data) {
            return binl2hex(core_hmac_md5(key, data));
        },

        hmac_b64digest: function (key, data) {
            return binl2b64(core_hmac_md5(key, data));
        },

        hmac_hash: function (key, data) {
            return binl2str(core_hmac_md5(key, data));
        },

        /*
         * Perform a simple self-test to see if the VM is working
         */
        test: function () {
            return MD5.hexdigest("abc") === "900150983cd24fb0d6963f7d28e17f72";
        }
    };

    return obj;
})();

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
function tsk_param_create(s_name, s_value) {
    var self = new Object();
    self.s_name = s_name;
    self.s_value = s_value;
    self.b_tag = false;
    return self;
}

function tsk_param_create_null() {
    return tsk_param_create(null, null);
}

function tsk_param_parse(s_line) {
    if (!tsk_string_is_null_or_empty(s_line)) {
        var i_start = 0;
        var i_end = s_line.length;
        var i_equal = tsk_string_index_of(s_line, i_end, "=");
        var s_name = null;
        var s_value = null;
        if (i_equal >= 0 && i_equal < i_end) {
            s_name = s_line.substring(i_start, i_start + (i_equal - i_start));
            s_value = s_line.substring(i_equal + 1, i_equal + (i_end - i_equal));
        }
        else {
            s_name = s_line;
        }
        return tsk_param_create(s_name, s_value);
    }
    return null;
}

function tsk_param_get_index_by_name(ao_params, s_name) {
    if (ao_params && !tsk_string_is_null_or_empty(s_name)) {
        var s_name_i = s_name.toLowerCase();
        for(var i = 0; i < ao_params.length; ++i){
            if(ao_params[i].s_name.toLowerCase() == s_name_i){
                return i;
            }
        }
    }
    return -1;
}

function tsk_param_get_by_name(ao_params, s_name) {
    var i_index = tsk_param_get_index_by_name(ao_params, s_name);
    if(i_index != -1){
        return ao_params[i_index];
    }
    return null;
}

function tsk_param_get_value_by_name(ao_params, s_name) {
    var o_param = tsk_param_get_by_name(ao_params, s_name);
    if(o_param){
        return o_param.s_value;
    }
    return null;
}

function tsk_params_have_param(ao_params, s_name) {
    return tsk_param_get_by_name(ao_params, s_name) != null;
}

function tsk_params_add(ao_params, s_name, s_value){
    if(ao_params && !tsk_string_is_null_or_empty(s_name)){
        var i_index = tsk_param_get_index_by_name(ao_params, s_name);
        if(i_index != -1){
            ao_params[i_index].s_value = s_value;
        }
        else{
            ao_params.push(tsk_param_create(s_name, s_value));
        }
    }
}

function tsk_params_add_param(ao_params, o_param) {
    if (ao_params && o_param) {
        tsk_params_add(ao_params, o_param.s_name, o_param.s_value);
    }
}

function tsk_params_remove_by_name(ao_params, s_name){
    if(ao_params && !tsk_string_is_null_or_empty(s_name)){
        var i_index = tsk_param_get_index_by_name(ao_params, s_name);
        if(i_index != -1){
            ao_params.splice(i_index, 1);
        }
    }
}

function tsk_param_tostring(o_param){
    if(o_param && o_param.s_name){
        return  !tsk_string_is_null_or_empty(o_param.s_value) ? (o_param.s_name + "=" + o_param.s_value) : o_param.s_name;
    }
    return "";
}

function tsk_params_tostring(o_params, c_separator){
    var s_ret = "";
    if(o_params){
        for (var i = 0; i < o_params.length; ++i) {
            if (!tsk_string_is_null_or_empty(s_ret)) {
                s_ret += c_separator;
            }
            s_ret += tsk_param_tostring(o_params[i]);
        }
    }
    return s_ret;
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
function tsk_ragel_state_create() {
    var self = new Object();
    tsk_ragel_state_init(self, null, 0);
    return self;
}

function tsk_ragel_state_init(o_self, o_data, i_size) {
    o_self.i_cs = 0;
    o_self.i_p = 0;
    o_self.i_pe = i_size;
    o_self.o_data = o_data;
    o_self.s_data = null;
    o_self.i_eof = 0;
    o_self.i_tag_start = 0;
    o_self.i_tag_end = i_size;
}

function tsk_ragel_state_init_ai(o_self, ai_data) {
    return tsk_ragel_state_init_str(o_self, tsk_buff_ab2str(ai_data));
}

function tsk_ragel_state_init_str(o_self, s_str) {
    tsk_ragel_state_init(o_self, tsk_buff_str2ib(s_str), s_str.length);
    o_self.s_data = s_str;
}

function tsk_ragel_parser_get_string(s_str, i_p, i_tag_start) {
    var i_len = (i_p - i_tag_start);
    var s_ret = null;
    if (i_len > 0) {
        s_ret = s_str.substring(i_tag_start, (i_tag_start + i_len));
    }
    return s_ret;
}

function tsk_ragel_parser_get_int(s_str, i_p, i_tag_start) {
    var i_ret = 0;
    var s_curr = tsk_ragel_parser_get_string(s_str, i_p, i_tag_start);
    if (!tsk_string_is_null_or_empty(s_curr)) {
        i_ret = parseInt(s_curr);
    }
    return i_ret;
}

function tsk_ragel_parser_get_param(s_str, i_p, i_tag_start) {
    if (!tsk_string_is_null_or_empty(s_str)) {
        var i_len = (i_p - i_tag_start);
        return tsk_param_parse(s_str.substring(i_tag_start, i_tag_start + i_len));
    }
    return null;
}

function tsk_ragel_add_param(s_str, i_p, i_tag_start, ao_params) {
    var o_param = tsk_ragel_parser_get_param(s_str, i_p, i_tag_start);
    if (o_param) {
        ao_params.push(o_param);
    }
}

function tsk_ragel_parser_add_string(s_str, i_p, i_tag_start, sa_strings){
    var s_curr = tsk_ragel_parser_get_string(s_str, i_p, i_tag_start);
    if (!tsk_string_is_null_or_empty(s_curr)) {
        sa_strings.push(s_curr);
    }
    return sa_strings;
}

function tsk_ragel_scanner_get_string(s_str, i_ts, i_te){
    var i_len = (i_te - i_ts);
    var s_ret = null;
    if(i_len > 0){
        s_ret = s_str.substring(i_ts, (i_ts + i_len));
    }
    return s_ret;
}

function tsk_ragel_scanner_get_int(s_str, i_ts, i_te){
    var s_curr = tsk_ragel_scanner_get_string(s_str, i_ts, i_te);
    if(s_curr){
        return parseInt(s_curr);
    }
    return 0;
}

function tsk_tagel_scanner_add_param(s_str, i_ts_i_te, ao_params) {
    if (ao_params && !tsk_string_is_null_or_empty(s_str)) {
        var i_len = (te - ts);
        var o_param = tsk_param_parse(s_str.substring(i_ts, i_ts + i_len));
        ao_params.push(o_param);
    }
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
function tsk_string_is_null_or_empty(s_str) {
    return !s_str || s_str == "";
}

function tsk_string_is_string(o_str) {
    return (o_str instanceof String || typeof o_str == "string");
}


function tsk_string_index_of(s_str, i_len, s_substr){
    var i_ret = -1;
    if(s_str && s_substr){
        i_ret = s_str.indexOf(s_substr);
    }
    return i_ret < i_len ? i_ret : -1;
}

function tsk_string_contains(s_str, i_len, s_substr){
    return tsk_string_index_of(s_str, i_len, s_substr) >= 0;
}

function tsk_string_unquote(s_str, c_lquote, c_rquote){
    var s_ret = s_str;
    if(s_ret){
        var i_len = s_ret.length;
        if(i_len >= 2 && s_ret[0] == c_lquote && s_ret[i_len - 1] == c_rquote){
            s_ret = s_str.substring(1, i_len - 1);
        }
    }
    return s_ret;
}

function tsk_string_unquote_2(s_str){
    return tsk_string_unquote(s_str, "\"", "\"");
}

function tsk_strdup(s_str) {
    if (s_str) {
        return new String(s_str).toString();
    }
    return s_str;
}

// tsk_string_format(s_format, ...)
function tsk_string_format(s_str) {
    for (var i = 1; i < arguments.length; i++) {
        var regexp = new RegExp('\\{' + (i - 1) + '\\}', 'gi');
        s_str = s_str.replace(regexp, arguments[i]);
    }
    return s_str;
};

function tsk_string_equals(s_1, s_2) {
    return (s_1 == s_2);
}

function tsk_string_iequals(s_1, s_2) {
    if (s_1 && s_2) {
        return s_1.toLowerCase() == s_2.toLowerCase();
    }
    return (s_1 == s_2);
}

function tsk_string_random_from_dict(i_length, s_dict) {
    var s_ret = "";
    for (var i = 0; i < i_length; i++) {
        s_ret += s_dict[Math.floor(Math.random() * s_dict.length)];
    }
    return s_ret;
}

function tsk_string_random(i_length) {
    var s_dict = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
    return tsk_string_random_from_dict(i_length, s_dict);
}

function tsk_string_random_uuid() {
    // e.g. 6ba7b810-9dad-11d1-80b4-00c04fd430c8
    var s_dict = "0123456789abcdef";
    return tsk_string_format("{0}-{1}-{2}-{3}-{4}",
            tsk_string_random_from_dict(8, s_dict),
            tsk_string_random_from_dict(4, s_dict),
            tsk_string_random_from_dict(4, s_dict), 
            tsk_string_random_from_dict(4, s_dict),
            tsk_string_random_from_dict(12, s_dict));
}

function tsk_string_to_int(s_str, i_default) {
    try{ return parseInt(s_str); }
    catch(e){ return i_default; }
}

function tsk_string_to_object(s_str) {
     if(!tsk_string_is_null_or_empty(s_str)){
        try{ eval("var obj = " + s_str + ";"); return obj; }
        catch(e){}
     }
}

// s_url: <scheme>://<host>:<port>/<dir>
// <dir> is optional
// s_url: udp://192.168.0.10:8545/ws
// @return array is succeed or null otherwise
function tsk_string_parse_url(s_url) {
    if (!s_url) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    var i_0 = s_url.indexOf("://");
    var i_1 = s_url.lastIndexOf(":");
    if (i_0 == -1 || i_1 == -1) {
        tsk_utils_log_error(s_url + " not valid as url");
        return null;
    }
    var ao_params = new Array();
    ao_params.push(s_url.substring(0, i_0));
    ao_params.push(s_url.substring((i_0 + 3), i_1));

    try {
        var i_3 = s_url.substring(i_0 + 3).indexOf("/");
        if (i_3 == -1) {
            ao_params.push(parseInt(s_url.substring(i_1 + 1), 10));
        }
        else {
            ao_params.push(parseInt(s_url.substring(i_1 + 1, i_3 + i_0 + 3), 10));
            ao_params.push(s_url.substring(i_3 + i_0 + 3 + 1));
        }
    }
    catch (e) {
        tsk_utils_log_error(e);
        return null;
    }

    return ao_params;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

function tsk_utils_init_webrtc() {
    // WebRtc plugins
    WebRtc4all_Init();
}

function tsk_utils_have_websocket() {
    try {
        return !!window.WebSocket;
    }
    catch (e) {
        return false;
    }
}

function tsk_utils_have_webrtc() {
    return (WebRtc4all_GetType() != WebRtcType_e.NONE);
}

function tsk_utils_have_webrtc4all() {
    return (tsk_utils_have_webrtc4npapi() || tsk_utils_have_webrtc4ie());
}

function tsk_utils_have_webrtc4npapi() {
    return (WebRtc4all_GetType() == WebRtcType_e.NPAPI);
}

function tsk_utils_have_webrtc4ie() {
    return (WebRtc4all_GetType() == WebRtcType_e.IE);
}

function tsk_utils_have_webrtc4native() {
    return (WebRtc4all_GetType() == WebRtcType_e.NATIVE);
}

function tsk_utils_have_webrtc4ericsson() {
    return (WebRtc4all_GetType() == WebRtcType_e.ERICSSON);
}

function tsk_utils_webrtc4all_get_version() {
    return WebRtc4all_GetVersion();
}

function tsk_utils_have_stream() {
    try {
        return (tsk_utils_have_webrtc4all() || !!navigator.nativeGetUserMedia);
    }
    catch (e) { }
    return false;
}

var __s_navigator_friendly_name = undefined;
function tsk_utils_get_navigator_friendly_name(){
    if(!__s_navigator_friendly_name){
        __s_navigator_friendly_name = 'unknown';
        if (navigator.userAgent || navigator.appName) {
            var ao_friendly_names = [
                {s_id: 'chrome', s_name: 'chrome'},
                {s_id: 'firefox', s_name: 'firefox'},
                {s_id: 'safari', s_name: 'safari'},
                {s_id: 'opera', s_name: 'opera'},
                {s_id: 'microsoft internet explorer', s_name: 'ie'},
                {s_id: 'netscape', s_name: 'netscape'}
            ];
            var s_userAgent = navigator.userAgent ? navigator.userAgent.toLowerCase() : 'null';
            var s_appName = navigator.appName ? navigator.appName.toLowerCase() : 'null';
            for (var i_index = 0; i_index < ao_friendly_names.length; ++i_index) {
                if (s_userAgent.indexOf(ao_friendly_names[i_index].s_id) != -1 || s_appName.indexOf(ao_friendly_names[i_index].s_id) != -1) {
                    __s_navigator_friendly_name = ao_friendly_names[i_index].s_name;
                    break;
                }
            }
        }
    }
    return __s_navigator_friendly_name;
}

var __s_system_friendly_name = undefined;
function tsk_utils_get_system_friendly_name(){
    if(!__s_system_friendly_name){
        __s_system_friendly_name = 'unknown';
        if (navigator.appVersion) {
            var ao_friendly_names = [
                {s_id: 'mac', s_name: 'mac'},
                {s_id: 'powerpc', s_name: 'powerpc'},
                {s_id: 'win', s_name: 'windows'},
                {s_id: 'sunos', s_name: 'sunos'},
                {s_id: 'linux', s_name: 'linux'}
            ];
            var s_appVersion = navigator.appVersion.toLowerCase();
            for (var i_index = 0; i_index < ao_friendly_names.length; ++i_index) {
                if (s_appVersion.indexOf(ao_friendly_names[i_index].s_id) != -1) {
                    __s_system_friendly_name = ao_friendly_names[i_index].s_name;
                    break;
                }
            }
        }
    }
    return __s_system_friendly_name;
}


var __i_debug_level = 4; // INFO:4, WARN:3, ERROR:2, FATAL:1

function tsk_utils_log_set_level(i_level) {
    __i_debug_level = i_level;
}

function tsk_utils_log_info(s_msg) {
    if (window.console && (__i_debug_level >= 4))
        tsk_utils_log("info", s_msg);
}

function tsk_utils_log_warn(s_msg) {
    if (window.console && (__i_debug_level >= 3))
        tsk_utils_log("warn", s_msg);
}

function tsk_utils_log_error(s_msg) {
    if (window.console && (__i_debug_level >= 2))
        tsk_utils_log("error", s_msg);
}

function tsk_utils_log(level, s_msg) {
    if (window.console && window.console[level]) {
        var date = new Date();
        window.console[level]("[" + date.getHours() + ":" + date.getMinutes() +
            ":" + date.getSeconds() + "] " + s_msg);

    }
}

function tsk_utils_log_fatal(s_msg) {
    if(__i_debug_level >= 1) {
        tsk_utils_log_error(s_msg);
    }
}


var sipml5_version = '1.3.203';

tsk_utils_log_info('SIPML5 API version = ' + sipml5_version);

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var tmedia_type_e =
{
    NONE: { i_id: 0, s_name: null },
    GHOST: { i_id: (0x01 << 0), s_name: null },

    AUDIO: { i_id: (0x01 << 1), s_name: "audio" },
    VIDEO: { i_id: (0x01 << 2), s_name: "video" },
    CHAT: { i_id: (0x01 << 3), s_name: "message" },
    FILE: { i_id: (0x01 << 4), s_name: "message" },
    T38: { i_id: (0x01 << 5), s_name: "t38" },
    SCREEN_SHARE: { i_id: (0x01 << 2) | (0x01 << 6) /* VIDEO + SCREENSHARE */, s_name: "sccreen share" },

    MSRP: { i_id: (0x01 << 3) | (0x01 << 4)/* (CHAT.i_id | FILE.i_id) */, s_name: "message" },
    AUDIO_VIDEO: { i_id: (0x01 << 1) | (0x01 << 2)/* (AUDIO.i_id | VIDEO.i_id) */, s_name: "audio/video" },

    ALL: { i_id: 0xFF, s_name: "all" }
};


if(!window.__b_release_mode){
    tmedia_api_add_js_scripts('head',
    'src/tinyMEDIA/src/tmedia_webrtc4all.js', // must be first
    'src/tinyMEDIA/src/tmedia_defaults.js',
    'src/tinyMEDIA/src/tmedia_session.js'
    );
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
// "http://tools.ietf.org/html/draft-uberti-rtcweb-jsep-02" implementation for Safari, Opera, Firefox and IE

w4aPeerConnection.prototype.s_configuration = null;
w4aPeerConnection.prototype.f_IceCallback = null;
w4aPeerConnection.prototype.f_Rfc5168Callback;
w4aPeerConnection.prototype.o_peer = null;
w4aPeerConnection.prototype.localDescription = null; // part of the standard
w4aPeerConnection.prototype.remoteDescription = null; // part of the standard

w4aSessionDescription.prototype.o_sdp = null;

w4aIceCandidate.prototype.media = null;
w4aIceCandidate.prototype.label = null; // part of the standard

var __o_roap_stream = null;
var __o_jsep_stream_audio = null;
var __o_jsep_stream_audiovideo = null;

var WebRtcType_e =
{
    NONE: -1,

    NATIVE: 0,

    IE: 1, // W4A
    NPAPI: 2, // W4A
    W4A: 3, // TEMP type before knowing which one to use

    ERICSSON: 4
};

var __webrtc_type = WebRtcType_e.NONE;
var __b_webrtc4all_initialized = false;
var __b_webrtc4ie_peerconn = undefined;
function WebRtc4all_Init() {
    if (!__b_webrtc4all_initialized) {
        try {
            // NPAPI plugin object
            var oWebRtc4npapi = document.createElement('embed');
            oWebRtc4npapi.id = "WebRtc4npapi";
            oWebRtc4npapi.type = "application/w4a";
            oWebRtc4npapi.width = oWebRtc4npapi.height = '1px';
            oWebRtc4npapi.stype = 'visibility:hidden;';
            document.body.appendChild(oWebRtc4npapi);
        }
        catch (e) { }        

        // WebRtc plugin type
        try {
            if (__webrtc_type == WebRtcType_e.NONE) {
                window.nativeRTCPeerConnection = (window.webkitPeerConnection00 || window.webkitRTCPeerConnection || window.mozRTCPeerConnection);
                window.nativeRTCSessionDescription = (window.mozRTCSessionDescription || window.RTCSessionDescription); // order is very important: "RTCSessionDescription" defined in Nighly but useless
                window.nativeRTCIceCandidate = (window.mozRTCIceCandidate || window.RTCIceCandidate);
                navigator.nativeGetUserMedia = (navigator.webkitGetUserMedia || navigator.mozGetUserMedia);
                if ((navigator.nativeGetUserMedia && window.nativeRTCPeerConnection)) {
                    __webrtc_type = WebRtcType_e.NATIVE; // Google Chrome
                }
                else if (navigator.nativeGetUserMedia && window.webkitPeerConnection) {
                    __webrtc_type = WebRtcType_e.ERICSSON;
                }
           }
        }
        catch (e) { }
        if (__webrtc_type == WebRtcType_e.NONE || __webrtc_type == WebRtcType_e.W4A) {
            try {
                if ((__b_webrtc4ie_peerconn = new ActiveXObject("webrtc4ie.PeerConnection"))) {
                    __webrtc_type = WebRtcType_e.IE; // Internet Explorer
                }
            }
            catch (e) {
                if (WebRtc4npapi.supportsPeerConnection) {
                    __webrtc_type = WebRtcType_e.NPAPI; // Opera, Firefox or Safari
                }
            }
        }

        __b_webrtc4all_initialized = true;

        if (navigator.nativeGetUserMedia && WebRtc4all_GetType() == WebRtcType_e.ERICSSON) {
            navigator.nativeGetUserMedia("audio, video",
                    function (stream) {
                        tsk_utils_log_info("Got stream :)");
                        __o_roap_stream = stream;
                    },
                    function (error) {
                        tsk_utils_log_error(error);
                    });
        }
    }
}

function WebRtc4all_GetVersion() {
    try {
        if (__webrtc_type == WebRtcType_e.IE) {
            return __b_webrtc4ie_peerconn.version;
        }
        else if (__webrtc_type == WebRtcType_e.NPAPI) {
            return WebRtc4npapi.version;
        }
    }
     catch (e) { }
     return "0.0.0.0";
}

// This function must be called before "WebRtc4all_Init()"
function WebRtc4all_SetType(s_type) {
    if (__webrtc_type != WebRtcType_e.NONE) {
        tsk_utils_log_error("Trying not set default webrtc type after init() is not allowed");
        return false;
    }
    switch (s_type) {
        case "w4a":
            __webrtc_type = WebRtcType_e.W4A;
            break;
        case "ericsson":
            __webrtc_type = WebRtcType_e.ERICSSON;
            break;
        case "native":
            __webrtc_type = WebRtcType_e.NATIVE;
            break;
        default:
            tsk_utils_log_error("[" + s_type + "] not valid as default webrtc type");
            return false;
    }
    return true;
}

function WebRtc4all_GetType() {
    return __webrtc_type;
}

var __looper = undefined;
function WebRtc4all_GetLooper() {
    if (__looper == undefined && tsk_utils_have_webrtc4ie()) {
        try {
            if (fakeLooper && fakeLooper.hWnd) {
                __looper = fakeLooper.hWnd;
            }
            else if ((__o_display_local && __o_display_local.hWnd) || (__o_display_remote && __o_display_remote.hWnd)) {
                __looper = (__o_display_local && __o_display_local.hWnd) ? __o_display_local.hWnd : __o_display_remote.hWnd;
            }
            else {
                // TODO: This function fails to create looper on IE11.
                // https://code.google.com/p/sipml5/issues/detail?id=161
                var oLooper = document.createElement('object');
                oLooper.classid = "clsid:7082C446-54A8-4280-A18D-54143846211A";
                oLooper.width = oLooper.height = '1px';
                document.body.appendChild(oLooper);
                __looper = oLooper.hWnd;
          }
          if (!__looper) {
            tsk_utils_log_error("Failed to create looper. Your app may crash on IE11");
          }
        }
        catch (e) {
            tsk_utils_log_error(e);
            __looper = null;
        }
    }
    return __looper;
}

function WebRtc4all_SetDisplays(o_local_elt, o_remote_elt) {
    if (__webrtc_type == WebRtcType_e.IE) {
        // visiblity must be "visible"  for the first time to force handle creation
        if (o_local_elt) {
            o_local_elt.innerHTML = "<object id=\"__o_display_local\" classid=\"clsid:5C2C407B-09D9-449B-BB83-C39B7802A684\"" +
                                    " class=\"video\" width=\"88px\" height=\"72px\" style=\"margin-top: -80px; margin-left: 5px; background-color: #000000; visibility:visible\"> </object>";
            __o_display_local.style.visibility = "hidden";
        }
        if (o_remote_elt) {
            o_remote_elt.innerHTML = "<object id=\"__o_display_remote\" classid=\"clsid:5C2C407B-09D9-449B-BB83-C39B7802A684\"" +
                                     " width=\"100%\" height=\"100%\" style=\"visibility:visible;\"> </object>";
            __o_display_remote.style.visibility = "hidden";
        }
    }
    else if (__webrtc_type == WebRtcType_e.NPAPI) {
        if (o_local_elt) {
            o_local_elt.innerHTML = "<embed id=\"__o_display_local\" type=\"application/w4a-display\"" +
                                    " class=\"video\" width=\"88px\" height=\"72px\" style=\"margin-top: -80px; margin-left: 5px; background-color: #000000; visibility:visible\"> </embed>";
            __o_display_local.style.visibility = "hidden";
        }
        if (o_remote_elt) {
            o_remote_elt.innerHTML = "<embed id=\"__o_display_remote\" type=\"application/w4a-display\"" +
                                     " width=\"100%\" height=\"100%\" style=\"visibility:visible;\"> </embed>";
            __o_display_remote.style.visibility = "hidden";
        }
    }
}

function w4aSessionDescription(s_sdp) {
    if (!__b_webrtc4all_initialized) {
        WebRtc4all_Init();
    }
    var b_isInternetExplorer = (__webrtc_type == WebRtcType_e.IE);
    this.o_sdp = b_isInternetExplorer ? new ActiveXObject("webrtc4ie.SessionDescription") : WebRtc4npapi.createSessionDescription();
    this.o_sdp.Init(s_sdp ? (s_sdp + "") : null);
}

w4aSessionDescription.prototype.toSdp = function () {
    return this.o_sdp.toSdp();
}
w4aSessionDescription.prototype.toString = w4aSessionDescription.prototype.toSdp;

w4aSessionDescription.prototype.addCandidate = function (o_candidate) {
    if(o_candidate && o_candidate.media && o_candidate.label) {
        this.o_sdp.addCandidate(o_candidate.media, o_candidate.label);
    }
}

function w4aIceCandidate(media, label) {
    this.media = media;
    this.label = label;
}

w4aIceCandidate.prototype.toSdp = function () {
    return this.label;
};

function w4aPeerConnection(s_configuration, f_IceCallback) {
    if (!__b_webrtc4all_initialized) {
        WebRtc4all_Init();
    }
    var This = this;
    var b_isInternetExplorer = (__webrtc_type == WebRtcType_e.IE);
    this.s_configuration = s_configuration;
    this.f_IceCallback = f_IceCallback;
    this.o_peer = b_isInternetExplorer ? new ActiveXObject("webrtc4ie.PeerConnection") : WebRtc4npapi.createPeerConnection();
    this.o_peer.Init(s_configuration);

    // attach displays if defined by the user
    try { this.o_peer.localVideo = (window.__o_display_local ? window.__o_display_local.hWnd : 0); } catch (e) { }
    try { this.o_peer.remoteVideo = (window.__o_display_remote ? window.__o_display_remote.hWnd : 0); } catch (e) { }

    // register callback function
    if (b_isInternetExplorer) {
        eval("function This.o_peer::IceCallback(media, label, bMoreToFollow) { return This.onIceCallback (media, label, bMoreToFollow); }");
        eval("function This.o_peer::Rfc5168Callback(command) { return This.onRfc5168Callback(command); }");
    }
    else {
        this.o_peer.opaque = This;
        this.o_peer.setCallbackFuncName("w4aPeerConnection_NPAPI_OnEvent");
        if (this.o_peer.setRfc5168CallbackFuncName) {
            this.o_peer.setRfc5168CallbackFuncName("w4aPeerConnection_NPAPI_OnRfc5168Event");
        }
    }
};


// actions, for setLocalDescription/setRemoteDescription
w4aPeerConnection.SDP_OFFER = 0x100;
w4aPeerConnection.SDP_PRANSWER = 0x200;
w4aPeerConnection.SDP_ANSWER = 0x300;

// PeerConnection state
w4aPeerConnection.NEW = 0;     // initial state
w4aPeerConnection.OPENING = 1; // local or remote desc set
w4aPeerConnection.ACTIVE = 2;  // local and remote desc set
w4aPeerConnection.CLOSED = 3;  // ended state

// ICE state
w4aPeerConnection.ICE_GATHERING = 0x100;
w4aPeerConnection.ICE_WAITING = 0x200;
w4aPeerConnection.ICE_CHECKING = 0x300;
w4aPeerConnection.ICE_CONNECTED = 0x400;
w4aPeerConnection.ICE_COMPLETED = 0x500;
w4aPeerConnection.ICE_FAILED = 0x600;
w4aPeerConnection.ICE_CLOSED = 0x700;

// SessionDescription createOffer (MediaHints hints)
w4aPeerConnection.prototype.createOffer = function (o_hints) {
    if ((__webrtc_type == WebRtcType_e.IE)) {
        return new w4aSessionDescription(this.o_peer.createOffer(o_hints.has_audio, o_hints.has_video));
    }
    else {
        var oSdp = this.o_peer.createOffer(o_hints.has_audio, o_hints.has_video);
        if (oSdp) {
            return new w4aSessionDescription(oSdp.toSdp());
        }
        return null;
    }
}

// SessionDescription createAnswer (DOMString offer, MediaHints hints);
w4aPeerConnection.prototype.createAnswer = function (s_offer, o_hints) {
    if ((__webrtc_type == WebRtcType_e.IE)) {
        return new w4aSessionDescription(this.o_peer.createAnswer(o_hints.has_audio, o_hints.has_video));
    }
    else {
        var oSdp = this.o_peer.createAnswer(o_hints.has_audio, o_hints.has_video);
        if (oSdp) {
            return new w4aSessionDescription(oSdp.toSdp());
        }
        return null;
    }
}

// void setLocalDescription (unsigned short action, SessionDescription desc);
w4aPeerConnection.prototype.setLocalDescription = function (i_action, o_desc) {
    this.o_peer.setLocalDescription(i_action, (__webrtc_type == WebRtcType_e.IE) ? o_desc.toSdp() : o_desc.o_sdp);
    this.localDescription = new w4aSessionDescription(this.o_peer.localDescription);
}

// void setRemoteDescription (unsigned short action, SessionDescription desc);
w4aPeerConnection.prototype.setRemoteDescription = function (i_action, o_desc) {
    this.o_peer.setRemoteDescription(i_action, (__webrtc_type == WebRtcType_e.IE) ? o_desc.toSdp() : o_desc.o_sdp);
    this.remoteDescription = new w4aSessionDescription(this.o_peer.remoteDescription);
}

// void startIce (optional IceOptions options);
w4aPeerConnection.prototype.startIce = function (o_options) {
    this.o_peer.startIce(0/* all */, WebRtc4all_GetLooper());
}

// void startMedia (void);
// Not part of the specification
// In native WebRTC, media is started when ICE negotiation complete. For WebRTC4all we cannot rely on ICE as it's optional.
w4aPeerConnection.prototype.startMedia = function (o_options) {
    if(this.o_peer /*&& this.o_peer.startMedia*/) {
        // startMedia() introduced when ICE become optional. "if(this.o_peer.startMedia)" always returns false on IE.
        try { this.o_peer.startMedia(); }
        catch (e) { }
    }
}

// void processIceMessage (IceCandidate candidate);
w4aPeerConnection.prototype.processIceMessage = function (o_candidate) {
    tsk_utils_log_error("Not implemented"); // we expect all ICE candidates in the SDP offer (SIP)
}

// void addStream (MediaStream stream, MediaStreamHints hints);
w4aPeerConnection.prototype.addStream = function (o_stream, o_hints) {
}

// void removeStream (MediaStream stream);
w4aPeerConnection.prototype.removeStream = function (o_stream) {
}

// void processContent(const char* req_name, const char* content_type, const void* content_ptr, int content_size)
// Not part of the specification
w4aPeerConnection.prototype.processContent = function (s_req_name, s_content_type, s_content_ptr, i_content_size) {
    if (this.o_peer) {
        try { this.o_peer.processContent(s_req_name, s_content_type, s_content_ptr, i_content_size); }
        catch (e) { }
    }
}

// void close()
w4aPeerConnection.prototype.close = function () {
    if (this.o_peer) {
        this.o_peer.close();
    }
}

w4aPeerConnection.prototype.onIceCallback = function (media, label, bMoreToFollow) {
    tsk_utils_log_info("w4aPeerConnection::onIceCallback(" + media + "," + label + "," + bMoreToFollow + ")");
    this.iceState = this.o_peer.iceState;
    if (this.f_IceCallback) {
        this.f_IceCallback(new w4aIceCandidate(media, label), bMoreToFollow);
    }
}


function w4aPeerConnection_NPAPI_OnEvent(o_peer, sMedia, sLabel, bMoreToFollow) {
    o_peer.onIceCallback(sMedia, sLabel, bMoreToFollow);
}

w4aPeerConnection.prototype.onRfc5168Callback = function (command) {
    tsk_utils_log_info("w4aPeerConnection::onRfc5168Callback(" + command+ ")");
    if (this.o_mgr && this.o_mgr.callback) {
        if (command === "picture_fast_update") {
            this.o_mgr.callback(tmedia_session_events_e.RFC5168_REQUEST_IDR, this.o_mgr.e_type);
        }
    }
    else {
        tsk_utils_log_error("No manager associated to this peerconnection");
    }
}

function w4aPeerConnection_NPAPI_OnRfc5168Event(o_peer, sCommand) {
    o_peer.onRfc5168Callback(sCommand);
}


/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var __tmedia_defaults_e_media_type = tmedia_type_e.AUDIO_VIDEO;

function tmedia_defaults_get_media_type() {
    return __tmedia_defaults_e_media_type;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

var __o_peerconnection_class = undefined;
var __o_sessiondescription_class = undefined;
var __o_iceCandidate_class = undefined;

var tmedia_session_events_e =
{
    GET_LO_SUCCESS: 0,
    GET_LO_FAILED: 1,

    SET_RO_SUCCESS: 10,
    SET_RO_FAILED: 11,

    SET_ACK_SUCCESS: 20,
    SET_ACK_FAILED: 21,

    STREAM_LOCAL_REQUESTED: 30,
    STREAM_LOCAL_ACCEPTED: 31,
    STREAM_LOCAL_REFUSED: 32,
    STREAM_LOCAL_ADDED: 33,
    STREAM_LOCAL_REMOVED: 34,
    STREAM_REMOTE_ADDED: 35,
    STREAM_REMOTE_REMOVED: 36,

    RFC5168_REQUEST_IDR: 40
};

tmedia_session_mgr.prototype.__ao_supported_media = [tmedia_type_e.AUDIO, tmedia_type_e.VIDEO];

// fn_callback(o_usr_data, e_event_type, e_media_type)
function tmedia_session_mgr(e_type, s_addr, b_ipv6, b_offerer, fn_callback, o_usr_data) {
    this.s_addr = s_addr;
    this.s_public_addr = null;
    this.b_ipv6 = b_ipv6;

    this.fn_callback = fn_callback;
    this.o_usr_data = o_usr_data;

    this.sdp = {};
    this.sdp.i_lo_ver = -1;
    this.sdp.o_lo = null;
    this.sdp.i_ro_ver = -1;
    this.sdp.o_ro = null;

    this.o_stream_local = null;
    this.o_stream_remote = null;

    this.b_started = false;
    this.b_ro_changed = false;
    this.b_lo_changed = false;
    this.b_state_changed = false;
    this.b_media_type_changed = false;

    this.e_type = e_type;
    this.ao_sessions = new Array();
    this.ao_params = new Array();

    // initialize media classes
    // Must be done before loading sessions
    if (__o_peerconnection_class == undefined) {
        if (tsk_utils_have_webrtc4all()) {
            __o_peerconnection_class = w4aPeerConnection;
            __o_sessiondescription_class = w4aSessionDescription;
            __o_iceCandidate_class = w4aIceCandidate;
        }
        else if (tsk_utils_have_webrtc()) {
            // https://groups.google.com/group/discuss-webrtc/browse_thread/thread/ccaff9c94aa2aac1
        if (WebRtc4all_GetType() == WebRtcType_e.NATIVE) {
                if (window.webkitPeerConnection00 && window.SessionDescription && window.IceCandidate) {
                    __o_peerconnection_class = window.webkitPeerConnection00;
                    __o_sessiondescription_class = window.SessionDescription;
                    __o_iceCandidate_class = window.IceCandidate;
                }
                else if (window.nativeRTCPeerConnection && window.nativeRTCSessionDescription && window.nativeRTCIceCandidate) {
                    __o_peerconnection_class = window.nativeRTCPeerConnection;
                    __o_sessiondescription_class = window.nativeRTCSessionDescription;
                    __o_iceCandidate_class = window.nativeRTCIceCandidate;
                }
            }
            else if (WebRtc4all_GetType() == WebRtcType_e.ERICSSON) {
                if (window.webkitPeerConnection) {
                    __o_peerconnection_class = window.webkitPeerConnection;
                }
            }
        }

        tsk_utils_log_info("PeerConnectionClass = " + (__o_peerconnection_class || "unknown") + 
                            " SessionDescriptionClass = " + (__o_sessiondescription_class || "unknown") +
                            " IceCandidateClass = " + (__o_iceCandidate_class || "unknown")
                            );
    }

    if (b_offerer) {
        this.load_sessions();
    }
}

tmedia_session_mgr.prototype.is_roap = function () {
    return (WebRtc4all_GetType() == WebRtcType_e.ERICSSON);
}

tmedia_session_mgr.prototype.is_jsep = function () {
    return !this.is_roap();
}

tmedia_session_mgr.prototype.get_stream_local = function () {
    return this.o_stream_local;
}

tmedia_session_mgr.prototype.get_stream_remote = function () {
    return this.o_stream_remote;
}

tmedia_session_mgr.prototype.set_stream_local = function (o_stream) {
    this.o_stream_local = o_stream;
    this.callback(o_stream ? tmedia_session_events_e.STREAM_LOCAL_ADDED : tmedia_session_events_e.STREAM_LOCAL_REMOVED, tmedia_type_e.VIDEO);
}

tmedia_session_mgr.prototype.set_stream_remote = function (o_stream) {
    this.o_stream_remote = o_stream;
    this.callback(o_stream ? tmedia_session_events_e.STREAM_REMOTE_ADDED : tmedia_session_events_e.STREAM_REMOTE_REMOVED, tmedia_type_e.VIDEO);
}

tmedia_session_mgr.prototype.set_fn_callback = function (fn_callback, o_usr_data) {
    this.fn_callback = fn_callback;
    this.o_usr_data = o_usr_data;
}

tmedia_session_mgr.prototype.callback = function (e_event_type, e_media_type) {
    if (this.fn_callback) {
        if (e_event_type == tmedia_session_events_e.GET_LO_SUCCESS) {
            this.b_lo_changed = true;
            if (this.ao_sessions.length > 0) {
                this.sdp.o_lo = this.ao_sessions[0].o_sdp_lo; // ao_sessions[0].get_lo() not used because we don't want to request new SDP but just a reference
            }
        }
        this.fn_callback(this.o_usr_data, e_event_type, e_media_type);
    }
}

tmedia_session_mgr.prototype.set_media_type = function(e_type){

	if(this.e_type != e_type){
		this.b_media_type_changed = true;
		this.e_type = e_type;
	}
	return 0;
}

tmedia_session_mgr.prototype.get_media_type = function () {
    return this.e_type;
}

tmedia_session_mgr.prototype.has_media = function (e_type) {
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        if (this.ao_sessions[i].e_type == e_type) {
            return true;
        }
    }
    return false;
}

tmedia_session_mgr.prototype.has_ro_changed = function () {
    return this.b_ro_changed;
}

tmedia_session_mgr.prototype.has_state_changed = function () {
    return this.b_state_changed;
}

tmedia_session_mgr.prototype.has_active_session = function(){
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        if (this.ao_sessions[i].o_sdp_lo) {
            return true;
        }
    }
    return false;
}

tmedia_session_mgr.prototype.is_started = function () {
    return this.b_started;
}

tmedia_session_mgr.prototype.has_lo = function () {
    return this.sdp.o_lo != null;
}

tmedia_session_mgr.prototype.has_ro = function () {
    return this.sdp.o_ro != null;
}

tmedia_session_mgr.prototype.remove_media = function(e_type){
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        if (this.ao_sessions[i].e_type == e_type) {
            this.ao_sessions[i].stop();
            this.ao_sessions.splice(i, 1);
            break;
        }
    }
}

tmedia_session_mgr.prototype.apply_params = function () {
    var o_param;
    for (var i = 0; i < this.ao_params.length; ++i) {
        if (!(o_param = this.ao_params[i])) {
            continue;
        }

        switch (o_param.e_type) {
            case tmedia_param_type_e.CODEC:
                {
                    break;
                }
            case tmedia_param_type_e.MANAGER:
                {
                    break;
                }
            case tmedia_param_type_e.SESSION:
                {
                    for (var j = 0; j < this.ao_sessions.length; ++j) {
                        if (this.ao_sessions[j].e_type.i_id & o_param.e_media_type.i_id) {
                            this.ao_sessions[j].set(o_param);
                        }
                    }
                    break;
                }
        }
    }

    // clean params
    this.ao_params.splice(0, this.ao_params.length);
}

tmedia_session_mgr.prototype.load_sessions = function () {
    var o_session = null;
    if (this.ao_sessions.length == 0 || this.b_media_type_changed) {
        /* for each registered plugin create a session instance */
        for (var i = 0; i < tmedia_session_mgr.prototype.__ao_supported_media.length; ++i) {
            var e_type = tmedia_session_mgr.prototype.__ao_supported_media[i];
            if ((e_type.i_id & this.e_type.i_id) && !this.has_media(e_type)) {// we don't have a session with this media type yet
                if ((o_session = tmedia_session.prototype.Create(e_type, this))) {
                    this.ao_sessions.push(o_session);
                }
            }
            else if (!(e_type.i_id & this.e_type.i_id) && this.has_media(e_type)) {// we have media session from previous call (before update)
                this.remove_media(e_type);
            }
        }
        /* set default values */
        this.set(
            tmedia_session_mgr.prototype.SetParamSession(this.e_type, "local-ip", this.s_addr),
			tmedia_session_mgr.prototype.SetParamSession(this.e_type, "local-ipver", this.b_ipv6 ? "ipv6" : "ipv4")
        );

        /* apply params */
        this.apply_params(self);
    }
    return 0;
}

tmedia_session_mgr.prototype.__update_ro = function (o_sdp) {
    this.sdp.o_ro = o_sdp;
    var b_ro_held = true;
    // do not use 'is_held()' as 'session.o_ro' are not defined yet
    var i_index = 0;
    var o_hdr_M;
    while ((o_hdr_M = o_sdp.get_header_at(tsdp_header_type_e.M, i_index++))) {
        if (!o_hdr_M.is_held(false)) {
            b_ro_held = false;
            break;
        }
    }
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        this.ao_sessions[i].b_ro_held = b_ro_held;
    }
    return 0;
}

tmedia_session_mgr.prototype.get_lo = function () {
    /* prepare the session manager if not already done (create all sessions) */
    if (this.ao_sessions.length == 0) {
        if (this.load_sessions() != 0) {
            tsk_utils_log_error("Failed to prepare the session manager");
            return null;
        }
    }

    /* creates local sdp if not already done or update it's value (because of set_ro())*/
    if ((this.b_ro_changed || this.b_lo_changed || this.b_state_changed || this.b_mediaType_changed) && this.sdp.o_lo) {
        this.sdp.o_lo = null;
        if (this.b_mediaType_changed) {
            // reload session with new medias and keep the old one
            this.load_sessions();
        }
        this.b_lo_changed = false;
        this.b_ro_changed = false;
        this.b_state_changed = false;
        this.b_mediaType_changed = false;
    }

    if (this.ao_sessions.length > 0) {
        this.sdp.o_lo = this.ao_sessions[0].get_lo();
    }

    return this.sdp.o_lo;
}

tmedia_session_mgr.prototype.set_ro = function (o_sdp, b_is_offer) {
    if (!o_sdp) {
        tsk_utils_log_error("Invalid parameter");
        return -1;
    }

    var i_ret = 0;
    var b_stopped_to_reconf = false;
    var b_is_hold_resume = false;
    var b_is_mediatype_changed = false;
    var e_new_mediatype = tmedia_type_e.NONE;
    var b_is_loopback_address = false;
    var b_had_ro_sdp = (this.sdp.o_ro != null);
    var o_hdr_O;
    var o_hdr_C; /* global "c=" line */

    /*	RFC 3264 subcaluse 8
    When issuing an offer that modifies the session, the "o=" line of the new SDP MUST be identical to that in the previous SDP, 
    except that the version in the origin field MUST increment by one from the previous SDP. If the version in the origin line 
    does not increment, the SDP MUST be identical to the SDP with that version number. The answerer MUST be prepared to receive 
    an offer that contains SDP with a version that has not changed; this is effectively a no-op.
    */
    if ((o_hdr_O = o_sdp.get_header(tsdp_header_type_e.O))) {
        if (this.sdp.i_ro_ver == o_hdr_O.i_sess_version) {
            tsk_utils_log_warn("Remote offer has not changed");
            return 0;
        }
        this.sdp.i_ro_ver = o_hdr_O.i_sess_version;
    }
    else {
        tsk_utils_log_error("o= line is missing");
        return -2;
    }

    /* This is to hack fake forking from ZTE => ignore SDP with loopback address in order to not start/stop the camera several
    * times which leads to more than ten seconds for session connection.
    * Gets the global connection line: "c="
    * Loopback address is only invalid on 
    */
    if ((o_hdr_C = o_sdp.get_header(tsdp_header_type_e.C)) && o_hdr_C.s_addr) {
        b_is_loopback_address = (tsk_string_iequals("IP4", o_hdr_C.s_addrtype) && tsk_string_iequals("127.0.0.1", o_hdr_C.s_addr))
						|| (tsk_string_iequals("IP6", o_hdr_C.s_addrtype) && tsk_string_iequals("::1", o_hdr_C.s_addr));
    }

    /* Check if media type has changed or not
    * For initial offer we don't need to check anything
    */
    if (this.sdp.o_lo) {
        e_new_mediatype = o_sdp.get_media_type();
        if(e_new_mediatype == tmedia_type_e.VIDEO && this.e_type == tmedia_type_e.SCREEN_SHARE) { // "SCREEN_SHARE" will be identified in the SDP as Video when using get_media_type()
            e_new_mediatype = this.e_type;
        }
        if ((b_is_mediatype_changed = (e_new_mediatype != this.e_type))) {
            tsk_utils_log_error("this.set_media_type(e_new_mediatype);");
            //this.set_media_type(e_new_mediatype);
            tsk_utils_log_info("media type has changed");
        }
    }

    /*
    * It's almost impossible to update the codecs, the connection information etc etc while the sessions are running
    * For example, if the video producer is already started then, you probably cannot update its configuration
    * without stoping it and restart again with the right config. Same for RTP Network config (ip addresses, NAT, ports, IP version, ...)
    * "is_loopback_address" is used as a guard to avoid reconf for loopback address used for example by ZTE for fake forking. In all case
    * loopback address won't work on embedded devices such as iOS and Android.
    * FIXME: We must check that it's not a basic hold/resume because this kind of request doesn't update the stream config
    */
    if (this.b_started && !(this.is_roap() || this.is_jsep()) && ((!b_is_hold_resume && !b_is_loopback_address) || b_is_mediatype_changed)) {
        if ((i_ret = this.stop())) {
            tsk_utils_log_error("Failed to stop session manager");
            return i_ret;
        }
        b_stopped_to_reconf = true;
    }

    /* update remote offer */
    this.__update_ro(o_sdp);

    /* prepare the session manager if not already done (create all sessions with their codecs) 
    * if network-initiated: think about tmedia_type_from_sdp() before creating the manager */
    if ((i_ret = this.load_sessions())) {
        tsk_utils_log_error("Failed to prepare the session manager");
        return i_ret;
    }

    /* get global connection line (common to all sessions) 
    * Each session should override this info if it has a different one in its "m=" line
    */
    if (o_hdr_C && o_hdr_C.s_addr) {
        this.set(tmedia_session_mgr.prototype.SetParamSession(this.e_type, "remote-ip", o_hdr_C.s_addr));
    }

    for (var i = 0; i < this.ao_sessions.length; ++i) {
        this.ao_sessions[i].set_ro(o_sdp, b_is_offer);
    }

    /* signal that ro has changed (will be used to update lo) unless there was no ro_sdp*/
    this.b_ro_changed = b_had_ro_sdp;

    /* update local offer before restarting the session manager otherwise neg_codecs won't match if new codecs
    have been added or removed */
    (this.get_lo(self));

    /* manager was started and we stopped it in order to reconfigure it (codecs, network, ....) */
    if (b_stopped_to_reconf) {
        if ((i_ret = this.start())) {
            tsk_utils_log_warn("Failed to re-start session manager");
            return i_ret;
        }
    }

    return 0;
}

tmedia_session_mgr.prototype.processContent = function (s_req_name, s_content_type, s_content_ptr, i_content_size) {
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        this.ao_sessions[i].processContent(s_req_name, s_content_type, s_content_ptr, i_content_size);
    }
}

tmedia_session_mgr.prototype.start = function () {
    var i_ret = 0;
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        if ((i_ret = this.ao_sessions[i].start())) {
            return i_ret;
        }
    }
    this.b_started = true;
    return 0;
}

tmedia_session_mgr.prototype.stop = function () {
    var i_ret = 0;
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        if ((i_ret = this.ao_sessions[i].stop())) {
            return i_ret;
        }
    }
    this.b_started = false;
    return 0;
}

tmedia_session_mgr.prototype.acked = function () {
    var i_ret = 0;
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        if ((i_ret = this.ao_sessions[i].acked())) {
            return i_ret;
        }
    }
    return 0;
}

tmedia_session_mgr.prototype.is_held = function(e_type, b_local){	
	var b_have_these_sessions = false;
    var i_index;
    var o_hdr_M;
    var o_sdp;

	for (var i = 0; i < this.ao_sessions.length; ++i) {
		var o_session = this.ao_sessions[i];
		if (!e_type || (o_session.e_type.i_id & e_type.i_id)) {
            if(b_local && o_session.o_sdp_lo){
                o_sdp = o_session.o_sdp_lo;
            }
            else if(!b_local && o_session.o_sdp_ro){
                o_sdp = o_session.o_sdp_ro;
            }
            else continue;

            b_have_these_sessions = true;
            i_index = 0;
            while((o_hdr_M = o_sdp.get_header_at(tsdp_header_type_e.M, i_index++))){
                if (!o_hdr_M.is_held(b_local)) {
                    return false;
                }
            }
		}
	}
	/* none is held */
	return b_have_these_sessions ? true : false;
}

tmedia_session_mgr.prototype.hold = function (e_type) {
    var i_ret;
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        if (!e_type || (this.ao_sessions[i].e_type.i_id & e_type.i_id)) {
            this.b_state_changed = true;
            if (i_ret = this.ao_sessions[i].hold()) {
                return i_ret;
            }
            this.ao_sessions[i].b_lo_held = true;
        }
    }
    return 0;
}

tmedia_session_mgr.prototype.resume = function (e_type) {
    var i_ret;
    for (var i = 0; i < this.ao_sessions.length; ++i) {
        if (!e_type || (this.ao_sessions[i].e_type.i_id & e_type.i_id)) {
            this.b_state_changed = true;
            if (i_ret = this.ao_sessions[i].resume()) {
                return i_ret;
            }
            this.ao_sessions[i].b_lo_held = false;
        }
    }
    return 0;
}

tmedia_session_mgr.prototype.set = function(){
    for(var i = 0; i < arguments.length; ++i){
        if(arguments[i]){
            this.ao_params.push(arguments[i]);
        }
    }

    /* apply params if we already have sessions */
    if(this.ao_sessions.length > 0){
        this.apply_params();
    }
}

tmedia_session_mgr.prototype.SetParamSession = function (e_media_type, s_key, o_value) {
    return new tmedia_param(tmedia_param_type_e.SESSION, e_media_type, s_key, o_value);
}

tmedia_session_mgr.prototype.SetParamCodec = function (e_media_type, s_key, o_value) {
    return new tmedia_param(tmedia_param_type_e.CODEC, e_media_type, s_key, o_value);
}

tmedia_session_mgr.prototype.SetParam = function (e_media_type, s_key, o_value) {
    return new tmedia_param(tmedia_param_type_e.MANAGER, e_media_type, s_key, o_value);
}






function tmedia_session(e_type, o_mgr) {
    this.e_type = e_type;
    this.b_ro_changed = false;
    this.b_initialized = false;
    this.b_prepared = false;
    this.b_lo_held = false;
    this.b_ro_held = false;

    this.o_sdp = null;
    this.o_mgr = o_mgr;
}

tmedia_session.prototype.set = function (o_param) {
    return this.__set(o_param);
}

tmedia_session.prototype.prepare = function () {
    return this.__prepare();
}

tmedia_session.prototype.start = function () {
    return this.__start();
}

tmedia_session.prototype.pause = function () {
    return this.__pause();
}

tmedia_session.prototype.stop = function () {
    return this.__stop();
}

tmedia_session.prototype.get_lo = function () {
    return this.__get_lo();
}

tmedia_session.prototype.set_ro = function (o_sdp, b_is_offer) {
    return this.__set_ro(o_sdp, b_is_offer);
}

tmedia_session.prototype.processContent = function (s_req_name, s_content_type, s_content_ptr, i_content_size) {
    if (this.__processContent) {
        return this.__processContent(s_req_name, s_content_type, s_content_ptr, i_content_size);
    }
}

tmedia_session.prototype.acked = function () {
    return this.__acked();
}

tmedia_session.prototype.hold = function () {
    return this.__hold();
}

tmedia_session.prototype.resume = function () {
    return this.__resume();
}


tmedia_session.prototype.Create = function (e_type, o_mgr) {
    switch (e_type) {
        case tmedia_type_e.AUDIO:
        case tmedia_type_e.VIDEO:
        case tmedia_type_e.SCREEN_SHARE:
            {
                 // for now we support a single media session per call
                 // The code is based on Doubango ANSI-C code which uses one media type (e.g. 1audio plus 1video) per media session while SIPML5 bundle them (e.g. 1audiovideo)
                if(o_mgr.ao_sessions.length == 0) {
                    if (o_mgr.is_jsep()) {
                        return tmedia_session_jsep.prototype.CreateInstance(o_mgr);
                    }
                    else {
                        return new tmedia_session_roap(o_mgr);
                    }
                }
                return null;
            }
        case tmedia_type_e.GHOST:
            {
                return new tmedia_session_ghost(o_mgr);
            }
        default:
            {
                tsk_utils_log_error(e_type + " not supported as media type");
                return null;
            }
    }
}

if(!window.__b_release_mode){
    tmedia_api_add_js_scripts('head',
        'src/tinyMEDIA/src/tmedia_session_jsep.js',
        'src/tinyMEDIA/src/tmedia_session_roap.js',
        'src/tinyMEDIA/src/tmedia_session_ghost.js'
    );
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
// http://tools.ietf.org/html/draft-uberti-rtcweb-jsep-02
// JSEP00: webkitPeerConnection00 (http://www.w3.org/TR/2012/WD-webrtc-20120209/)
// JSEP01: webkitRTCPeerConnection (http://www.w3.org/TR/webrtc/), https://webrtc-demos.appspot.com/html/pc1.html
// Mozilla: http://mozilla.github.com/webrtc-landing/pc_test.html
// Contraints: https://webrtc-demos.appspot.com/html/constraints-and-stats.html
// Android: https://groups.google.com/group/discuss-webrtc/browse_thread/thread/b8538c85df801b40
// Canary 'muted': https://groups.google.com/group/discuss-webrtc/browse_thread/thread/8200f2049c4de29f
// Canary state events: https://groups.google.com/group/discuss-webrtc/browse_thread/thread/bd30afc3e2f43f6d
// DTMF: https://groups.google.com/group/discuss-webrtc/browse_thread/thread/1354781f202adbf9
// IceRestart: https://groups.google.com/group/discuss-webrtc/browse_thread/thread/c189584d380eaa97
// Video Resolution: https://code.google.com/p/chromium/issues/detail?id=143631#c9

tmedia_session_jsep.prototype = Object.create(tmedia_session.prototype);
tmedia_session_jsep00.prototype = Object.create(tmedia_session_jsep.prototype);
tmedia_session_jsep01.prototype = Object.create(tmedia_session_jsep.prototype);

tmedia_session_jsep.prototype.o_pc = null;
tmedia_session_jsep.prototype.b_cache_stream = false;
tmedia_session_jsep.prototype.o_local_stream = null;
tmedia_session_jsep.prototype.o_sdp_jsep_lo = null;
tmedia_session_jsep.prototype.o_sdp_lo = null;
tmedia_session_jsep.prototype.b_sdp_lo_pending = false;
tmedia_session_jsep.prototype.i_sdp_lo_version = -1;
tmedia_session_jsep.prototype.o_sdp_json_ro = null;
tmedia_session_jsep.prototype.o_sdp_ro = null;
tmedia_session_jsep.prototype.b_sdp_ro_pending = false;
tmedia_session_jsep.prototype.b_sdp_ro_offer = false;
tmedia_session_jsep.prototype.s_answererSessionId = null;
tmedia_session_jsep.prototype.s_offererSessionId = null;
tmedia_session_jsep.prototype.ao_ice_servers = null;
tmedia_session_jsep.prototype.o_bandwidth = { audio:undefined, video:undefined };
tmedia_session_jsep.prototype.o_video_size = { minWidth:undefined, minHeight:undefined, maxWidth:undefined, maxHeight:undefined };
tmedia_session_jsep.prototype.o_audio_constraints = { googEchoCancellation: undefined, googNoiseSuppression: undefined, googAutoGainControl: undefined };

tmedia_session_jsep.prototype.b_ro_changed = false;
tmedia_session_jsep.prototype.b_lo_held = false;
tmedia_session_jsep.prototype.b_ro_held = false;

//
//  JSEP
//

tmedia_session_jsep.prototype.CreateInstance = function (o_mgr) {
    if (__o_peerconnection_class === window.webkitPeerConnection00 || __o_peerconnection_class === window.w4aPeerConnection) {
        return new tmedia_session_jsep00(o_mgr);
    }
    return new tmedia_session_jsep01(o_mgr);
}

function tmedia_session_jsep(o_mgr) {
    tmedia_session.call(this, o_mgr.e_type, o_mgr);
}

tmedia_session_jsep.prototype.__set = function (o_param) {
    if(!o_param){
        return -1;
    }
    switch(o_param.s_key){
        case 'ice-servers':
            {
                this.ao_ice_servers = o_param.o_value;
                return 0;
            }
        case 'cache-stream':
            {
                this.b_cache_stream = !!o_param.o_value;
                return 0;
            }
        case 'bandwidth':
            {
                this.o_bandwidth = o_param.o_value;
                return 0;
            }
        case 'video-size':
            {
                this.o_video_size = o_param.o_value;
                return 0;
            }
        case 'audio-constraints':
            {
                this.o_audio_constraints = o_param.o_value;
                return 0;
            }
    }

    return -2;
}

tmedia_session_jsep.prototype.__prepare = function () {
    return 0;
}

tmedia_session_jsep.prototype.__processContent = function (s_req_name, s_content_type, s_content_ptr, i_content_size) {
    if (this.o_pc && this.o_pc.processContent) {
        return this.o_pc.processContent(s_req_name, s_content_type, s_content_ptr, i_content_size);
    }
}

tmedia_session_jsep.prototype.__start = function () {
    if (this.o_local_stream && this.o_local_stream.start) {
        // cached stream would be stopped in close()
        this.o_local_stream.start();
    }
    else if (this.o_pc) {
        if(__o_peerconnection_class === window.w4aPeerConnection) { // WebRTC4All (https://code.google.com/p/webrtc4all/) only
            // In native WebRTC (Chrome or Firefox), media is started when ICE negotiation complete. For WebRTC4all we cannot rely on ICE as it's optional.
            try { this.o_pc.startMedia(); }
            catch (e) { }
        }
    }
    return 0;
}

tmedia_session_jsep.prototype.__pause = function () {
    if (this.o_local_stream && this.o_local_stream.pause) {
        this.o_local_stream.pause();
    }
    return 0;
}

tmedia_session_jsep.prototype.__stop = function () {
    this.close();
    this.o_sdp_lo = null;
    tsk_utils_log_info("PeerConnection::stop()");

    return 0;
}

tmedia_session_jsep.prototype.decorate_lo = function (b_inc_version) {
    if (this.o_sdp_lo) {
        /* Session name for debugging - Requires by webrtc2sip to set RTCWeb type */
        var o_hdr_S;
        if ((o_hdr_S = this.o_sdp_lo.get_header(tsdp_header_type_e.S))) {
            o_hdr_S.s_value = "Doubango Telecom - " + tsk_utils_get_navigator_friendly_name();
        }

        /* Session version */
        var o_hdr_O;
        if (this.i_sdp_lo_version == -1) {
            this.i_sdp_lo_version = ((__o_peerconnection_class == window.webkitRTCPeerConnection) || (__o_peerconnection_class == w4aPeerConnection)) ? 2 : 1; // 1: google-ice, 2: standard-ice
        }
        if ((o_hdr_O = this.o_sdp_lo.get_header(tsdp_header_type_e.O))) {
            o_hdr_O.i_sess_version = this.i_sdp_lo_version;
            if (b_inc_version) {
                ++this.i_sdp_lo_version;
            }
        }
        /* Remove 'video' media if not enabled (bug in chrome: doesn't honor 'has_video' parameter) */
        if (/*!this.o_sdp_ro &&*/!(this.e_type.i_id & tmedia_type_e.VIDEO.i_id)) {
            this.o_sdp_lo.remove_media("video");
        }
        /* hold / resume, profile, bandwidth... */
        var i_index = 0;
        var o_hdr_M;
        var b_w4a = (__o_peerconnection_class == w4aPeerConnection);
        var b_fingerprint = !!this.o_sdp_lo.get_header_a("fingerprint"); // session-level fingerprint
        while ((o_hdr_M = this.o_sdp_lo.get_header_at(tsdp_header_type_e.M, i_index++))) {
            // hold/resume
            o_hdr_M.set_holdresume_att(this.b_lo_held, this.b_ro_held);
			//Firefox hack against trickle ICE, which not corresponding to hold presumptions in nauphone
			if (!this.b_lo_held && o_hdr_M.o_hdr_C.s_addr == "0.0.0.0") {
				var a_index = 0;
				var o_hdr_A;
				while (o_hdr_A = o_hdr_M.find_a_at("candidate", a_index++)) {
					if (o_hdr_A.s_value.indexOf("typ srflx") >= 0) {
						var r = o_hdr_A.s_value.match(/[0-9]{1,3}(\.[0-9]{1,3}){3}/g);
						if (r.length > 0) {
							var ip = r[0].substring(1,r[0].length);
							o_hdr_M.o_hdr_C.s_addr = ip;
							break;
						}
					}
				}
			}
            // HACK: Nightly 20.0a1 uses RTP/SAVPF for DTLS-SRTP which is not correct. More info at https://bugzilla.mozilla.org/show_bug.cgi?id=827932.
            if (!b_w4a) {
                if (o_hdr_M.find_a("crypto")) {
                    o_hdr_M.s_proto = "RTP/SAVPF";
                }
                else if (b_fingerprint || o_hdr_M.find_a("fingerprint")) {
                    o_hdr_M.s_proto = "UDP/TLS/RTP/SAVPF";
                }
            }
            
            // bandwidth
            if(this.o_bandwidth) {
                if(this.o_bandwidth.audio && o_hdr_M.s_media.toLowerCase() == "audio") {
                    o_hdr_M.add_header(new tsdp_header_B("AS:"+this.o_bandwidth.audio));
                }
                else if(this.o_bandwidth.video && o_hdr_M.s_media.toLowerCase() == "video") {
                    o_hdr_M.add_header(new tsdp_header_B("AS:"+this.o_bandwidth.video));
                }
            }
        }
        
        /* SKOROZVON HOLD HACK */
        if(this.b_lo_held) {
            //console.log("HOLD HACK (#1)");
            o_hdr_O.s_addr = "0.0.0.0";
            var o_hdr_C;
            if((o_hdr_C = this.o_sdp_lo.get_header(tsdp_header_type_e.C))) {
                //console.log("C header changed");
                o_hdr_C.s_addr = "0.0.0.0";
            }
            i_index = 0
            while ((o_hdr_M = this.o_sdp_lo.get_header_at(tsdp_header_type_e.M, i_index++))) {
                o_hdr_M.s_proto = "RTP/AVP";
                o_hdr_M.i_nports = 0;
                o_hdr_M.i_port = 0;
                o_hdr_M.ao_hdr_A = new Array();
                o_hdr_M.as_fmt = new Array();
            }
        }
    }
    return 0;
}

tmedia_session_jsep.prototype.decorate_ro = function (b_remove_bundle) {
    if (this.o_sdp_ro) {
        var o_hdr_M, o_hdr_A;
        var i_index = 0, i;
        var b_w4a = (__o_peerconnection_class == w4aPeerConnection);

        // FIXME: Chrome fails to parse SDP with global SDP "a=" attributes
        // Chrome 21.0.1154.0+ generate "a=group:BUNDLE audio video" but cannot parse it
        // In fact, new the attribute is left the ice callback is called twice and the 2nd one trigger new INVITE then 200OK. The SYN_ERR is caused by the SDP in the 200 OK.
        // Is it because of "a=rtcp:1 IN IP4 0.0.0.0"?
        if (b_remove_bundle) {
            this.o_sdp_ro.remove_header(tsdp_header_type_e.A);
        }

        // ==== START: RFC5939 utility functions ==== //
        var rfc5939_get_acap_part = function(o_hdr_a, i_part/* i_part = 1: field, 2: value*/){
            var ao_match = o_hdr_a.s_value.match(/^\d\s+(\w+):([\D|\d]+)/i);
            if(ao_match && ao_match.length == 3){
                return ao_match[i_part];
            }
        }
        var rfc5939_acap_ensure = function(o_hdr_a){
            if(o_hdr_a && o_hdr_a.s_field == "acap"){
                o_hdr_a.s_field = rfc5939_get_acap_part(o_hdr_a, 1);
                o_hdr_a.s_value = rfc5939_get_acap_part(o_hdr_a, 2);
            }
        }
        var rfc5939_get_headerA_at = function(o_msg, s_media, s_field, i_index){
            var i_pos = 0;
            var get_headerA_at = function(o_sdp, s_field, i_index){
                if(o_sdp){
                    var ao_headersA = (o_sdp.ao_headers || o_sdp.ao_hdr_A);
                    for (var i = 0; i < ao_headersA.length; ++i) {
                        if(ao_headersA[i].e_type == tsdp_header_type_e.A && ao_headersA[i].s_value){
                            var b_found = (ao_headersA[i].s_field === s_field);
                            if(!b_found && ao_headersA[i].s_field == "acap"){
                                b_found = (rfc5939_get_acap_part(ao_headersA[i], 1) == s_field);
                            }
                            if(b_found && i_pos++ >= i_index){
                                return ao_headersA[i];
                            }
                        }
                    }
                }
            }

            var o_hdr_a = get_headerA_at(o_msg, s_field, i_index); // find at session level
            if(!o_hdr_a){
                return get_headerA_at(o_msg.get_header_m_by_name(s_media), s_field, i_index); // find at media level
            }
            return o_hdr_a;
        }
         // ==== END: RFC5939 utility functions ==== //

        // change profile if not secure
        //!\ firefox nighly: DTLS-SRTP only, chrome: SDES-SRTP
        var b_fingerprint = !!this.o_sdp_ro.get_header_a("fingerprint"); // session-level fingerprint
        while ((o_hdr_M = this.o_sdp_ro.get_header_at(tsdp_header_type_e.M, i_index++))) {
            // check for "crypto:"/"fingerprint:" lines (event if it's not valid to provide "crypto" lines in non-secure SDP many clients do it, so, just check)
            if (!b_w4a && o_hdr_M.s_proto.indexOf("SAVP") < 0) {
                if (o_hdr_M.find_a("crypto")) {
                    o_hdr_M.s_proto = "RTP/SAVPF";
                    break;
                }
                else if (b_fingerprint || o_hdr_M.find_a("fingerprint")) {
                    o_hdr_M.s_proto = "UDP/TLS/RTP/SAVPF";
                    break;
                }
            }

            // rfc5939: "acap:fingerprint,setup,connection"
            if (!b_w4a && o_hdr_M.s_proto.indexOf("SAVP") < 0) {
                if((o_hdr_A = rfc5939_get_headerA_at(this.o_sdp_ro, o_hdr_M.s_media, "fingerprint", 0))){
                    rfc5939_acap_ensure(o_hdr_A);
                    if((o_hdr_A = rfc5939_get_headerA_at(this.o_sdp_ro, o_hdr_M.s_media, "setup", 0))){
                        rfc5939_acap_ensure(o_hdr_A);
                    }
                    if((o_hdr_A = rfc5939_get_headerA_at(this.o_sdp_ro, o_hdr_M.s_media, "connection", 0))){
                        rfc5939_acap_ensure(o_hdr_A);
                    }
                    o_hdr_M.s_proto = "UDP/TLS/RTP/SAVP";
                }
            }
            // rfc5939: "acap:crypto". Only if DTLS is OFF
            if (!b_w4a && o_hdr_M.s_proto.indexOf("SAVP") < 0) {
                i = 0;
                while((o_hdr_A = rfc5939_get_headerA_at(this.o_sdp_ro, o_hdr_M.s_media, "crypto", i++))){
                    rfc5939_acap_ensure(o_hdr_A);
                    o_hdr_M.s_proto = "RTP/SAVPF";
                    // do not break => find next "acap:crypto" lines and ensure them
                }
            }

            // HACK: Nightly 20.0a1 uses RTP/SAVPF for DTLS-SRTP which is not correct. More info at https://bugzilla.mozilla.org/show_bug.cgi?id=827932
            // Same for chrome: https://code.google.com/p/sipml5/issues/detail?id=92
            if(!b_w4a && o_hdr_M.s_proto.indexOf("UDP/TLS/RTP/SAVP") != -1){
                o_hdr_M.s_proto = "RTP/SAVPF";
            }
            // SKOROZVON HACK
            i = 0;
            var id, name, rate;
            while((o_hdr_A = rfc5939_get_headerA_at(this.o_sdp_ro, o_hdr_M.s_media, "rtpmap", i++))){
                if(o_hdr_A.s_value.indexOf("telephone-event") != -1) {
                    console.log("FOUND TELEPHONE-EVENT PAYLOAD: " + o_hdr_A.s_value);
                    //126 telephone-event/8000
                    //fmtp:126 0-15
                    var ao_match = o_hdr_A.s_value.match(/^(\d+)\s+([\w\-]+)\/([\D|\d]+)/i);
                    if(ao_match && ao_match.length == 4){
                        id = ao_match[1];
                        name = ao_match[2];
                        rate = ao_match[3];
                        o_hdr_A.s_value = "126 telephone-event/" + rate;
                        for(var j = 0; j < o_hdr_M.as_fmt.length; j++) {
                            if(o_hdr_M.as_fmt[j] == "" +id)
                                o_hdr_M.as_fmt[j] = "126";
                        }
                        //console.log(o_hdr_M);
                    }
                    break;
                }
            }
            i = 0;
            while((o_hdr_A = rfc5939_get_headerA_at(this.o_sdp_ro, o_hdr_M.s_media, "fmtp", i++))){
                if(o_hdr_A.s_value.indexOf(""+id) == 0) {
                    var ao_match = o_hdr_A.s_value.match(/^(\d+)\s+(\d+)/i);
                    var range;
                    if(ao_match && ao_match.length == 3){
                        range = ao_match[2];
                        o_hdr_A.s_value = "126 " + range;
                    }
                }
            }
        }
    }
    return 0;
}

tmedia_session_jsep.prototype.subscribe_stream_events = function () {
    if (this.o_pc) {
        this.o_pc.onstatechange = function (evt) {
            tsk_utils_log_info("__on_state_change");
        }
        this.o_pc.onopen = function (evt) {
            tsk_utils_log_info("__on_open");
        }
        this.o_pc.onaddstream = function (evt) {
            tsk_utils_log_info("__on_add_stream");
            var This = (tmedia_session_jsep01.mozThis || this.o_session);
            This.o_remote_stream = evt.stream;
            if (This.o_mgr) {
                // HACK: patch for Firefox and others
                // https://groups.google.com/group/discuss-webrtc/browse_thread/thread/e30f0ffc267bce5f
                if(!This.o_remote_stream.videoTracks || !This.o_remote_stream.audioTracks){
                    var b_support_audio = !!(This.e_type.i_id & tmedia_type_e.AUDIO.i_id);
                    var b_support_video = !!(This.e_type.i_id & tmedia_type_e.VIDEO.i_id);
                    This.o_remote_stream.audioTracks = This.o_remote_stream.getAudioTracks ? This.o_remote_stream.getAudioTracks() : {length: b_support_audio ? 1 : 0};
                    This.o_remote_stream.videoTracks = This.o_remote_stream.getVideoTracks ? This.o_remote_stream.getVideoTracks() : {length: b_support_video ? 1 : 0};
                }
                This.o_mgr.set_stream_remote(evt.stream);
            }
        }
        this.o_pc.onremovestream = function (evt) {
            tsk_utils_log_info("__on_remove_stream");
            var This = (tmedia_session_jsep01.mozThis || this.o_session);
            This.o_remote_stream = null;
            if (This.o_mgr) {
                This.o_mgr.set_stream_remote(null);
            }
        }
    }
}

tmedia_session_jsep.prototype.close = function () {
    if (this.o_mgr) { // 'onremovestream' not always called
        this.o_mgr.set_stream_remote(null);
        this.o_mgr.set_stream_local(null);
    }
    if (this.o_pc) {
        if (this.o_local_stream) {
            // TODO: On Firefox 26: Error: "removeStream not implemented yet"
            try { this.o_pc.removeStream(this.o_local_stream); } catch (e) { }
            if(!this.b_cache_stream || (this.e_type == tmedia_type_e.SCREEN_SHARE)) { // only stop if caching is disabled or screenshare
                this.o_local_stream.stop();
            }
            this.o_local_stream = null;
        }
        this.o_pc.close();
        this.o_pc = null;
        this.b_sdp_lo_pending = false;
        this.b_sdp_ro_pending = false;
    }
}

tmedia_session_jsep.prototype.__acked = function () {
    return 0;
}

tmedia_session_jsep.prototype.__hold = function () {
    if (this.b_lo_held) {
        // tsk_utils_log_warn('already on hold');
        return;
    }
    this.b_lo_held = true;

    this.close();

    this.o_sdp_ro = null;

    this.decorate_lo(true);

    return 0;
}

tmedia_session_jsep.prototype.__resume = function () {
    if (!this.b_lo_held) {
        // tsk_utils_log_warn('not on hold');
        return;
    }
    this.b_lo_held = false;

    this.close();

	if(tmedia_session_jsep01.mozThis)
		tmedia_session_jsep01.mozThis.localDescription = null;
    this.o_sdp_lo = null;
    this.o_sdp_ro = null;

    return 0;
}


//
//  JSEP00
//

function tmedia_session_jsep00(o_mgr) {
    tmedia_session_jsep.call(this, o_mgr);
}

tmedia_session_jsep00.prototype.__get_lo = function () {
    if (!this.o_pc && !this.b_lo_held) {
        this.o_mgr.set_stream_local(__o_roap_stream);

        this.o_local_stream = __o_roap_stream;
        var This = this;

        // "__o_peerconnection_class" is equal to "webkitPeerConnection00 || webkitPeerConnection" on chrome and "w4aPeerConnection" on IE
        this.o_pc = new __o_peerconnection_class("STUN stun.l.google.com:19302",
                function (o_candidate, b_moreToFollow) {
                    // tsk_utils_log_info("__on_ice_candidate: " + (o_candidate ? o_candidate.toSdp() : "null"));
                    if (o_candidate) {
                        This.o_sdp_jsep_lo.addCandidate(o_candidate);
                    }
                    if (!b_moreToFollow) {
                        This.o_sdp_lo = tsdp_message.prototype.Parse(This.o_sdp_jsep_lo.toSdp());
                        if (This.o_sdp_lo) {
                            This.decorate_lo(true);
                        }
                        if (This.o_mgr) {
                            This.o_mgr.callback(tmedia_session_events_e.GET_LO_SUCCESS, This.e_type);
                        }
                        This.b_sdp_lo_pending = false;
                    }
                }
        );
        this.o_pc.o_session = this;
        this.o_pc.o_mgr = this.o_mgr;
        this.subscribe_stream_events();
    }

    if (!this.o_sdp_lo && !this.b_sdp_lo_pending) {
        var b_start_ice = true;
        var b_answer = ((this.b_sdp_ro_pending || this.b_sdp_ro_offer) && (this.o_sdp_ro != null));

        if (this.o_pc.localDescription) {
            switch (this.o_pc.iceState) { // chrome won't restart ICE
                case __o_peerconnection_class.ICE_COMPLETED:
                case __o_peerconnection_class.ICE_FAILED:
                case __o_peerconnection_class.ICE_CLOSED:
                    b_start_ice = false;
                    break;
            }
        }

        if (this.b_sdp_ro_pending && this.o_sdp_ro) {
            this.__set_ro(this.o_sdp_ro, true);
        }

        this.o_sdp_jsep_lo = b_answer ?
            this.o_pc.createAnswer(this.o_pc.remoteDescription.toSdp(), { has_audio: !!(this.e_type.i_id & tmedia_type_e.AUDIO.i_id), has_video: !!(this.e_type.i_id & tmedia_type_e.VIDEO.i_id) }) :
            this.o_pc.createOffer({ has_audio: !!(this.e_type.i_id & tmedia_type_e.AUDIO.i_id), has_video: !!(this.e_type.i_id & tmedia_type_e.VIDEO.i_id) });

        if (!b_start_ice) {
            this.o_sdp_lo = tsdp_message.prototype.Parse(this.o_sdp_jsep_lo.toSdp());
            if (this.o_sdp_lo) {
                this.decorate_lo(false);
                this.o_sdp_jsep_lo = new __o_sessiondescription_class(this.o_sdp_lo);
            }
        }

        this.o_pc.setLocalDescription(b_answer ? __o_peerconnection_class.SDP_ANSWER : __o_peerconnection_class.SDP_OFFER,
                this.o_sdp_jsep_lo);

        if (b_start_ice) {
            this.b_sdp_lo_pending = true;
            this.o_pc.startIce({ use_candidates: "all" });
        }
    }

    return this.o_sdp_lo;
}

tmedia_session_jsep00.prototype.__set_ro = function (o_sdp, b_is_offer) {
    if (!o_sdp) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    /* update remote offer */
    this.o_sdp_ro = o_sdp;
    this.b_sdp_ro_offer = b_is_offer;

    if (this.o_pc) {
        try {
            //console.debug("SDP_RO=%s", this.o_sdp_ro.toString());
            this.decorate_ro(true);
            this.o_pc.setRemoteDescription(b_is_offer ? __o_peerconnection_class.SDP_OFFER : __o_peerconnection_class.SDP_ANSWER,
                            new __o_sessiondescription_class(this.o_sdp_ro.toString()));
            if (!this.b_sdp_ro_pending && b_is_offer) {
                this.o_sdp_lo = null; // to force new SDP when get_lo() is called
            }
        }
        catch (e) {
            this.o_mgr.callback(tmedia_session_events_e.SET_RO_FAILED, this.e_type);
            tsk_utils_log_error(e);
            return -2;
        }
        finally {
            this.b_sdp_ro_pending = false;
        }
    }
    else {
        this.b_sdp_ro_pending = true;
    }

    return 0;
}

//
//  JSEP01
//

function tmedia_session_jsep01(o_mgr) {
    tmedia_session_jsep.call(this, o_mgr);
	if(tsk_utils_get_navigator_friendly_name() == 'firefox'){
		this.o_media_constraints = 
		{
			'offerToReceiveAudio': !!(this.e_type.i_id & tmedia_type_e.AUDIO.i_id),
			'offerToReceiveVideo': !!(this.e_type.i_id & tmedia_type_e.VIDEO.i_id)
		};
		tmedia_session_jsep01.mozThis = this;
		this.o_media_constraints.MozDontOfferDataChannel = true;
	}
	else
	{
		this.o_media_constraints =
		{ 'mandatory':
			{
				'OfferToReceiveAudio': !!(this.e_type.i_id & tmedia_type_e.AUDIO.i_id),
				'OfferToReceiveVideo': !!(this.e_type.i_id & tmedia_type_e.VIDEO.i_id)
			}
		};
	}
}

tmedia_session_jsep01.mozThis = undefined;

tmedia_session_jsep01.onGetUserMediaSuccess = function (o_stream, _This) {
    tsk_utils_log_info("onGetUserMediaSuccess");
    var This = (tmedia_session_jsep01.mozThis || _This);
    if (This && This.o_pc && This.o_mgr) {
        if(!This.b_sdp_lo_pending){
            tsk_utils_log_warn("onGetUserMediaSuccess but no local sdp request is pending");
            return;
        }

        // HACK: patch for Firefox and others
        // https://groups.google.com/group/discuss-webrtc/browse_thread/thread/e30f0ffc267bce5f
        if(!o_stream.videoTracks || !o_stream.audioTracks){
            var b_support_audio = !!(This.e_type.i_id & tmedia_type_e.AUDIO.i_id);
            var b_support_video = !!(This.e_type.i_id & tmedia_type_e.VIDEO.i_id);
            o_stream.audioTracks = o_stream.getAudioTracks ? o_stream.getAudioTracks() : {length: b_support_audio ? 1 : 0};
            o_stream.videoTracks = o_stream.getVideoTracks ? o_stream.getVideoTracks() : {length: b_support_video ? 1 : 0};
        }

        // save stream other next calls
        if(o_stream.audioTracks.length > 0 && o_stream.videoTracks.length == 0){
            __o_jsep_stream_audio = o_stream;
        }
        else if(o_stream.audioTracks.length > 0 && o_stream.videoTracks.length > 0){
            __o_jsep_stream_audiovideo = o_stream;
        }
        
        if(!This.o_local_stream){
            This.o_mgr.callback(tmedia_session_events_e.STREAM_LOCAL_ACCEPTED, this.e_type);
        }
        

        // HACK: Firefox only allows to call gum one time
        if(tmedia_session_jsep01.mozThis){
            __o_jsep_stream_audiovideo = __o_jsep_stream_audio = o_stream;
        }

        This.o_local_stream = o_stream;
        This.o_pc.addStream(o_stream);
        This.o_mgr.set_stream_local(o_stream);

        var b_answer = ((This.b_sdp_ro_pending || This.b_sdp_ro_offer) && (This.o_sdp_ro != null));
        if (b_answer) {
            tsk_utils_log_info("createAnswer");
            This.o_pc.createAnswer(
                tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onCreateSdpSuccess : function(o_offer){ tmedia_session_jsep01.onCreateSdpSuccess(o_offer, This); },
                tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onCreateSdpError : function(s_error){ tmedia_session_jsep01.onCreateSdpError(s_error, This); },
                This.o_media_constraints,
                false // createProvisionalAnswer
             );
        }
        else {
            tsk_utils_log_info("createOffer");
            This.o_pc.createOffer(
                tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onCreateSdpSuccess : function(o_offer){ tmedia_session_jsep01.onCreateSdpSuccess(o_offer, This); },
                tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onCreateSdpError : function(s_error){ tmedia_session_jsep01.onCreateSdpError(s_error, This); },
                This.o_media_constraints
            );
        }
    }
}

tmedia_session_jsep01.onGetUserMediaError = function (s_error, _This) {
    tsk_utils_log_info("onGetUserMediaError");
    var This = (tmedia_session_jsep01.mozThis || _This);
    if (This && This.o_mgr) {
        tsk_utils_log_error(s_error);
        This.o_mgr.callback(tmedia_session_events_e.STREAM_LOCAL_REFUSED, This.e_type);
    }
}

tmedia_session_jsep01.onCreateSdpSuccess = function (o_sdp, _This) {
    tsk_utils_log_info("onCreateSdpSuccess");
    var This = (tmedia_session_jsep01.mozThis || _This);
    if (This && This.o_pc) {
        This.iceFinished = false;
        This.o_pc.setLocalDescription(o_sdp,
            tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onSetLocalDescriptionSuccess : function(){ tmedia_session_jsep01.onSetLocalDescriptionSuccess(This); },
            tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onSetLocalDescriptionError : function(s_error){ tmedia_session_jsep01.onSetLocalDescriptionError(s_error, This); }
        );
/*        if(tmedia_session_jsep01.mozThis && !tmedia_session_jsep01.mozThis.localDescription){
            tmedia_session_jsep01.mozThis.localDescription = o_sdp; // HACK: Firefox Nightly 20.0a1 => "PeeConnection.localDescription" always undefined or not correct. More info at https://bugzilla.mozilla.org/show_bug.cgi?id=828235
        }*/
    }
}

tmedia_session_jsep01.onCreateSdpError = function (s_error, _This) {
    tsk_utils_log_info("onCreateSdpError");
    var This = (tmedia_session_jsep01.mozThis || _This);
    if (This && This.o_mgr) {
        tsk_utils_log_error(s_error);
        This.o_mgr.callback(tmedia_session_events_e.GET_LO_FAILED, This.e_type);
    }
}

tmedia_session_jsep01.onSetLocalDescriptionSuccess = function(_This){
    /*tsk_utils_log_info("onSetLocalDescriptionSuccess and do nothing");
    var This = (tmedia_session_jsep01.mozThis || _This);
    if (This && This.o_pc) {
        if(tmedia_session_jsep01.mozThis){
            tmedia_session_jsep01.onIceGatheringCompleted(This); // HACK: Firefox Nightly 20.0a1(2013-01-08) => "PeeConnection.onicecandidate" callback never called. More info at https://bugzilla.mozilla.org/show_bug.cgi?id=827932
        }
    }*/
}

tmedia_session_jsep01.onSetLocalDescriptionError = function(s_error, _This){
    tsk_utils_log_info("onSetLocalDescriptionError");
    var This = (tmedia_session_jsep01.mozThis || _This);
    if (This && This.o_mgr) {
        tsk_utils_log_error(s_error.toString());
        This.o_mgr.callback(tmedia_session_events_e.GET_LO_FAILED, This.e_type);
    }
}

tmedia_session_jsep01.onSetRemoteDescriptionSuccess = function(_This){
    tsk_utils_log_info("onSetRemoteDescriptionSuccess");
    var This = (tmedia_session_jsep01.mozThis || _This);
    if(This){
        if (!This.b_sdp_ro_pending && This.b_sdp_ro_offer) {
            This.o_sdp_lo = null; // to force new SDP when get_lo() is called
        }
   }
}

tmedia_session_jsep01.onSetRemoteDescriptionError = function(s_error, _This){
    tsk_utils_log_info("onSetRemoteDescriptionError");
    var This = (tmedia_session_jsep01.mozThis || _This);
    if(This){
        This.o_mgr.callback(tmedia_session_events_e.SET_RO_FAILED, This.e_type);
        tsk_utils_log_error(s_error);
    }
}

tmedia_session_jsep01.onIceGatheringCompleted = function (_This) {
    tsk_utils_log_info("onIceGatheringCompleted");
    var This = (tmedia_session_jsep01.mozThis || _This);
    if(This && This.o_pc){
		//tsk_utils_log_info("sdp " + This.o_pc.localDescription.sdp);
        if(!This.b_sdp_lo_pending){
            tsk_utils_log_warn("onIceGatheringCompleted but no local sdp request is pending");
            return;
        }
        This.b_sdp_lo_pending = false;
        // HACK: Firefox Nightly 20.0a1(2013-01-08): PeerConnection.localDescription has a wrong value (remote sdp). More info at https://bugzilla.mozilla.org/show_bug.cgi?id=828235
        var localDescription = (This.o_pc.localDescription || This.localDescription);
        if(localDescription){
            This.o_sdp_jsep_lo = localDescription;
            This.o_sdp_lo = tsdp_message.prototype.Parse(This.o_sdp_jsep_lo.sdp);
            This.decorate_lo(true);
            if (This.o_mgr) {
                This.o_mgr.callback(tmedia_session_events_e.GET_LO_SUCCESS, This.e_type);
            }
        }
        else{
            This.o_mgr.callback(tmedia_session_events_e.GET_LO_FAILED, This.e_type);
            tsk_utils_log_error("localDescription is null");
        }
    }
}

tmedia_session_jsep01.onIceCandidate = function (o_event, _This) {
    tsk_utils_log_info("onIceCandidate");
    var This = (tmedia_session_jsep01.mozThis || _This);

    if(!This || !This.o_pc){
        // AT now it's normal situation, just ignore it tsk_utils_log_error("This/PeerConnection is null: unexpected");
        return;
    }

    if (This.iceFinished)
        return;

    var isCompleted = This.o_pc.iceGatheringState == "complete";
    var noMoreCandidates = (o_event && !o_event.candidate);
    var isSrflxCandidate = o_event && o_event.candidate && o_event.candidate.candidate.indexOf("typ srflx") !== -1;

    if (noMoreCandidates || isSrflxCandidate || isCompleted) {
        tsk_utils_log_info("ICE GATHERING COMPLETED!");
        tmedia_session_jsep01.onIceGatheringCompleted(This);
        This.iceFinished = true;
    } else if (This.o_pc.iceState == "failed") {
        tsk_utils_log_error("Ice state is 'failed'");
        This.o_mgr.callback(tmedia_session_events_e.GET_LO_FAILED, This.e_type); 
    }
}




tmedia_session_jsep01.prototype.__get_lo = function () {
    var This = this;
    var o_iceServers = this.ao_ice_servers;
    if (!this.o_pc && !this.b_lo_held) {
        var o_video_constraints = {
            mandatory: { },
            optional: []
        };
        if((this.e_type.i_id & tmedia_type_e.SCREEN_SHARE.i_id) == tmedia_type_e.SCREEN_SHARE.i_id) {
            o_video_constraints.mandatory.chromeMediaSource = 'screen';
        }
        if(this.e_type.i_id & tmedia_type_e.VIDEO.i_id) {
            if(this.o_video_size) {
                if(this.o_video_size.minWidth) o_video_constraints.mandatory.minWidth = this.o_video_size.minWidth;
                if(this.o_video_size.minHeight) o_video_constraints.mandatory.minHeight = this.o_video_size.minHeight;
                if(this.o_video_size.maxWidth) o_video_constraints.mandatory.maxWidth = this.o_video_size.maxWidth;
                if(this.o_video_size.maxHeight) o_video_constraints.mandatory.maxHeight = this.o_video_size.maxHeight;
            }
            try{ tsk_utils_log_info("Video Contraints:" + JSON.stringify(o_video_constraints)); } catch(e){}
        }
        var o_audio_constraints = {
            mandatory: {},
            optional: []
        };
        
        if(this.o_audio_constraints && tsk_utils_get_navigator_friendly_name() == 'chrome') {
            if(this.o_audio_constraints.googEchoCancellation != undefined) o_audio_constraints.mandatory.googEchoCancellation = this.o_audio_constraints.googEchoCancellation;
            if(this.o_audio_constraints.googNoiseSuppression != undefined) o_audio_constraints.mandatory.googNoiseSuppression = this.o_audio_constraints.googNoiseSuppression;
            if(this.o_audio_constraints.googAutoGainControl != undefined) o_audio_constraints.mandatory.googAutoGainControl = this.o_audio_constraints.googAutoGainControl;
        }
        var o_iceServers = this.ao_ice_servers;
        if(!o_iceServers){ // defines default ICE servers only if none exist (because WebRTC requires ICE)
            // HACK Nightly 21.0a1 (2013-02-18): 
            // - In RTCConfiguration passed to RTCPeerConnection constructor: FQDN not yet implemented (only IP-#s). Omitting "stun:stun.l.google.com:19302"
            // - CHANGE-REQUEST not supported when using "numb.viagenie.ca"
            // - (stun/ERR) Missing XOR-MAPPED-ADDRESS when using "stun.l.google.com"
            // numb.viagenie.ca: 66.228.45.110:
            // stun.l.google.com: 173.194.78.127
            // stun.counterpath.net: 216.93.246.18
            // "23.21.150.121" is the default STUN server used in Nightly
            o_iceServers = tmedia_session_jsep01.mozThis
                ? [{ url: 'stun:23.21.150.121:3478'}, { url: 'stun:216.93.246.18:3478'}, { url: 'stun:66.228.45.110:3478'}, { url: 'stun:173.194.78.127:19302'}]
                : [{ url: 'stun:stun.l.google.com:19302'}, { url: 'stun:stun.counterpath.net:3478'}, { url: 'stun:numb.viagenie.ca:3478'}];
        }
        try{ tsk_utils_log_info("ICE servers:" + JSON.stringify(o_iceServers)); } catch(e){}
        this.o_pc = new __o_peerconnection_class(
                (o_iceServers && !o_iceServers.length) ? null : { iceServers: o_iceServers }, // empty array is used to disable STUN/TURN.
				//tmedia_session_jsep01.mozThis ? null : { iceServers: o_iceServers }, //SKOROZVON in original was (o_iceServers && !o_iceServers.length) ? null : { iceServers: o_iceServers }, // empty array is used to disable STUN/TURN.
                this.o_media_constraints
        );
        this.o_pc.onicecandidate = tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onIceCandidate : function(o_event){ tmedia_session_jsep01.onIceCandidate(o_event, This) };
        this.o_pc.o_mgr = this.o_mgr;
        if(!tmedia_session_jsep01.mozThis){
            this.o_pc.o_session = this; // HACK: Firefox exception: "Cannot modify properties of a WrappedNative"  nsresult: "0x80570034 (NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN)"
        }
        this.subscribe_stream_events();
    }

    if (!this.o_sdp_lo && !this.b_sdp_lo_pending) {
        this.b_sdp_lo_pending = true;

        // set penfing ro if there is one
        if (this.b_sdp_ro_pending && this.o_sdp_ro) {
            this.__set_ro(this.o_sdp_ro, true);
        }
        // get media stream
        if(this.e_type == tmedia_type_e.AUDIO && (this.b_cache_stream && __o_jsep_stream_audio)){
            tmedia_session_jsep01.onGetUserMediaSuccess(__o_jsep_stream_audio, This);
        }
        else if(this.e_type == tmedia_type_e.AUDIO_VIDEO && (this.b_cache_stream && __o_jsep_stream_audiovideo)){
            tmedia_session_jsep01.onGetUserMediaSuccess(__o_jsep_stream_audiovideo, This);
        }
        else{
            this.o_mgr.callback(tmedia_session_events_e.STREAM_LOCAL_REQUESTED, this.e_type);
            navigator.nativeGetUserMedia(
                    { 
                        audio: (this.e_type == tmedia_type_e.SCREEN_SHARE) ? false : !!(this.e_type.i_id & tmedia_type_e.AUDIO.i_id) ? o_audio_constraints : false, // IMPORTANT: Chrome '28.0.1500.95 m' doesn't support using audio with screenshare
                        video: !!(this.e_type.i_id & tmedia_type_e.VIDEO.i_id) ? o_video_constraints : false, // "SCREEN_SHARE" contains "VIDEO" flag -> (VIDEO & SCREEN_SHARE) = VIDEO
                        data: false 
                    },
                    tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onGetUserMediaSuccess : function(o_stream){ tmedia_session_jsep01.onGetUserMediaSuccess(o_stream, This); },
                    tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onGetUserMediaError : function(s_error){ tmedia_session_jsep01.onGetUserMediaError(s_error, This); }
                );
       }
    }

    return this.o_sdp_lo;
}

tmedia_session_jsep01.prototype.__set_ro = function (o_sdp, b_is_offer) {
    if (!o_sdp) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    /* update remote offer */
    this.o_sdp_ro = o_sdp;
    this.b_sdp_ro_offer = b_is_offer;

    if (this.o_pc) {
        try {
            var This = this;
            this.decorate_ro(false);
            tsk_utils_log_info("setRemoteDescription(" + (b_is_offer ? "offer)" : "answer)") + "\n" + this.o_sdp_ro);
            this.o_pc.setRemoteDescription(
               new __o_sessiondescription_class({ type: b_is_offer ? "offer" : "answer", sdp : This.o_sdp_ro.toString() }),
               tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onSetRemoteDescriptionSuccess : function() { tmedia_session_jsep01.onSetRemoteDescriptionSuccess(This); },
               tmedia_session_jsep01.mozThis ? tmedia_session_jsep01.onSetRemoteDescriptionError : function(s_error) { tmedia_session_jsep01.onSetRemoteDescriptionError(s_error, This); }
            );
        }
        catch (e) {
            tsk_utils_log_error(e);
            this.o_mgr.callback(tmedia_session_events_e.SET_RO_FAILED, this.e_type);
            return -2;
        }
        finally {
            this.b_sdp_ro_pending = false;
        }
    }
    else {
        this.b_sdp_ro_pending = true;
    }

    return 0;
}


/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
//@deprecated THIS IMPLEMENTATION IS DEPRECATED
// http://tools.ietf.org/html/draft-jennings-rtcweb-signaling-01

var __o_session_roap = null;

var tmedia_session_state_e =
{
    NONE: -1,
    OFFER_SENT: 0,
    OFFER_RECEIVED: 1,
    ANSWER_SENT: 2,
    ANSWER_RECEIVED: 3,

    LOCAL_HOLD: 10
};

function tmedia_session_roap(o_mgr) {
    this.__proto__.__proto__ = new tmedia_session(tmedia_type_e.AUDIO_VIDEO, o_mgr);
    this.e_state = tmedia_session_state_e.NONE;
    this.o_pc = null;
    this.o_pc_json = null;

    this.o_remote_stream = null;
    this.o_local_stream = null;

    this.o_sdp_json_lo = null;
    this.o_sdp_lo = null;
    this.o_sdp_json_ro = null;
    this.o_sdp_ro = null;

    this.b_ro_changed = false;
    this.b_lo_held = false;
    this.b_ro_held = false;
}

tmedia_session_roap.prototype.__set = function (o_param) {
    return 0;
}

tmedia_session_roap.prototype.__prepare = function () {
    return 0;
}

tmedia_session_roap.prototype.__start = function () {
    return 0;
}

tmedia_session_roap.prototype.__pause = function () {
    //if (this.o_local_stream) {
        
    //}
    return 0;
}


tmedia_session_roap.prototype.__stop = function () {
    tsk_utils_log_info("PeerConnection::stop()");

    if (this.o_pc) {
        this.o_pc.close();
        this.o_pc = null;
    }
    this.o_mgr.set_stream_remote(null);
    this.o_mgr.set_stream_local(null);

    return 0;
}

tmedia_session_roap.prototype.__get_lo = function () {
    tsk_utils_log_info("ROAP: __get_lo");
    if (!this.o_pc) {
        __o_session_roap = this;

        // alert user
        this.o_mgr.set_stream_local(__o_roap_stream);

        __o_session_roap.o_local_stream = __o_roap_stream;
        __o_session_roap.o_pc = new __o_peerconnection_class("STUN stun.l.google.com:19302", __o_session_roap.__on_signaling_message);
        //__o_session_roap.o_pc = new webkitDeprecatedPeerConnection("NONE", __o_session_roap.__on_signaling_message);
        __o_session_roap.o_pc.o_session = __o_session_roap;
        __o_session_roap.o_pc.onstatechange = tmedia_session_roap.prototype.__on_state_change;
        __o_session_roap.o_pc.onconnecting = tmedia_session_roap.prototype.__on_connecting;
        __o_session_roap.o_pc.onopen = tmedia_session_roap.prototype.__on_open;
        __o_session_roap.o_pc.onaddstream = tmedia_session_roap.prototype.__on_add_stream;
        __o_session_roap.o_pc.onremovestream = tmedia_session_roap.prototype.__on_remove_stream;

        if (__o_session_roap.o_pc) {
            tsk_utils_log_info("ROAP: __get_lo::addStream()");
            __o_session_roap.o_pc.addStream(__o_session_roap.o_local_stream);
        }

        if (this.e_state == tmedia_session_state_e.OFFER_RECEIVED && this.o_sdp_ro) {
            this.__set_ro(this.o_sdp_ro, true);
        }

        return null;
    }

    return this.o_sdp_lo;
}

tmedia_session_roap.prototype.__hold = function () {
    this.b_lo_held = true;

    if (this.o_pc && this.o_local_stream) {
        this.o_pc.removeStream(this.o_local_stream);
        return 0;
    }

    tsk_utils_log_error("Invalid state");
    return -1;
}

tmedia_session_roap.prototype.__set_ro = function (o_sdp, b_is_offer) {
    tsk_utils_log_info("ROAP: __set_ro");
    this.o_sdp_ro = o_sdp;

    if (!this.o_pc) {
        this.e_state = tmedia_session_state_e.OFFER_RECEIVED;
        return 0;
    }

    var s_sdp_json_ro = null;
    var o_hdr_O;
    var i_seq = 1;
    var i_tieBreaker = Math.floor((Math.random() * 0x0000FFFF));
    var s_answererSessionId;
    var s_offererSessionId;

    if ((o_hdr_O = this.o_sdp_ro.get_header(tsdp_header_type_e.O))) {
        i_seq = o_hdr_O.i_sess_version;
    }

    this.e_state = b_is_offer ? tmedia_session_state_e.OFFER_RECEIVED : tmedia_session_state_e.ANSWER_RECEIVED;

    if (this.o_pc_json) {
        s_answererSessionId = this.o_pc_json.answererSessionId ? this.o_pc_json.answererSessionId : tsk_string_random(16);
        s_offererSessionId = this.o_pc_json.offererSessionId ? this.o_pc_json.offererSessionId : tsk_string_random(16);

        if (this.o_pc_json.messageType == "OFFER") {
            s_sdp_json_ro = tsk_string_format(
                "{\n" +
                "\"answererSessionId\" : \"{0}\",\n" +
                "\"messageType\" : \"ANSWER\",\n" +
                "\"offererSessionId\" : \"{1}\",\n" +
                "\"sdp\" : \"{2}\",\n" +
                "\"seq\" : {3}\n" +
                "}\n", s_answererSessionId, s_offererSessionId, this.o_sdp_ro.toString("\\r\\n"), this.o_sdp_json_lo.seq);
        }
        else { // ACK use "ACKED"
            s_sdp_json_ro = tsk_string_format(
                "{\n" +
                "\"answererSessionId\" : \"{0}\",\n" +
                "\"messageType\" : \"OFFER\",\n" +
                "\"offererSessionId\" : \"{1}\",\n" +
                "\"sdp\" : \"{2}\",\n" +
                "\"seq\" : {3},\n" +
                "\"tieBreaker\": {4}\n" +
                "}\n", s_answererSessionId, s_offererSessionId, this.o_sdp_ro.toString("\\r\\n"), (this.o_sdp_json_lo.seq + 1), i_tieBreaker);
        }
    }
    else {
        s_sdp_json_ro = tsk_string_format(
                "{\n" +
                "\"messageType\" : \"OFFER\",\n" +
                "\"offererSessionId\" : \"{0}\",\n" +
                "\"sdp\" : \"{1}\",\n" +
                "\"seq\" : {2},\n" +
                "\"tieBreaker\": {3}\n" +
                "}\n", tsk_string_random(16), this.o_sdp_ro.toString("\\r\\n"), i_seq, i_tieBreaker);
    }

    try {
        tsk_utils_log_info("RO=" + s_sdp_json_ro);
        this.o_sdp_json_ro = JSON.parse(s_sdp_json_ro);
        this.o_pc.processSignalingMessage("SDP\n" + s_sdp_json_ro);
        return 0;
    }
    catch (e) {
        __o_session_roap.o_mgr.callback(tmedia_session_events_e.SET_RO_FAILED, this.e_type);
        tsk_utils_log_error(e);
        return -2;
    }
}

tmedia_session_roap.prototype.__acked = function () {
    if (this.o_sdp_json_lo) {
        if (this.o_sdp_json_lo.messageType == "ANSWER") {
            var s_sdp_json_ack = tsk_string_format(
                "SDP\n{\n" +
                "\"answererSessionId\" : \"{0}\",\n" +
                "\"messageType\" : \"OK\",\n" +
                "\"offererSessionId\" : \"{1}\",\n" +
                "\"seq\" : {2}\n" +
                "}\n", this.o_sdp_json_lo.offererSessionId, this.o_sdp_json_lo.answererSessionId, this.o_sdp_json_lo.seq);

            tsk_utils_log_info("ACK=" + s_sdp_json_ack);
            try {
                this.o_pc.processSignalingMessage(s_sdp_json_ack);
            }
            catch (e) {
                tsk_utils_log_error(e);
                return -2;
            }
        }
    }
    return 0;
}

tmedia_session_roap.prototype.__on_signaling_message = function (message) {
    tsk_utils_log_info("LO=" + message);

    if (tsk_string_index_of(message, 3, "SDP") == 0) {
        message = message.substring(3);
    }

    try {
        __o_session_roap.o_pc_json = JSON.parse(message);
        if (__o_session_roap.o_pc_json.messageType == "OFFER" || __o_session_roap.o_pc_json.messageType == "ANSWER") {
            var o_sdp = tsdp_message.prototype.Parse(__o_session_roap.o_pc_json.sdp);
            if (!o_sdp) {
                tsk_utils_log_error("failed to parse sdp" + __o_session_roap.o_pc_json.sdp);
                __o_session_roap.o_mgr.callback(tmedia_session_events_e.GET_LO_FAILED, this.e_type);
                return;
            }
            // https://groups.google.com/group/ericsson-labs-web-rtc/browse_thread/thread/4acadd0da3fce37c
            var o_hdr_ma = o_sdp.get_header_m_by_name("audio");
            var o_hdr_mv = o_sdp.get_header_m_by_name("video");
            /*if (o_hdr_ma && o_hdr_ma.i_port < 1024) {
                tsk_utils_log_error("Audio media contains invalid port:" + o_hdr_ma.i_port);
                return;
            }
            if (o_hdr_mv && o_hdr_mv.i_port < 1024) {
                tsk_utils_log_error("Video media contains invalid port:" + o_hdr_mv.i_port);
                return;
            }*/

            __o_session_roap.o_sdp_json_lo = __o_session_roap.o_pc_json;
            __o_session_roap.o_sdp_lo = o_sdp;

            var o_hdr_S;
            if ((o_hdr_S = __o_session_roap.o_sdp_lo.get_header(tsdp_header_type_e.S))) {
                o_hdr_S.s_value = "webrtc (roap)";
            }

            var o_hdr_O;
            if ((o_hdr_O = __o_session_roap.o_sdp_lo.get_header(tsdp_header_type_e.O))) {
                o_hdr_O.i_sess_version = __o_session_roap.o_sdp_json_lo.seq;
            }

            /* Hold/Resume */
            if (__o_session_roap.b_lo_held || __o_session_roap.b_ro_held) {
                var o_hdr_M;
                var i_index = 0;
                while ((o_hdr_M = __o_session_roap.o_sdp_lo.get_header_at(tsdp_header_type_e.M, i_index++))) {
                    o_hdr_M.set_holdresume_att(__o_session_roap.b_lo_held, __o_session_roap.b_ro_held);
                }
            }

            //__o_session_roap.o_sdp_lo.remove_media("video");
            //__o_session_roap.o_sdp_lo.add_media("video", 0, "RTP/AVP");
            
            //if (o_hdr_ma) {
                //o_hdr_m.s_proto = "RTP/AVP";
                //tsdp_header_A.prototype.RemoveAllByField(o_hdr_m.ao_hdr_A, "rtcp");
                //tsdp_header_A.prototype.RemoveAllByField(o_hdr_m.ao_hdr_A, "ssrc");
            //}
            //if (o_hdr_mv) {
                //o_hdr_m.s_proto = "RTP/AVP";
                //tsdp_header_A.prototype.RemoveAllByField(o_hdr_m.ao_hdr_A, "rtcp");
                //tsdp_header_A.prototype.RemoveAllByField(o_hdr_m.ao_hdr_A, "ssrc");
            //}


            if (__o_session_roap.e_state == tmedia_session_state_e.LOCAL_HOLD) {
                __o_session_roap.e_state = tmedia_session_state_e.OFFER_SENT;
            }

            __o_session_roap.o_mgr.callback(tmedia_session_events_e.GET_LO_SUCCESS, this.e_type);
        }
        else if (__o_session_roap.o_pc_json.messageType == "OK") {
            __o_session_roap.o_mgr.callback(tmedia_session_events_e.SET_RO_SUCCESS, this.e_type);
        }
        if (__o_session_roap.o_pc_json.messageType == "ERROR") {
            tsk_utils_log_error("onSignalingMessage::messageType = ERROR");
            __o_session_roap.o_mgr.callback(tmedia_session_events_e.GET_LO_FAILED, this.e_type); // FIXME
        }
    }
    catch (e) {
        __o_session_roap.o_mgr.callback(tmedia_session_events_e.GET_LO_FAILED, this.e_type);
        tsk_utils_log_error(e);
        return;
    }
    /* Hold/Resume */
    // __o_session_roap.M.o_lo.set_holdresume_att(__o_session_roap.b_lo_held, __o_session_roap.b_ro_held);
    /* callback */

}

tmedia_session_roap.prototype.__on_state_change = function (evt) {
    tsk_utils_log_info("__on_state_change");
}

tmedia_session_roap.prototype.__on_connecting = function (evt) {
    tsk_utils_log_info("__on_connecting");
}

tmedia_session_roap.prototype.__on_open = function (evt) {
    tsk_utils_log_info("__on_open");
}

tmedia_session_roap.prototype.__on_add_stream = function (evt) {
    tsk_utils_log_info("__on_add_stream");

    // alert user
    if (__o_session_roap) {
        __o_session_roap.o_remote_stream = evt.stream;
        if (__o_session_roap.o_mgr) {
            __o_session_roap.o_mgr.set_stream_remote(evt.stream);
        }
    }
}

tmedia_session_roap.prototype.__on_remove_stream = function (evt) {
    tsk_utils_log_info("__on_remove_stream");

    // alert user
    if (__o_session_roap) {
        __o_session_roap.o_remote_stream = null;
        if (__o_session_roap.o_mgr) {
            __o_session_roap.o_mgr.set_stream_remote(null);
        }
    }
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var tmedia_param_type_e =
{
    CODEC: 0,
    SESSION: 1,
    MANAGER: 2
};

function tmedia_param(e_type, e_media_type, s_key, o_value) {
    this.e_type = e_type;
    this.e_media_type = e_media_type;
    this.s_key = s_key;
    this.o_value = o_value;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var tmedia_qos_status_e =
{
    CURR: 0,
    DEST: 1,
    CONF: 3
};

var tmedia_qos_ptype_e =
{
    QOS: 0
};

var tmedia_qos_stype_e =
{
    NONE: 0,
    SEGMENTED: 1,
    E2E: 2
};

var tmedia_qos_strength_e =
{
    NONE: 0,
    FAILURE: 1,
    UNKNOWN: 2,
    OPTIONAL: 3,
    MANDATORY: 4
};

var tmedia_qos_direction_e =
{
    NONE: 0x00,
    SEND: (0x01 << 1),
    RECV: (0x01 << 2),
    SEND_RECV: (0x01 << 1) | (0x01 << 2)// (SEND | RECV)
};


/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var tsdp_header_type_e =
{
    NONE: { i_rank: -1, c_name: null },

    A: { i_rank: 13, c_name: 'a' },
    B: { i_rank: 8, c_name: 'b' },
    C: { i_rank: 7, c_name: 'c' },
    DUMMY: { i_rank: 255, c_name: '*' },
    E: { i_rank: 5, c_name: 'e' },
    I: { i_rank: 3, c_name: 'i' },
    K: { i_rank: 12, c_name: 'k' },
    M: { i_rank: 14, c_name: 'm' },
    O: { i_rank: 1, c_name: 'o' },
    P: { i_rank: 6, c_name: 'p' },
    R: { i_rank: 10, c_name: 'r' },
    S: { i_rank: 2, c_name: 's' },
    T: { i_rank: 9, c_name: 't' },
    U: { i_rank: 4, c_name: 'u' },
    V: { i_rank: 0, c_name: 'v' },
    Z: { i_rank: 11, c_name: 'z' }
};

function tsdp_header(e_type) {
    this.e_type = e_type;
}

tsdp_header.prototype.tostring_full = function (b_without_crlf, s_endline) {
    return tsk_string_format("{0}={1}{2}", this.get_name(), this.toString(s_endline), b_without_crlf ? "" : (s_endline ? s_endline : "\r\n"));
}

tsdp_header.prototype.get_name = function () {
    if (this.e_type == tsdp_header_type_e.DUMMY) {
        return this.c_name;
    }
    return this.e_type.c_name;
}

function tsdp_header_compare_by_rank(o_hdr_1, o_hdr_2) {
    if (o_hdr_1 && o_hdr_2) {
        return o_hdr_1.e_type.i_rank - o_hdr_2.e_type.i_rank;
    }
    return -1;
}


if(!window.__b_release_mode){
    tsdp_api_add_js_scripts('head',
        'src/tinySDP/src/headers/tsdp_header_A.js',
        'src/tinySDP/src/headers/tsdp_header_C.js',
        'src/tinySDP/src/headers/tsdp_header_M.js',
        'src/tinySDP/src/headers/tsdp_header_O.js',
        'src/tinySDP/src/headers/tsdp_header_Str.js', // B, E, I, K, P, R, S, T, U, Z
        'src/tinySDP/src/headers/tsdp_header_V.js'
    );
}

/* line 1 "./ragel/tsdp_parser_header_A.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

tsdp_header_A.prototype = Object.create(tsdp_header.prototype);

/* line 34 "./ragel/tsdp_parser_header_A.jrl" */



/* line 16 "./src/headers/tsdp_header_A.js" */
_tsdp_machine_parser_header_A_actions = [
	0, 1, 0, 1, 1, 1, 2, 2, 
	0, 2
];

_tsdp_machine_parser_header_A_key_offsets = [
	0, 0, 1, 3, 18, 19, 35, 35, 
	38
];

_tsdp_machine_parser_header_A_trans_keys = [
	97, 32, 61, 32, 33, 37, 39, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 10, 13, 33, 37, 39, 58, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 13, 0, 65535, 13, 0, 
	65535, 0
];

_tsdp_machine_parser_header_A_single_lengths = [
	0, 1, 2, 5, 1, 6, 0, 1, 
	1
];

_tsdp_machine_parser_header_A_range_lengths = [
	0, 0, 0, 5, 0, 5, 0, 1, 
	1
];

_tsdp_machine_parser_header_A_index_offsets = [
	0, 0, 2, 5, 16, 18, 30, 31, 
	34
];

_tsdp_machine_parser_header_A_indicies = [
	0, 1, 0, 2, 1, 2, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 1, 
	4, 1, 5, 6, 6, 6, 7, 6, 
	6, 6, 6, 6, 6, 1, 1, 9, 
	8, 1, 11, 10, 1, 0
];

_tsdp_machine_parser_header_A_trans_targs = [
	2, 0, 3, 5, 6, 4, 5, 7, 
	8, 4, 8, 4
];

_tsdp_machine_parser_header_A_trans_actions = [
	0, 0, 0, 1, 0, 3, 0, 3, 
	1, 7, 0, 5
];

_tsdp_machine_parser_header_A_eof_actions = [
	0, 0, 0, 0, 0, 3, 0, 7, 
	5
];

tsdp_machine_parser_header_A_start = 1;
tsdp_machine_parser_header_A_first_final = 5;
tsdp_machine_parser_header_A_error = 0;

tsdp_machine_parser_header_A_en_main = 1;


/* line 37 "./ragel/tsdp_parser_header_A.jrl" */

function tsdp_header_A(s_field, s_value){
	tsdp_header.call(this, tsdp_header_type_e.A);
	this.s_field = s_field;
	this.s_value = s_value;
}

tsdp_header_A.prototype.toString = function(){
	return tsk_string_format("{0}{1}{2}",
			this.s_field,

			this.s_value ? ":" : "",
			this.s_value ? this.s_value : "");
}

tsdp_header_A.prototype.RemoveAllByField = function(ao_headers, s_field){
	var o_hdr_A;

	if(!ao_headers || !s_field){
		tsk_utils_log_error("Invalid parameter");
		return -1;
	}

	for(i = 0; i < ao_headers.length; ){
		o_hdr_A = ao_headers[i];
		if(tsk_string_iequals(s_field, o_hdr_A.s_field)){
			ao_headers.splice(i, 1);
			continue;
		}
		++i;
	}

	return 0;
}

tsdp_header_A.prototype.Parse = function(s_str){
	var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_A = new tsdp_header_A(null, null);
	
	
/* line 127 "./src/headers/tsdp_header_A.js" */
{
	 cs = tsdp_machine_parser_header_A_start;
} /* JSCodeGen::writeInit */

/* line 82 "./ragel/tsdp_parser_header_A.jrl" */
	
/* line 134 "./src/headers/tsdp_header_A.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsdp_machine_parser_header_A_key_offsets[cs];
	_trans = _tsdp_machine_parser_header_A_index_offsets[cs];
	_klen = _tsdp_machine_parser_header_A_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsdp_machine_parser_header_A_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsdp_machine_parser_header_A_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsdp_machine_parser_header_A_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsdp_machine_parser_header_A_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsdp_machine_parser_header_A_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsdp_machine_parser_header_A_indicies[_trans];
	cs = _tsdp_machine_parser_header_A_trans_targs[_trans];
	if (_tsdp_machine_parser_header_A_trans_actions[_trans] != 0) {
		_acts = _tsdp_machine_parser_header_A_trans_actions[_trans];
		_nacts = _tsdp_machine_parser_header_A_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsdp_machine_parser_header_A_actions[_acts - 1]) {
case 0:
/* line 14 "./ragel/tsdp_parser_header_A.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 18 "./ragel/tsdp_parser_header_A.jrl" */

		hdr_A.s_field = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 2:
/* line 22 "./ragel/tsdp_parser_header_A.jrl" */

		hdr_A.s_value = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
/* line 233 "./src/headers/tsdp_header_A.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	if (p == eof) {
	__acts = _tsdp_machine_parser_header_A_eof_actions[cs];
	__nacts =  _tsdp_machine_parser_header_A_actions[__acts];
	__acts += 1;
	while (__nacts > 0) {
		__nacts -= 1;
		__acts += 1;
		switch (_tsdp_machine_parser_header_A_actions[__acts - 1]) {
case 0:
/* line 14 "./ragel/tsdp_parser_header_A.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 18 "./ragel/tsdp_parser_header_A.jrl" */

		hdr_A.s_field = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 2:
/* line 22 "./ragel/tsdp_parser_header_A.jrl" */

		hdr_A.s_value = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
/* line 276 "./src/headers/tsdp_header_A.js" */
		} /* eof action switch */
	}
	if (_trigger_goto) {
		continue;
	}
}
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 83 "./ragel/tsdp_parser_header_A.jrl" */
	
	if( cs < 
/* line 293 "./src/headers/tsdp_header_A.js" */
5
/* line 84 "./ragel/tsdp_parser_header_A.jrl" */
 ){
		tsk_utils_log_error("Failed to parse \"a=\" header: " + s_str);
		return null;
	}
	
	return hdr_A;
}





/* line 1 "./ragel/tsdp_parser_header_C.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

tsdp_header_C.prototype = Object.create(tsdp_header.prototype);

/* line 38 "./ragel/tsdp_parser_header_C.jrl" */



/* line 16 "./src/headers/tsdp_header_C.js" */
_tsdp_machine_parser_header_C_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 2, 0, 2, 2, 0, 3
];

_tsdp_machine_parser_header_C_key_offsets = [
	0, 0, 1, 3, 6, 9, 12, 15, 
	16, 19, 22
];

_tsdp_machine_parser_header_C_trans_keys = [
	99, 32, 61, 32, 0, 65535, 32, 0, 
	65535, 32, 0, 65535, 32, 0, 65535, 10, 
	13, 0, 65535, 13, 0, 65535, 0
];

_tsdp_machine_parser_header_C_single_lengths = [
	0, 1, 2, 1, 1, 1, 1, 1, 
	1, 1, 0
];

_tsdp_machine_parser_header_C_range_lengths = [
	0, 0, 0, 1, 1, 1, 1, 0, 
	1, 1, 0
];

_tsdp_machine_parser_header_C_index_offsets = [
	0, 0, 2, 5, 8, 11, 14, 17, 
	19, 22, 25
];

_tsdp_machine_parser_header_C_trans_targs = [
	2, 0, 2, 3, 0, 3, 4, 0, 
	5, 4, 0, 8, 6, 0, 8, 6, 
	0, 10, 0, 7, 9, 0, 7, 9, 
	0, 0, 0
];

_tsdp_machine_parser_header_C_trans_actions = [
	0, 0, 0, 0, 0, 0, 1, 0, 
	3, 0, 0, 9, 1, 0, 5, 0, 
	0, 0, 0, 12, 1, 0, 7, 0, 
	0, 0, 0
];

_tsdp_machine_parser_header_C_eof_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	12, 7, 0
];

tsdp_machine_parser_header_C_start = 1;
tsdp_machine_parser_header_C_first_final = 8;
tsdp_machine_parser_header_C_error = 0;

tsdp_machine_parser_header_C_en_main = 1;


/* line 41 "./ragel/tsdp_parser_header_C.jrl" */

function tsdp_header_C(s_nettype, s_addrtype, s_addr){
	tsdp_header.call(this, tsdp_header_type_e.C);
	this.s_nettype = s_nettype;
	this.s_addrtype = s_addrtype;
	this.s_addr = s_addr;
}

tsdp_header_C.prototype.toString = function(){
	return tsk_string_format("{0} {1} {2}", 
			this.s_nettype,
			this.s_addrtype,
			this.s_addr);
}

tsdp_header_C.prototype.Parse = function(s_str){
	var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_C = new tsdp_header_C(null, null, null);
	
	
/* line 100 "./src/headers/tsdp_header_C.js" */
{
	 cs = tsdp_machine_parser_header_C_start;
} /* JSCodeGen::writeInit */

/* line 66 "./ragel/tsdp_parser_header_C.jrl" */
	
/* line 107 "./src/headers/tsdp_header_C.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsdp_machine_parser_header_C_key_offsets[cs];
	_trans = _tsdp_machine_parser_header_C_index_offsets[cs];
	_klen = _tsdp_machine_parser_header_C_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsdp_machine_parser_header_C_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsdp_machine_parser_header_C_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsdp_machine_parser_header_C_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsdp_machine_parser_header_C_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsdp_machine_parser_header_C_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	cs = _tsdp_machine_parser_header_C_trans_targs[_trans];
	if (_tsdp_machine_parser_header_C_trans_actions[_trans] != 0) {
		_acts = _tsdp_machine_parser_header_C_trans_actions[_trans];
		_nacts = _tsdp_machine_parser_header_C_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsdp_machine_parser_header_C_actions[_acts - 1]) {
case 0:
/* line 14 "./ragel/tsdp_parser_header_C.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 18 "./ragel/tsdp_parser_header_C.jrl" */

		hdr_C.s_nettype = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 2:
/* line 22 "./ragel/tsdp_parser_header_C.jrl" */

		hdr_C.s_addrtype = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 3:
/* line 26 "./ragel/tsdp_parser_header_C.jrl" */

		hdr_C.s_addr = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
/* line 210 "./src/headers/tsdp_header_C.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	if (p == eof) {
	__acts = _tsdp_machine_parser_header_C_eof_actions[cs];
	__nacts =  _tsdp_machine_parser_header_C_actions[__acts];
	__acts += 1;
	while (__nacts > 0) {
		__nacts -= 1;
		__acts += 1;
		switch (_tsdp_machine_parser_header_C_actions[__acts - 1]) {
case 0:
/* line 14 "./ragel/tsdp_parser_header_C.jrl" */

		i_tag_start = p;
			break;
case 3:
/* line 26 "./ragel/tsdp_parser_header_C.jrl" */

		hdr_C.s_addr = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
/* line 248 "./src/headers/tsdp_header_C.js" */
		} /* eof action switch */
	}
	if (_trigger_goto) {
		continue;
	}
}
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 67 "./ragel/tsdp_parser_header_C.jrl" */
	
	if( cs < 
/* line 265 "./src/headers/tsdp_header_C.js" */
8
/* line 68 "./ragel/tsdp_parser_header_C.jrl" */
 ){
		tsk_utils_log_error("Failed to parse \"c=\" header: " + s_str);
		return null;
	}
	
	return hdr_C;
}

/* line 1 "./ragel/tsdp_parser_header_M.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

tsdp_header_M.prototype = Object.create(tsdp_header.prototype);

/* line 49 "./ragel/tsdp_parser_header_M.jrl" */




/* line 17 "./src/headers/tsdp_header_M.js" */
_tsdp_machine_parser_header_M_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4
];

_tsdp_machine_parser_header_M_key_offsets = [
	0, 0, 1, 3, 18, 33, 35, 39, 
	53, 54, 68, 70, 73, 88, 88, 103
];

_tsdp_machine_parser_header_M_trans_keys = [
	109, 32, 61, 32, 33, 37, 39, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 32, 33, 37, 39, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 48, 57, 32, 47, 48, 57, 33, 
	37, 39, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 10, 33, 37, 
	39, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 48, 57, 32, 48, 
	57, 13, 32, 33, 37, 39, 47, 126, 
	42, 43, 45, 57, 65, 90, 95, 122, 
	13, 33, 37, 39, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 13, 
	32, 33, 37, 39, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 0
];

_tsdp_machine_parser_header_M_single_lengths = [
	0, 1, 2, 5, 5, 0, 2, 4, 
	1, 4, 0, 1, 7, 0, 5, 6
];

_tsdp_machine_parser_header_M_range_lengths = [
	0, 0, 0, 5, 5, 1, 1, 5, 
	0, 5, 1, 1, 4, 0, 5, 5
];

_tsdp_machine_parser_header_M_index_offsets = [
	0, 0, 2, 5, 16, 27, 29, 33, 
	43, 45, 55, 57, 60, 72, 73, 84
];

_tsdp_machine_parser_header_M_indicies = [
	0, 1, 0, 2, 1, 2, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 1, 
	4, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 1, 6, 1, 7, 8, 9, 
	1, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 1, 11, 1, 12, 12, 12, 
	12, 12, 12, 12, 12, 12, 1, 13, 
	1, 7, 14, 1, 15, 16, 12, 12, 
	12, 17, 12, 12, 12, 12, 12, 1, 
	1, 18, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 1, 20, 21, 22, 22, 
	22, 22, 22, 22, 22, 22, 22, 1, 
	0
];

_tsdp_machine_parser_header_M_trans_targs = [
	2, 0, 3, 4, 5, 4, 6, 7, 
	10, 6, 12, 13, 12, 11, 11, 8, 
	14, 9, 8, 15, 8, 14, 15
];

_tsdp_machine_parser_header_M_trans_actions = [
	0, 0, 0, 1, 3, 0, 1, 5, 
	5, 0, 1, 0, 0, 1, 0, 7, 
	7, 0, 0, 1, 9, 9, 0
];

_tsdp_machine_parser_header_M_eof_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 7, 0, 0, 9
];

tsdp_machine_parser_header_M_start = 1;
tsdp_machine_parser_header_M_first_final = 12;
tsdp_machine_parser_header_M_error = 0;

tsdp_machine_parser_header_M_en_main = 1;


/* line 53 "./ragel/tsdp_parser_header_M.jrl" */

function tsdp_header_M(s_media, i_port, s_proto){
	tsdp_header.call(this, tsdp_header_type_e.M);
	this.s_media = s_media;
	this.i_port = i_port;
	this.i_nports = 0; // number of ports
	this.s_proto = s_proto;
	this.as_fmt = new Array();

	this.o_hdr_I = null;
	this.o_hdr_C = null;
	this.ao_hdr_B = new Array();
	this.o_hdr_K = null;
	this.ao_hdr_A = new Array();
	this.ao_hdr_Dummy = new Array();
}

tsdp_header_M.prototype.toString = function(s_endline){
	if(!s_endline){
		s_endline = "\r\n";
	}
	/*	IMPORTANT: Keep the order.
			
		m=  (media name and transport address)
		i=* (media title)
		c=* (connection information -- optional if included at
				session level)
		b=* (zero or more bandwidth information lines)
		k=* (encryption key)
		a=* (zero or more media attribute lines)
	*/
	var s_str = tsk_string_format("{0} {1}{2}{3} {4}",
			this.s_media,
			this.i_port,
			
			this.i_nports ? "/" : "",
			this.i_nports ? this.i_nports : "",

			this.s_proto);

	// FMTs
	for(var i = 0; i < this.as_fmt.length; ++i){
		s_str += " " + this.as_fmt[i];
	}
		
	var b_single_line = !this.o_hdr_I && !this.o_hdr_C && this.ao_hdr_B.length==0 && !this.o_hdr_K && this.ao_hdr_A.length.length==0;
	if(b_single_line){
		return s_str;
	}

	// close the "m=" line
	s_str += s_endline;

	// i=* (media title)
	if(this.o_hdr_I){
		s_str += this.o_hdr_I.tostring_full(false, s_endline);
	}
	// c=* (connection information -- optional if included at session level)
	if(this.o_hdr_C){
		s_str += this.o_hdr_C.tostring_full(false, s_endline);
	}
	// b=* (zero or more bandwidth information lines)
	for(var i = 0; i < this.ao_hdr_B.length; ++i){
		s_str += this.ao_hdr_B[i].tostring_full(false, s_endline);
	}
		
	// k=* (encryption key)
	if(this.o_hdr_K){
		s_str += this.o_hdr_K.tostring_full(false, s_endline);
	}
	// a=* (zero or more media attribute lines)
	for(var i = 0; i < this.ao_hdr_A.length; ++i){
		s_str += this.ao_hdr_A[i].tostring_full(false, s_endline);
	}
	// dummies
	for(var i = 0; i < this.ao_hdr_Dummy.length; ++i){
		s_str += this.ao_hdr_Dummy[i].tostring_full(false, s_endline);
	}
		
	return s_str.substring(0, s_str.length - s_endline.length);
}

// for A headers, use "tsdp_header_A_removeAll_by_field()"
tsdp_header_M.prototype.remove_header = function(e_type){
	switch(e_type){
		case tsdp_header_type_e.I:
			{
                this.o_hdr_I = null;
				break;
			}
		case tsdp_header_type_e.C:
			{
                this.o_hdr_C = null;
				break;
			}
		case tsdp_header_type_e.B:
			{
                this.ao_hdr_B.splice(0, this.ao_hdr_B.length);
				break;
			}
		case tsdp_header_type_e.K:
			{
                this.o_hdr_K = null;
				break;
			}
	}
	return 0;
}

tsdp_header_M.prototype.add_header = function(o_header){
	if(!o_header){
		tsk_utils_log_error("Invalid argument");
		return -1;
	}

	switch(o_header.e_type){
		case tsdp_header_type_e.I:
			{
				this.o_hdr_I = o_header;
				break;
			}
		case tsdp_header_type_e.C:
			{
				this.o_hdr_C = o_header;
				break;
			}
		case tsdp_header_type_e.B:
			{
				this.ao_hdr_B.push(o_header);
				break;
			}
		case tsdp_header_type_e.K:
			{
				this.o_hdr_K = o_header;
				break;
			}
		case tsdp_header_type_e.A:
			{
				this.ao_hdr_A.push(o_header);
				break;
			}
	}
	
	return 0;
}

tsdp_header_M.prototype.add_fmt = function(s_fmt){
	if(s_fmt){
		this.as_fmt.push(s_fmt);
	}
}

// add_headers(...)
tsdp_header_M.prototype.add_headers = function(){
	for(var i = 0; i < arguments.length; ++i){
		if(arguments[i]){
			this.add_header(arguments[i]);
		}
	}
}

tsdp_header_M.prototype.find_a_at = function(s_field, i_index) {
	if(!s_field || i_index < 0){
		tsk_utils_log_error("Invalid argument");
		return null;
	}

	var i_pos = 0;
	for(var i = 0; i < this.ao_hdr_A.length; ++i){
		if(this.ao_hdr_A[i].s_field == s_field){
			if(i_pos++ >= i_index){
				return this.ao_hdr_A[i];
			}
		}
	}
	return null;
}

tsdp_header_M.prototype.find_a = function(s_field) {
	return this.find_a_at(s_field, 0);
}

tsdp_header_M.prototype.get_rtpmap = function(s_fmt){
	var i_fmt_len = s_fmt ? s_fmt.length : 0;
	if(i_fmt_len <= 0 || i_fmt_len > 3/*'0-255' or '*'*/){
		tsk_utils_log_error("Invalid argument");
		return null;
	}
	var s_rtpmap = null; /* e.g. AMR-WB/16000 */
	var i_A_len, i_index = 0;
	var i_indexof;
	
	var o_hdr_A;
	
	/* find "a=rtpmap" */
	while((o_hdr_A = this.find_a_at(i_index++))){
		/* A->value would be: "98 AMR-WB/16000" */
		if((i_A_len = o_hdr_A.s_value ? o_hdr_A.s_value.length : 0) < (i_fmt_len + 1/*space*/)){
			continue;
		}
		if((i_indexof = tsk_string_index_of(o_hdr_A.s_value, i_A_len, s_fmt)) == 0 && (o_hdr_A.s_value[i_fmt_len] == ' ')){
			s_rtpmap = o_hdr_A.s_value.substring(i_fmt_len+1, A_len);
			break;
		}
	}

	return s_rtpmap;
}

tsdp_header_M.prototype.get_fmtp = function(s_fmt){
	var i_fmt_len = s_fmt ? s_fmt.length : 0;
	if(i_fmt_len <= 0 || i_fmt_len > 3/*'0-255' or '*'*/){
		tsk_utils_log_error("Invalid argument");
		return null;
	}
	var s_fmtp= null; /* e.g. octet-align=1 */
	var i_A_len, i_index = 0;
	var i_indexof;
	
	var o_hdr_A;
	
	/* find "a=rtpmap" */
	while((o_hdr_A = this.find_a_at(i_index++))){
		/* A->value would be: "98 octet-align=1" */
		if((i_A_len = o_hdr_A.s_value ? o_hdr_A.s_value.length : 0) < (i_fmt_len + 1/*space*/)){
			continue;
		}
		if((i_indexof = tsk_string_index_of(o_hdr_A.s_value, i_A_len, s_fmt)) == 0 && (o_hdr_A.s_value[i_fmt_len] == ' ')){
			s_fmtp = o_hdr_A.s_value.substring(i_fmt_len+1, A_len);
			break;
		}
	}

	return s_fmtp;
}

/* as per 3GPP TS 34.610 */
tsdp_header_M.prototype.hold = function(b_local){
	var o_hdr_A;

	if((o_hdr_A = this.find_a(b_local ? "recvonly" : "sendonly"))){
		// an "inactive" SDP attribute if the stream was previously set to "recvonly" media stream
		o_hdr_A.s_field = b_local ? "inactive" : "recvonly";
	}
	else if((o_hdr_A = this.find_a("sendrecv"))){
		// a "sendonly" SDP attribute if the stream was previously set to "sendrecv" media stream
		o_hdr_A.s_field = b_local ? "sendonly" : "recvonly";
	}
	else{
		// default value is sendrecv. hold on default --> sendonly
		if(!(o_hdr_A = this.find_a(b_local ? "sendonly" : "recvonly")) && !(o_hdr_A = this.find_a("inactive"))){
			var o_hdr_newA;
			if((o_hdr_newA = new tsdp_header_A(b_local ? "sendonly" : "recvonly", null))){
				this.add_header(o_hdr_newA);
			}
		}
	}
	return 0;
}

/* as per 3GPP TS 34.610 */
tsdp_header_M.prototype.set_holdresume_att = function(b_lo_held, b_ro_held){
	var o_hdr_A;
	var hold_resume_atts = [["sendrecv", "recvonly"],["sendonly", "inactive"]];
	
	if((o_hdr_A = this.find_a("sendrecv")) || (o_hdr_A = this.find_a("sendonly")) || (o_hdr_A = this.find_a("recvonly")) || (o_hdr_A = this.find_a("inactive"))){
		o_hdr_A.s_field = hold_resume_atts[b_lo_held ? 1 : 0][b_ro_held ? 1 : 0];
	}
	else{
		var o_hdr_newA;
		if((o_hdr_newA = new tsdp_header_A(hold_resume_atts[b_lo_held ? 1 : 0][b_ro_held ? 1 : 0], null))){
			this.add_headers(o_hdr_newA);
		}
	}
	
	return 0;
}

tsdp_header_M.prototype.is_held = function(b_local){
	/* both cases */
	if(this.find_a("inactive")){
		return true;
	}

	if(b_local){
		return this.find_a("recvonly") ? true : false;
	}
	else{
		return this.find_a("sendonly") ? true : false;
	}
}

/* as per 3GPP TS 34.610 */
tsdp_header_M.prototype.resume = function(b_local){
	var o_hdr_A;

	if((o_hdr_A = this.find_a("inactive"))){
		// a "recvonly" SDP attribute if the stream was previously an inactive media stream
		o_hdr_A.s_field = b_local ? "recvonly" : "sendonly";
	}
	else if((o_hdr_A = this.find_a(b_local ? "sendonly" : "recvonly"))){
		// a "sendrecv" SDP attribute if the stream was previously a sendonly media stream, or the attribute may be omitted, since sendrecv is the default
		o_hdr_A.s_field = sendrecv;
	}
	return 0;
}

tsdp_header_M.prototype.Parse = function(s_str){
	var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_M = new tsdp_header_M(null, 0, null);
	
	
/* line 419 "./src/headers/tsdp_header_M.js" */
{
	 cs = tsdp_machine_parser_header_M_start;
} /* JSCodeGen::writeInit */

/* line 370 "./ragel/tsdp_parser_header_M.jrl" */
	
/* line 426 "./src/headers/tsdp_header_M.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsdp_machine_parser_header_M_key_offsets[cs];
	_trans = _tsdp_machine_parser_header_M_index_offsets[cs];
	_klen = _tsdp_machine_parser_header_M_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsdp_machine_parser_header_M_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsdp_machine_parser_header_M_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsdp_machine_parser_header_M_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsdp_machine_parser_header_M_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsdp_machine_parser_header_M_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsdp_machine_parser_header_M_indicies[_trans];
	cs = _tsdp_machine_parser_header_M_trans_targs[_trans];
	if (_tsdp_machine_parser_header_M_trans_actions[_trans] != 0) {
		_acts = _tsdp_machine_parser_header_M_trans_actions[_trans];
		_nacts = _tsdp_machine_parser_header_M_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsdp_machine_parser_header_M_actions[_acts - 1]) {
case 0:
/* line 14 "./ragel/tsdp_parser_header_M.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 18 "./ragel/tsdp_parser_header_M.jrl" */

		hdr_M.s_media = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 2:
/* line 22 "./ragel/tsdp_parser_header_M.jrl" */

		hdr_M.i_port= tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 3:
/* line 30 "./ragel/tsdp_parser_header_M.jrl" */

		hdr_M.s_proto = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 4:
/* line 34 "./ragel/tsdp_parser_header_M.jrl" */

		tsk_ragel_parser_add_string(s_str, p, i_tag_start, hdr_M.as_fmt);
			break;
/* line 535 "./src/headers/tsdp_header_M.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	if (p == eof) {
	__acts = _tsdp_machine_parser_header_M_eof_actions[cs];
	__nacts =  _tsdp_machine_parser_header_M_actions[__acts];
	__acts += 1;
	while (__nacts > 0) {
		__nacts -= 1;
		__acts += 1;
		switch (_tsdp_machine_parser_header_M_actions[__acts - 1]) {
case 3:
/* line 30 "./ragel/tsdp_parser_header_M.jrl" */

		hdr_M.s_proto = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 4:
/* line 34 "./ragel/tsdp_parser_header_M.jrl" */

		tsk_ragel_parser_add_string(s_str, p, i_tag_start, hdr_M.as_fmt);
			break;
/* line 573 "./src/headers/tsdp_header_M.js" */
		} /* eof action switch */
	}
	if (_trigger_goto) {
		continue;
	}
}
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 371 "./ragel/tsdp_parser_header_M.jrl" */
	
	if( cs < 
/* line 590 "./src/headers/tsdp_header_M.js" */
12
/* line 372 "./ragel/tsdp_parser_header_M.jrl" */
 ){
		tsk_utils_log_error("Failed to parse \"m=\" header: " + s_str);
		return null;
	}
	
	return hdr_M;
}


/* line 1 "./ragel/tsdp_parser_header_O.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

tsdp_header_O.prototype = Object.create(tsdp_header.prototype);

/* line 53 "./ragel/tsdp_parser_header_O.jrl" */




/* line 17 "./src/headers/tsdp_header_O.js" */
_tsdp_machine_parser_header_O_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 2, 
	0, 4, 2, 0, 5, 2, 0, 6
];

_tsdp_machine_parser_header_O_key_offsets = [
	0, 0, 1, 3, 6, 9, 11, 14, 
	16, 19, 22, 25, 28, 31, 32, 35, 
	38
];

_tsdp_machine_parser_header_O_trans_keys = [
	111, 32, 61, 32, 0, 65535, 32, 0, 
	65535, 48, 57, 32, 48, 57, 48, 57, 
	32, 48, 57, 32, 0, 65535, 32, 0, 
	65535, 32, 0, 65535, 32, 0, 65535, 10, 
	13, 0, 65535, 13, 0, 65535, 0
];

_tsdp_machine_parser_header_O_single_lengths = [
	0, 1, 2, 1, 1, 0, 1, 0, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	0
];

_tsdp_machine_parser_header_O_range_lengths = [
	0, 0, 0, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 0, 1, 1, 
	0
];

_tsdp_machine_parser_header_O_index_offsets = [
	0, 0, 2, 5, 8, 11, 13, 16, 
	18, 21, 24, 27, 30, 33, 35, 38, 
	41
];

_tsdp_machine_parser_header_O_trans_targs = [
	2, 0, 2, 3, 0, 3, 4, 0, 
	5, 4, 0, 6, 0, 7, 6, 0, 
	8, 0, 9, 8, 0, 11, 10, 0, 
	11, 10, 0, 14, 12, 0, 14, 12, 
	0, 16, 0, 13, 15, 0, 13, 15, 
	0, 0, 0
];

_tsdp_machine_parser_header_O_trans_actions = [
	0, 0, 0, 0, 0, 0, 1, 0, 
	3, 0, 0, 1, 0, 5, 0, 0, 
	1, 0, 7, 0, 0, 15, 1, 0, 
	9, 0, 0, 18, 1, 0, 11, 0, 
	0, 0, 0, 21, 1, 0, 13, 0, 
	0, 0, 0
];

_tsdp_machine_parser_header_O_eof_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 21, 13, 
	0
];

tsdp_machine_parser_header_O_start = 1;
tsdp_machine_parser_header_O_first_final = 14;
tsdp_machine_parser_header_O_error = 0;

tsdp_machine_parser_header_O_en_main = 1;


/* line 57 "./ragel/tsdp_parser_header_O.jrl" */

function tsdp_header_O(s_username, i_sess_id, i_sess_version, s_nettype, s_addrtype, s_addr){
	tsdp_header.call(this, tsdp_header_type_e.O);
	this.s_username = s_username;
	this.i_sess_id = i_sess_id;
	this.i_sess_version = i_sess_version;
	this.s_nettype = s_nettype;
	this.s_addrtype = s_addrtype;
	this.s_addr = s_addr;
}

tsdp_header_O.prototype.toString = function(){
	// o=alice 2890844526 2890844526 IN IP4 host.atlanta.example.com
	return tsk_string_format("{0} {1} {2} {3} {4} {5}",
		this.s_username,
		this.i_sess_id,
		this.i_sess_version,
		this.s_nettype,
		this.s_addrtype,
		this.s_addr);
}


tsdp_header_O.prototype.Parse = function(s_str){
	var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_O = new tsdp_header_O(null, 0, 0, null, null, null);
	
	
/* line 121 "./src/headers/tsdp_header_O.js" */
{
	 cs = tsdp_machine_parser_header_O_start;
} /* JSCodeGen::writeInit */

/* line 90 "./ragel/tsdp_parser_header_O.jrl" */
	
/* line 128 "./src/headers/tsdp_header_O.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsdp_machine_parser_header_O_key_offsets[cs];
	_trans = _tsdp_machine_parser_header_O_index_offsets[cs];
	_klen = _tsdp_machine_parser_header_O_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsdp_machine_parser_header_O_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsdp_machine_parser_header_O_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsdp_machine_parser_header_O_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsdp_machine_parser_header_O_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsdp_machine_parser_header_O_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	cs = _tsdp_machine_parser_header_O_trans_targs[_trans];
	if (_tsdp_machine_parser_header_O_trans_actions[_trans] != 0) {
		_acts = _tsdp_machine_parser_header_O_trans_actions[_trans];
		_nacts = _tsdp_machine_parser_header_O_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsdp_machine_parser_header_O_actions[_acts - 1]) {
case 0:
/* line 14 "./ragel/tsdp_parser_header_O.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 18 "./ragel/tsdp_parser_header_O.jrl" */

		hdr_O.s_username = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 2:
/* line 22 "./ragel/tsdp_parser_header_O.jrl" */

		hdr_O.i_sess_id = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 3:
/* line 26 "./ragel/tsdp_parser_header_O.jrl" */

		hdr_O.i_sess_version = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 4:
/* line 30 "./ragel/tsdp_parser_header_O.jrl" */

		hdr_O.s_nettype = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 5:
/* line 34 "./ragel/tsdp_parser_header_O.jrl" */

		hdr_O.s_addrtype = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 6:
/* line 38 "./ragel/tsdp_parser_header_O.jrl" */

		hdr_O.s_addr= tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
/* line 246 "./src/headers/tsdp_header_O.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	if (p == eof) {
	__acts = _tsdp_machine_parser_header_O_eof_actions[cs];
	__nacts =  _tsdp_machine_parser_header_O_actions[__acts];
	__acts += 1;
	while (__nacts > 0) {
		__nacts -= 1;
		__acts += 1;
		switch (_tsdp_machine_parser_header_O_actions[__acts - 1]) {
case 0:
/* line 14 "./ragel/tsdp_parser_header_O.jrl" */

		i_tag_start = p;
			break;
case 6:
/* line 38 "./ragel/tsdp_parser_header_O.jrl" */

		hdr_O.s_addr= tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
/* line 284 "./src/headers/tsdp_header_O.js" */
		} /* eof action switch */
	}
	if (_trigger_goto) {
		continue;
	}
}
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 91 "./ragel/tsdp_parser_header_O.jrl" */
	
	if( cs < 
/* line 301 "./src/headers/tsdp_header_O.js" */
14
/* line 92 "./ragel/tsdp_parser_header_O.jrl" */
 ){
		tsk_utils_log_error("Failed to parse \"o=\" header: " + s_str);
		return null;
	}
	
	return hdr_O;
}


/* line 1 "./ragel/tsdp_parser_header_Str.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

// Parse headers: B, E, I, K, P, R, S, T, U, Z, Dummy
tsdp_header_Str.prototype = Object.create(tsdp_header.prototype);
tsdp_header_B.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_E.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_I.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_K.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_P.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_R.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_S.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_T.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_U.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_Z.prototype = Object.create(tsdp_header_Str.prototype);
tsdp_header_Dummy.prototype = Object.create(tsdp_header_Str.prototype);

tsdp_header_Str.prototype.s_value = null;


/* line 56 "./ragel/tsdp_parser_header_Str.jrl" */



/* line 31 "./src/headers/tsdp_header_Str.js" */
_tsdp_machine_parser_header_Str_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 1, 8, 1, 9, 1, 10, 1, 
	11, 1, 12, 2, 0, 12
];

_tsdp_machine_parser_header_Str_key_offsets = [
	0, 0, 14, 16, 18, 19, 21, 23, 
	25, 27, 29, 31, 33, 35, 37, 39, 
	43, 46
];

_tsdp_machine_parser_header_Str_trans_keys = [
	98, 101, 105, 107, 112, 114, 115, 116, 
	117, 122, 65, 90, 97, 121, 32, 61, 
	32, 61, 10, 32, 61, 32, 61, 32, 
	61, 32, 61, 32, 61, 32, 61, 32, 
	61, 32, 61, 32, 61, 32, 61, 13, 
	32, 0, 65535, 13, 0, 65535, 0
];

_tsdp_machine_parser_header_Str_single_lengths = [
	0, 10, 2, 2, 1, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	1, 0
];

_tsdp_machine_parser_header_Str_range_lengths = [
	0, 2, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	1, 0
];

_tsdp_machine_parser_header_Str_index_offsets = [
	0, 0, 13, 16, 19, 21, 24, 27, 
	30, 33, 36, 39, 42, 45, 48, 51, 
	55, 58
];

_tsdp_machine_parser_header_Str_trans_targs = [
	5, 6, 7, 8, 9, 10, 11, 12, 
	13, 14, 2, 2, 0, 3, 15, 0, 
	3, 15, 0, 17, 0, 3, 15, 0, 
	3, 15, 0, 3, 15, 0, 3, 15, 
	0, 3, 15, 0, 3, 15, 0, 3, 
	15, 0, 3, 15, 0, 3, 15, 0, 
	3, 15, 0, 4, 15, 16, 0, 4, 
	16, 0, 0, 0
];

_tsdp_machine_parser_header_Str_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 0, 23, 23, 0, 
	0, 0, 0, 0, 0, 3, 3, 0, 
	5, 5, 0, 7, 7, 0, 9, 9, 
	0, 11, 11, 0, 13, 13, 0, 15, 
	15, 0, 17, 17, 0, 19, 19, 0, 
	21, 21, 0, 27, 0, 1, 0, 25, 
	0, 0, 0, 0
];

_tsdp_machine_parser_header_Str_eof_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 27, 
	25, 0
];

tsdp_machine_parser_header_Str_start = 1;
tsdp_machine_parser_header_Str_first_final = 15;
tsdp_machine_parser_header_Str_error = 0;

tsdp_machine_parser_header_Str_en_main = 1;


/* line 59 "./ragel/tsdp_parser_header_Str.jrl" */

function tsdp_header_Str(e_type, s_value){
	tsdp_header.call(this, e_type);
	this.s_value = s_value;
}

tsdp_header_Str.prototype.toString = function(){
	return this.s_value;
}

tsdp_header_Str.prototype.Parse = function(s_str){
	var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var o_hdr = null;
	
	
/* line 128 "./src/headers/tsdp_header_Str.js" */
{
	 cs = tsdp_machine_parser_header_Str_start;
} /* JSCodeGen::writeInit */

/* line 79 "./ragel/tsdp_parser_header_Str.jrl" */
	
/* line 135 "./src/headers/tsdp_header_Str.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsdp_machine_parser_header_Str_key_offsets[cs];
	_trans = _tsdp_machine_parser_header_Str_index_offsets[cs];
	_klen = _tsdp_machine_parser_header_Str_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsdp_machine_parser_header_Str_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsdp_machine_parser_header_Str_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsdp_machine_parser_header_Str_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsdp_machine_parser_header_Str_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsdp_machine_parser_header_Str_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	cs = _tsdp_machine_parser_header_Str_trans_targs[_trans];
	if (_tsdp_machine_parser_header_Str_trans_actions[_trans] != 0) {
		_acts = _tsdp_machine_parser_header_Str_trans_actions[_trans];
		_nacts = _tsdp_machine_parser_header_Str_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsdp_machine_parser_header_Str_actions[_acts - 1]) {
case 0:
/* line 29 "./ragel/tsdp_parser_header_Str.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 33 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_B(); 		break;
case 2:
/* line 34 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_E(); 		break;
case 3:
/* line 35 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_I(); 		break;
case 4:
/* line 36 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_K(); 		break;
case 5:
/* line 37 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_P(); 		break;
case 6:
/* line 38 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_R(); 		break;
case 7:
/* line 39 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_S(); 		break;
case 8:
/* line 40 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_T(); 		break;
case 9:
/* line 41 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_U(); 		break;
case 10:
/* line 42 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_Z(); 		break;
case 11:
/* line 43 "./ragel/tsdp_parser_header_Str.jrl" */
 o_hdr = new tsdp_header_Dummy(); o_hdr.c_name = tsk_ragel_parser_get_string(s_str, p, i_tag_start)[0]; 		break;
case 12:
/* line 45 "./ragel/tsdp_parser_header_Str.jrl" */

		if(o_hdr){
			o_hdr.s_value = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
		}
			break;
/* line 263 "./src/headers/tsdp_header_Str.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	if (p == eof) {
	__acts = _tsdp_machine_parser_header_Str_eof_actions[cs];
	__nacts =  _tsdp_machine_parser_header_Str_actions[__acts];
	__acts += 1;
	while (__nacts > 0) {
		__nacts -= 1;
		__acts += 1;
		switch (_tsdp_machine_parser_header_Str_actions[__acts - 1]) {
case 0:
/* line 29 "./ragel/tsdp_parser_header_Str.jrl" */

		i_tag_start = p;
			break;
case 12:
/* line 45 "./ragel/tsdp_parser_header_Str.jrl" */

		if(o_hdr){
			o_hdr.s_value = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
		}
			break;
/* line 303 "./src/headers/tsdp_header_Str.js" */
		} /* eof action switch */
	}
	if (_trigger_goto) {
		continue;
	}
}
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 80 "./ragel/tsdp_parser_header_Str.jrl" */
	
	if( cs < 
/* line 320 "./src/headers/tsdp_header_Str.js" */
15
/* line 81 "./ragel/tsdp_parser_header_Str.jrl" */
 ){
		tsk_utils_log_error("Failed to parse header: " + s_str);
		return null;
	}
	
	return o_hdr;
}

function tsdp_header_B(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.B, s_value); }
function tsdp_header_E(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.E, s_value); }
function tsdp_header_I(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.I, s_value); }
function tsdp_header_K(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.K, s_value); }
function tsdp_header_P(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.P, s_value); }
function tsdp_header_R(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.R, s_value); }
function tsdp_header_S(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.S, s_value); }
function tsdp_header_T(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.T, s_value); }
function tsdp_header_U(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.U, s_value); }
function tsdp_header_Z(s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.Z, s_value); }
function tsdp_header_Dummy(s_name, s_value){ tsdp_header_Str.call(this, tsdp_header_type_e.DUMMY, s_value); this.s_name = s_name; }


/* line 1 "./ragel/tsdp_parser_header_V.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

tsdp_header_V.prototype = Object.create(tsdp_header.prototype);

/* line 27 "./ragel/tsdp_parser_header_V.jrl" */



/* line 16 "./src/headers/tsdp_header_V.js" */
_tsdp_machine_parser_header_V_actions = [
	0, 1, 0, 1, 1
];

_tsdp_machine_parser_header_V_key_offsets = [
	0, 0, 1, 3, 6, 7, 10
];

_tsdp_machine_parser_header_V_trans_keys = [
	118, 32, 61, 32, 48, 57, 10, 13, 
	48, 57, 0
];

_tsdp_machine_parser_header_V_single_lengths = [
	0, 1, 2, 1, 1, 1, 0
];

_tsdp_machine_parser_header_V_range_lengths = [
	0, 0, 0, 1, 0, 1, 0
];

_tsdp_machine_parser_header_V_index_offsets = [
	0, 0, 2, 5, 8, 10, 13
];

_tsdp_machine_parser_header_V_trans_targs = [
	2, 0, 2, 3, 0, 3, 5, 0, 
	6, 0, 4, 5, 0, 0, 0
];

_tsdp_machine_parser_header_V_trans_actions = [
	0, 0, 0, 0, 0, 0, 1, 0, 
	0, 0, 3, 0, 0, 0, 0
];

_tsdp_machine_parser_header_V_eof_actions = [
	0, 0, 0, 0, 0, 3, 0
];

tsdp_machine_parser_header_V_start = 1;
tsdp_machine_parser_header_V_first_final = 5;
tsdp_machine_parser_header_V_error = 0;

tsdp_machine_parser_header_V_en_main = 1;


/* line 30 "./ragel/tsdp_parser_header_V.jrl" */

function tsdp_header_V(i_version){
	tsdp_header.call(this, tsdp_header_type_e.V);
	this.i_version = i_version;
	this.toString = function(){
		return this.i_version.toString();
	}
}

tsdp_header_V.prototype.Parse = function(s_str){
	var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_V = new tsdp_header_V(0);
	
	
/* line 83 "./src/headers/tsdp_header_V.js" */
{
	 cs = tsdp_machine_parser_header_V_start;
} /* JSCodeGen::writeInit */

/* line 49 "./ragel/tsdp_parser_header_V.jrl" */
	
/* line 90 "./src/headers/tsdp_header_V.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsdp_machine_parser_header_V_key_offsets[cs];
	_trans = _tsdp_machine_parser_header_V_index_offsets[cs];
	_klen = _tsdp_machine_parser_header_V_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsdp_machine_parser_header_V_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsdp_machine_parser_header_V_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsdp_machine_parser_header_V_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsdp_machine_parser_header_V_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsdp_machine_parser_header_V_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	cs = _tsdp_machine_parser_header_V_trans_targs[_trans];
	if (_tsdp_machine_parser_header_V_trans_actions[_trans] != 0) {
		_acts = _tsdp_machine_parser_header_V_trans_actions[_trans];
		_nacts = _tsdp_machine_parser_header_V_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsdp_machine_parser_header_V_actions[_acts - 1]) {
case 0:
/* line 14 "./ragel/tsdp_parser_header_V.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 18 "./ragel/tsdp_parser_header_V.jrl" */

		hdr_V.i_version = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
/* line 183 "./src/headers/tsdp_header_V.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	if (p == eof) {
	__acts = _tsdp_machine_parser_header_V_eof_actions[cs];
	__nacts =  _tsdp_machine_parser_header_V_actions[__acts];
	__acts += 1;
	while (__nacts > 0) {
		__nacts -= 1;
		__acts += 1;
		switch (_tsdp_machine_parser_header_V_actions[__acts - 1]) {
case 1:
/* line 18 "./ragel/tsdp_parser_header_V.jrl" */

		hdr_V.i_version = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
/* line 216 "./src/headers/tsdp_header_V.js" */
		} /* eof action switch */
	}
	if (_trigger_goto) {
		continue;
	}
}
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 50 "./ragel/tsdp_parser_header_V.jrl" */
	
	if( cs < 
/* line 233 "./src/headers/tsdp_header_V.js" */
5
/* line 51 "./ragel/tsdp_parser_header_V.jrl" */
 ){
		tsk_utils_log_error("Failed to parse \"v=\" header: " + s_str);
		return null;
	}
	
	return hdr_V;
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsdp_message.prototype.__s_o_username_default = "webrtc";
tsdp_message.prototype.__i_o_session_ver_default = 2301;
tsdp_message.prototype.__i_o_session_id_default = 1983;
tsdp_message.prototype.__s_s_value_default = "-";

function tsdp_message(s_addr, b_ipv6, i_version) {
    this.ao_headers = new Array();

    if (s_addr) {

        /*	RFC 3264 - 5 Generating the Initial Offer
        The numeric value of the session id and version in the o line MUST be 
        representable with a 64 bit signed integer.  The initial value of the version MUST be less than
        (2**62)-1, to avoid rollovers.
        */
        this.add_headers(
                new tsdp_header_V(0),
                new tsdp_header_O(
                    tsdp_message.prototype.__s_o_username_default,
                    tsdp_message.prototype.__i_o_session_id_default,
                    i_version,
                    "IN",
                    b_ipv6 ? "IP6" : "IP4",
                    s_addr));

        /*	RFC 3264 - 5 Generating the Initial Offer
        The SDP "s=" line conveys the subject of the session, which is
        reasonably defined for multicast, but ill defined for unicast.  For
        unicast sessions, it is RECOMMENDED that it consist of a single space
        character (0x20) or a dash (-).

        Unfortunately, SDP does not allow the "s=" line to be empty.
        */
        this.add_headers(new tsdp_header_S(tsdp_message.prototype.__s_s_value_default));

        /*	RFC 3264 - 5 Generating the Initial Offer
        The SDP "t=" line conveys the time of the session.  Generally,
        streams for unicast sessions are created and destroyed through
        external signaling means, such as SIP.  In that case, the "t=" line
        SHOULD have a value of "0 0".
        */
        this.add_headers(new tsdp_header_T(0, 0));
    }
}

tsdp_message.prototype.get_media_type = function () {
    // this is a shame because we cannot use '|' to combine the medias
    var b_audio = this.has_media("audio");
    var b_video = this.has_media("video");
    var b_msrp = this.has_media("message");
    
    if (b_audio && b_video) {
        return tmedia_type_e.AUDIO_VIDEO;
    }
    else if (b_audio) {
        return tmedia_type_e.AUDIO;
    }
    else if (b_video) {
        return tmedia_type_e.VIDEO;
    }
    else if (b_msrp) {
        return tmedia_type_e.MSRP;
    }
    return tmedia_type_e.NONE;
}

// add_headers(...)
tsdp_message.prototype.add_headers = function () {
    for (var i = 0; i < arguments.length; ++i) {
        if (arguments[i]) {
            this.ao_headers.push(arguments[i]);
        }
    }
    this.ao_headers.sort(tsdp_header_compare_by_rank);
}

tsdp_message.prototype.add_header = function (o_header) {
    this.add_headers(o_header);
}

tsdp_message.prototype.remove_header = function (e_type) {
    for (var i_index = 0; i_index < this.ao_headers.length; ) {
        if (this.ao_headers[i_index].e_type == e_type) {
            this.ao_headers.splice(i_index, 1);
            continue;
        }
        ++i_index;
    }
}

tsdp_message.prototype.get_header_at = function(e_type, i_index){
    var i_pos = 0;
    for (var i = 0; i < this.ao_headers.length; ++i) {
        if(this.ao_headers[i].e_type == e_type){
            if(i_pos++ >= i_index){
                return this.ao_headers[i];
            }
        }
    }
    return null;
}

tsdp_message.prototype.get_header = function (e_type) {
    return this.get_header_at(e_type, 0);
}

tsdp_message.prototype.get_header_by_name = function (c_name) {
    for (var i = 0; i < this.ao_headers.length; ++i) {
        if (this.ao_headers[i].get_name() == c_name) {
            return c_name;
        }
    }
    return null;
}

tsdp_message.prototype.get_header_a_at = function(s_field, i_index) {
	if(!s_field || i_index < 0){
		tsk_utils_log_error("Invalid argument");
		return null;
	}

	var i_pos = 0;
	for(var i = 0; i < this.ao_headers.length; ++i){
		if(this.ao_headers[i].e_type == tsdp_header_type_e.A && this.ao_headers[i].s_field == s_field){
			if(i_pos++ >= i_index){
				return this.ao_headers[i];
			}
		}
	}
	return null;
}

tsdp_message.prototype.get_header_a = function(s_field) {
	return this.get_header_a_at(s_field, 0);
}

tsdp_message.prototype.add_media = function (s_media, i_port, s_proto) {
    this.add_headers(new tsdp_header_M(s_media, i_port, s_proto));
}

tsdp_message.prototype.remove_media = function (s_media) {
    for (var i = 0; i < this.ao_headers.length; ++i) {
        if (this.ao_headers[i].e_type == tsdp_header_type_e.M) {
            if (this.ao_headers[i].s_media == s_media) {
                this.ao_headers.splice(i, 1);
            }
        }
    }
}

tsdp_message.prototype.get_header_m_by_name = function(s_media){
    if(!s_media){
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    for (var i = 0; i < this.ao_headers.length; ++i) {
        if (this.ao_headers[i].e_type == tsdp_header_type_e.M) {
            if(tsk_string_iequals(this.ao_headers[i].s_media, s_media)){
                return this.ao_headers[i];
            }
        }
    }
    return null;
}

tsdp_message.prototype.has_media = function (s_media) {
    return this.get_header_m_by_name(s_media) != null;
}

/* ================= 3GPP TS 34.610 :: Communication HOLD (HOLD) using IP Multimedia (IM) Core ================*/
tsdp_message.prototype.hold = function(s_media){
	if(!s_media){
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    // 3GPP TS 34.610-900 - 4.5.2.1	Actions at the invoking UE
    var o_hdr_M = this.get_header_m_by_name(s_media);
    if(o_hdr_M){
        o_hdr_M.hold(true);
    }

	return 0;
}

tsdp_message.prototype.resume = function(s_media){
	if(!s_media){
        tsk_utils_log_error("Invalid argument");
        return -1;
    }
	
	// 3GPP TS 34.610-900 - 4.5.2.1	Actions at the invoking UE
    var o_hdr_M = this.get_header_m_by_name(s_media);
    if(o_hdr_M){
        o_hdr_M.resume(true);
    }
    return 0;
}

tsdp_message.prototype.toString = function (s_endline) {
    var s_str = "";
    if (!s_endline) {
        s_endline = "\r\n";
    }
    for (var i = 0; i < this.ao_headers.length; ++i) {
        s_str += this.ao_headers[i].tostring_full(false, s_endline);
    }
    return s_str;
}

if(!window.__b_release_mode){
    tsdp_api_add_js_scripts('head',
    'src/tinySDP/src/tsdp_parser_message.js'
    );
}

/* line 1 "./ragel/tsdp_parser_message.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

/* line 181 "./ragel/tsdp_parser_message.jrl" */


/* Ragel data */

/* line 15 "./src/tsdp_parser_message.js" */
_tsdp_machine_message_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 1, 8, 1, 9, 1, 10, 1, 
	11, 1, 12, 1, 13, 1, 14, 1, 
	15, 1, 16
];

_tsdp_machine_message_key_offsets = [
	0, 0, 2, 5, 6, 8, 11, 13, 
	16, 18, 21, 23, 26, 28, 31, 33, 
	36, 38, 41, 43, 46, 48, 51, 53, 
	56, 58, 61, 63, 66, 68, 71, 73, 
	76, 78, 81
];

_tsdp_machine_message_trans_keys = [
	32, 61, 13, 0, 65535, 10, 32, 61, 
	13, 0, 65535, 32, 61, 13, 0, 65535, 
	32, 61, 13, 0, 65535, 32, 61, 13, 
	0, 65535, 32, 61, 13, 0, 65535, 32, 
	61, 13, 0, 65535, 32, 61, 13, 0, 
	65535, 32, 61, 13, 0, 65535, 32, 61, 
	13, 0, 65535, 32, 61, 13, 0, 65535, 
	32, 61, 13, 0, 65535, 32, 61, 13, 
	0, 65535, 32, 61, 13, 0, 65535, 32, 
	61, 13, 0, 65535, 32, 61, 13, 0, 
	65535, 65, 66, 67, 69, 73, 75, 77, 
	79, 80, 82, 83, 84, 85, 86, 90, 
	97, 98, 99, 101, 105, 107, 109, 111, 
	112, 114, 115, 116, 117, 118, 122, 68, 
	89, 100, 121, 0
];

_tsdp_machine_message_single_lengths = [
	0, 2, 1, 1, 2, 1, 2, 1, 
	2, 1, 2, 1, 2, 1, 2, 1, 
	2, 1, 2, 1, 2, 1, 2, 1, 
	2, 1, 2, 1, 2, 1, 2, 1, 
	2, 1, 30
];

_tsdp_machine_message_range_lengths = [
	0, 0, 1, 0, 0, 1, 0, 1, 
	0, 1, 0, 1, 0, 1, 0, 1, 
	0, 1, 0, 1, 0, 1, 0, 1, 
	0, 1, 0, 1, 0, 1, 0, 1, 
	0, 1, 2
];

_tsdp_machine_message_index_offsets = [
	0, 0, 3, 6, 8, 11, 14, 17, 
	20, 23, 26, 29, 32, 35, 38, 41, 
	44, 47, 50, 53, 56, 59, 62, 65, 
	68, 71, 74, 77, 80, 83, 86, 89, 
	92, 95, 98
];

_tsdp_machine_message_trans_targs = [
	1, 2, 0, 3, 2, 0, 34, 0, 
	4, 5, 0, 3, 5, 0, 6, 7, 
	0, 3, 7, 0, 8, 9, 0, 3, 
	9, 0, 10, 11, 0, 3, 11, 0, 
	12, 13, 0, 3, 13, 0, 14, 15, 
	0, 3, 15, 0, 16, 17, 0, 3, 
	17, 0, 18, 19, 0, 3, 19, 0, 
	20, 21, 0, 3, 21, 0, 22, 23, 
	0, 3, 23, 0, 24, 25, 0, 3, 
	25, 0, 26, 27, 0, 3, 27, 0, 
	28, 29, 0, 3, 29, 0, 30, 31, 
	0, 3, 31, 0, 32, 33, 0, 3, 
	33, 0, 1, 4, 6, 10, 12, 14, 
	16, 18, 20, 22, 24, 26, 28, 30, 
	32, 1, 4, 6, 10, 12, 14, 16, 
	18, 20, 22, 24, 26, 28, 30, 32, 
	8, 8, 0, 0
];

_tsdp_machine_message_trans_actions = [
	0, 0, 0, 3, 0, 0, 0, 0, 
	0, 0, 0, 5, 0, 0, 0, 0, 
	0, 7, 0, 0, 0, 0, 0, 9, 
	0, 0, 0, 0, 0, 11, 0, 0, 
	0, 0, 0, 13, 0, 0, 0, 0, 
	0, 15, 0, 0, 0, 0, 0, 17, 
	0, 0, 0, 0, 0, 19, 0, 0, 
	0, 0, 0, 21, 0, 0, 0, 0, 
	0, 23, 0, 0, 0, 0, 0, 25, 
	0, 0, 0, 0, 0, 27, 0, 0, 
	0, 0, 0, 29, 0, 0, 0, 0, 
	0, 31, 0, 0, 0, 0, 0, 33, 
	0, 0, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 0, 0
];

tsdp_machine_message_start = 34;
tsdp_machine_message_first_final = 34;
tsdp_machine_message_error = 0;

tsdp_machine_message_en_main = 34;


/* line 185 "./ragel/tsdp_parser_message.jrl" */

tsdp_message.prototype.Parse = function(s_str){
	var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var sdp_msg = new tsdp_message();
	var header = null;
	var hdr_T = null;
	var hdr_M = null;
	
	
/* line 136 "./src/tsdp_parser_message.js" */
{
	 cs = tsdp_machine_message_start;
} /* JSCodeGen::writeInit */

/* line 199 "./ragel/tsdp_parser_message.jrl" */
	
/* line 143 "./src/tsdp_parser_message.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsdp_machine_message_key_offsets[cs];
	_trans = _tsdp_machine_message_index_offsets[cs];
	_klen = _tsdp_machine_message_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsdp_machine_message_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsdp_machine_message_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsdp_machine_message_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsdp_machine_message_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsdp_machine_message_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	cs = _tsdp_machine_message_trans_targs[_trans];
	if (_tsdp_machine_message_trans_actions[_trans] != 0) {
		_acts = _tsdp_machine_message_trans_actions[_trans];
		_nacts = _tsdp_machine_message_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsdp_machine_message_actions[_acts - 1]) {
case 0:
/* line 14 "./ragel/tsdp_parser_message.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 21 "./ragel/tsdp_parser_message.jrl" */

		if(hdr_M){
			if((header = tsdp_header_A.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
				hdr_M.ao_hdr_A.push(header);
			}
		}
		else if((header = tsdp_header_A.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 2:
/* line 32 "./ragel/tsdp_parser_message.jrl" */

		if(hdr_M){
			if((header = tsdp_header_B.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
				hdr_M.ao_hdr_B.push(header);
			}
		}
		else if((header = tsdp_header_B.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 3:
/* line 43 "./ragel/tsdp_parser_message.jrl" */

		if(hdr_M && !hdr_M.o_hdr_C){
			hdr_M.o_hdr_C = tsdp_header_C.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start));
		}
		else if((header = tsdp_header_C.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 4:
/* line 52 "./ragel/tsdp_parser_message.jrl" */

		if((header = tsdp_header_Dummy.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			if(hdr_M){
				hdr_M.ao_hdr_Dummy.push(header);
			}
			else{
				sdp_msg.add_header(header);
			}
		}
			break;
case 5:
/* line 63 "./ragel/tsdp_parser_message.jrl" */

		if((header = tsdp_header_E.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 6:
/* line 69 "./ragel/tsdp_parser_message.jrl" */

		if(hdr_M && !hdr_M.o_hdr_I){
			hdr_M.o_hdr_I = tsdp_header_I.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start));
		}
		else if((header = tsdp_header_I.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 7:
/* line 78 "./ragel/tsdp_parser_message.jrl" */

		if(hdr_M && !hdr_M.o_hdr_K){
			hdr_M.o_hdr_K = tsdp_header_K.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start));
		}
		else if((header = tsdp_header_K.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 8:
/* line 87 "./ragel/tsdp_parser_message.jrl" */

		if((hdr_M = tsdp_header_M.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(hdr_M);
		}
			break;
case 9:
/* line 93 "./ragel/tsdp_parser_message.jrl" */

		if((header = tsdp_header_O.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 10:
/* line 99 "./ragel/tsdp_parser_message.jrl" */

		if((header = tsdp_header_P.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 11:
/* line 105 "./ragel/tsdp_parser_message.jrl" */

		if((header = tsdp_header_R.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			if(hdr_T){
				hdr_T.ao_hdr_R.push(header);
			}
			else{
				sdp_msg.add_header(header);
			}
		}
			break;
case 12:
/* line 116 "./ragel/tsdp_parser_message.jrl" */

		if((header = tsdp_header_S.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 13:
/* line 122 "./ragel/tsdp_parser_message.jrl" */

		if((hdr_T = tsdp_header_T.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(hdr_T);
			hdr_T = null;
		}
			break;
case 14:
/* line 129 "./ragel/tsdp_parser_message.jrl" */

		if((header = tsdp_header_U.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 15:
/* line 135 "./ragel/tsdp_parser_message.jrl" */

		if((header = tsdp_header_V.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
case 16:
/* line 141 "./ragel/tsdp_parser_message.jrl" */

		if((header = tsdp_header_Z.prototype.Parse(tsk_ragel_parser_get_string(s_str, p, i_tag_start)))){
			sdp_msg.add_header(header);
		}
			break;
/* line 373 "./src/tsdp_parser_message.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 200 "./ragel/tsdp_parser_message.jrl" */
	
	if( cs < 
/* line 403 "./src/tsdp_parser_message.js" */
34
/* line 201 "./ragel/tsdp_parser_message.jrl" */
 ){
		tsk_utils_log_error("Failed to parse sdp message: " + s_str);
		return null;
	}
	
	return sdp_msg;
}


/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
// /!\ never use
var tsip_action_type_common_e =
{
    ACCEPT: 1000, //! Accept incoming call (INVITE) or message (SIP MESSAGE)
	CANCEL: 1001, //! Cancel an outgoing request
	HANGUP: 1002, //! Hangup any SIP dialog (BYE, unREGISTER, unSUBSCRIBE ...). If the dialog is in early state, then it will be canceled
    REJECT: 1002, //! Reject incoming call (INVITE) or message (SIP MESSAGE)
    SHUTDOWN: 1003 //! Shutdown a SIP dialog. Should only be called by the stack
}; 

var tsip_action_type_e =
{
    NONE: -1,
    
    CONFIG: 0,
    DTMF_SEND: 1,

    /* === REGISTER == */
    REGISTER: 10, /**< Sends SIP REGISTER request */
    UNREGISTER: tsip_action_type_common_e.HANGUP, //! UnRegister by sending SIP REGISTER request with expires value equals to zero

    /* === SUBSCRIBE === */
    SUBSCRIBE: 20, /**< Sends SIP SUBSCRIBE request */
    UNSUBSCRIBE: tsip_action_type_common_e.HANGUP, //! Unsubsribe by sending SIP SUBSCRIBE request with expires value equals to zero

    /* === MESSAGE === */
    MESSAGE: 30, /**< Sends SIP MESSAGE request */

    /* === INFO === */
    INFO: 40,  /**< Sends SIP INFO request */

    /* === PUBLISH === */
    PUBLISH: 50, /**< Sends SIP PUBLISH request */
    UNPUBLISH: tsip_action_type_common_e.HANGUP,//! Unpublish by sending SIP PUBLISH request with expires value equals to zero

    /* === OPTIONS === */
    OPTIONS: 60, /**< Sends SIP OPTIONS request */

    /* === INVITE === */
    INVITE: 70, /**< Sends SIP INVITE/reINVITE request */
	HOLD: 71, /**< Puts the session on hold state */
	RESUME: 72, /**< Resumes a previously held session */
	ECT: 73, /**< Transfer the call */
	ECT_ACCEPT: 74, /**< Accept call transfer request */
	ECT_REJECT: 75, /**< Reject call transfer request */
	ECT_NOTIFY: 76, /**< Intra-Dialog notify. Never called by the end-user */
	LARGE_MESSAGE: 77, /**< Large message (MSRP). The session must be connected */


    /* === COMMON == */
    ACCEPT: tsip_action_type_common_e.ACCEPT,
    CANCEL: tsip_action_type_common_e.CANCEL,
    HANGUP: tsip_action_type_common_e.HANGUP,
    REJECT: tsip_action_type_common_e.REJECT,
    SHUTDOWN: tsip_action_type_common_e.SHUTDOWN
};

function tsip_action(e_type) {
    this.e_type = e_type;
    this.ao_headers = new Array();
    this.o_content = null;

    this.line_resp = {};
    this.line_resp.i_code = 0;
    this.line_resp.s_phrase = null;

    this.media = {};
    this.media.e_type = tmedia_type_e.NONE;
    this.media.ao_params = new Array();

    this.dtmf = {};
    this.dtmf.i_volume = -1;
    this.dtmf.i_event = -1;

    this.ect = {};
    this.ect.s_to = null;
}

tsip_action.prototype.set_line_resp = function (i_code, s_phrase) {
    this.line_resp.i_code = i_code;
    this.line_resp.s_phrase = s_phrase;
}

tsip_action.prototype.set_content = function (o_content) {
    this.o_content = o_content;
}

tsip_action.prototype.get_content = function () {
    return this.o_content;
}

// add_headers(...)
tsip_action.prototype.add_headers = function () {
    for (var i = 0; i < arguments.length; ++i) {
        if (arguments[i]) {
            this.ao_headers.push(arguments[i]);
        }
    }
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var tsip_event_type_e =
{
    NONE: -1,

    INVITE: 0,
    MESSAGE: 1,
    INFO: 2,
    OPTIONS: 3,
    PUBLISH: 4,
    REGISTER: 5,
    SUBSCRIBE: 6,

    DIALOG: 20,
    STACK: 21
};

var tsip_event_code_e = 
{
    // 100-699 are SIP reserved codes

    // 7xx ==> errors
    DIALOG_TRANSPORT_ERROR: 702,
    DIALOG_GLOBAL_ERROR: 703,
    DIALOG_MESSAGE_ERROR: 704,
    DIALOG_WEBRTC_ERROR: 705,

    // 8xx ==> success
    DIALOG_REQUEST_INCOMING: 800,
    DIALOG_REQUEST_OUTGOING: 802,
    DIALOG_REQUEST_CANCELLED: 803,
    DIALOG_REQUEST_SENT: 804,
    DIALOG_MEDIA_ADDED: 805,
    DIALOG_MEDIA_REMOVED: 806,
    DIALOG_MEDIA_LOCAL_REQUESTED: 807,
    DIALOG_MEDIA_LOCAL_ACCEPTED: 808,
    DIALOG_MEDIA_LOCAL_REFUSED: 809,

    // 9xx ==> Informational
    DIALOG_CONNECTING: 900,
    DIALOG_CONNECTED: 901,
    DIALOG_TERMINATING: 902,
    DIALOG_TERMINATED: 903,
    STACK_STARTING: 950,
    STACK_STARTED: 951,
    STACK_STOPPING: 952,
    STACK_STOPPED: 953,
    STACK_FAILED_TO_START: 954,
    STACK_FAILED_TO_STOP: 955
};

function tsip_event(o_session, i_code, s_phrase, o_message, e_type) {
    this.init(o_session, i_code, s_phrase, o_message, e_type);  
}

tsip_event.prototype.init = function (o_session, i_code, s_phrase, o_message, e_type) {
    this.o_session = o_session;
    this.o_usr_data = null;
    this.i_code = i_code;
    this.s_phrase = s_phrase;
    this.o_message = o_message;
    this.e_type = e_type;
    return 0;
}

tsip_event.prototype.get_session = function () {
    return this.o_session;
}

tsip_event.prototype.get_message = function () {
    return this.o_message;
}

tsip_event.prototype.get_code = function () {
    return this.i_code;
}

tsip_event.prototype.get_phrase = function () {
    return this.s_phrase;
}

tsip_event.prototype.set_usr_data = function (o_usr_data) {
    this.o_usr_data = o_usr_data;
}

tsip_event.prototype.is_type_session = function () {
    switch (this.e_type) {
        case tsip_event_type_e.INVITE:
        case tsip_event_type_e.MESSAGE:
        case tsip_event_type_e.INFO:
        case tsip_event_type_e.OPTIONS:
        case tsip_event_type_e.PUBLISH:
        case tsip_event_type_e.REGISTER:
        case tsip_event_type_e.SUBSCRIBE:
        case tsip_event_type_e.DIALOG:
            {
                return true;
            }
    }
    return false;
};

tsip_event.prototype.is_type_stack = function () {
    return (this.e_type == tsip_event_type_e.STACK);
};

// o_message: optional
tsip_event.prototype.signal = function () {
    var This = this;
    if (this.o_session.on_event && this.is_type_session()) {
        setTimeout(function () { This.o_session.on_event(This) }, 1);
    }
    
    switch (this.e_type) {
        case tsip_event_type_e.DIALOG:
            {
                if (This.o_session.o_stack.on_event_dialog) {
                    setTimeout(function () { This.o_session.o_stack.on_event_dialog(This) }, 1);
                }
                break;
            }
        case tsip_event_type_e.STACK:
            {
                if (This.o_session.o_stack.on_event_stack) {
                    setTimeout(function () { This.o_session.o_stack.on_event_stack(This) }, 1);
                }
            }
        case tsip_event_type_e.INVITE:
            {
                if (This.o_session.o_stack.on_event_invite) {
                    setTimeout(function () { This.o_session.o_stack.on_event_invite(This) }, 1);
                }
                break;
            }
        case tsip_event_type_e.MESSAGE:
            {
                if (This.o_session.o_stack.on_event_message) {
                    setTimeout(function () { This.o_session.o_stack.on_event_message(This) }, 1);
                }
                break;
            }
        case tsip_event_type_e.PUBLISH:
            {
                if (This.o_session.o_stack.on_event_publish) {
                    setTimeout(function () { This.o_session.o_stack.on_event_publish(This) }, 1);
                }
                break;
            }
        case tsip_event_type_e.SUBSCRIBE:
            {
                if (This.o_session.o_stack.on_event_subscribe) {
                    setTimeout(function () { This.o_session.o_stack.on_event_subscribe(This) }, 1);
                }
                break;
            }
    }


    return 0;
}

tsip_event.prototype.Signal = function(e_type, o_session, i_code, s_phrase, o_message) {
    if (!o_session || !o_session.o_stack) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }
    var o_event = new tsip_event(o_session, i_code, s_phrase, o_message, e_type);
    return o_event.signal();
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_response.prototype = Object.create(tsip_message.prototype);
tsip_request.prototype = Object.create(tsip_message.prototype);

tsip_message.prototype.__s_version_10 = "SIP/1.0";
tsip_message.prototype.__s_version_20 = "SIP/2.0";
tsip_message.prototype.__s_version_default = tsip_message.prototype.__s_version_20;

var tsip_message_type_e =
{
    UNKNOWN: 0, 
    REQUEST: 1,
    RESPONSE: 2
};

var tsip_request_type_e =
{
    NONE: { i_id: -1, s_name: "NONE" },

    ACK: { i_id: 0, s_name: "ACK" },
    BYE: { i_id: 1, s_name: "BYE" },
    CANCEL: { i_id: 2, s_name: "CANCEL" },
    INVITE: { i_id: 3, s_name: "INVITE" },
    OPTIONS: { i_id: 4, s_name: "OPTIONS" },
    REGISTER: { i_id: 5, s_name: "REGISTER" },
    SUBSCRIBE: { i_id: 6, s_name: "SUBSCRIBE" },
    NOTIFY: { i_id: 7, s_name: "NOTIFY" },
    REFER: { i_id: 8, s_name: "REFER" },
    INFO: { i_id: 9, s_name: "INFO" },
    UPDATE: { i_id: 10, s_name: "UPDATE" },
    MESSAGE: { i_id: 11, s_name: "MESSAGE" },
    PUBLISH: { i_id: 12, s_name: "PUBLISH" },
    PRACK: { i_id: 13, s_name: "PRACK" }
};


function tsip_message(e_type) {
    this.s_version = tsip_message.prototype.__s_version_default; // The SIP version. Only 'SIP/2.0' is supported
    this.e_type = e_type;

    // Request-Line / Response-Line
    this.line = {
        request: {}, // s_method, o_uri
        response: {} // i_status_code, s_reason_phrase
    };

    // Most common headers
    this.o_hdr_firstVia = null;
    this.o_hdr_From = null;
    this.o_hdr_To = null;
    this.o_hdr_Contact = null;
    this.o_hdr_Call_ID = null;
    this.o_hdr_CSeq = null;
    this.o_hdr_Expires = null;

    this.o_hdr_Content_Type = null;
    this.o_hdr_Content_Length = null;

    this.o_content = null;

    // Other headers
    this.ao_headers = new Array();

    // To hack the message
    this.s_sigcomp_id = null;
    this.o_socket = null;
    this.o_remote_addr = null;
    this.b_update = false;
}

function tsip_response(i_status_code, s_reason_phrase, o_request) {
    if(!s_reason_phrase || !o_request){
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    tsip_message.call(this, tsip_message_type_e.RESPONSE);
	this.line.response.i_status_code = i_status_code;
	this.line.response.s_reason_phrase = s_reason_phrase; 
				
	/* Copy network information */
	this.o_socket = o_request.o_socket;
	this.o_remote_addr = o_request.o_remote_addr;

	/*
	RFC 3261 - 8.2.6.2 Headers and Tags

	The From field of the response MUST equal the From header field of
	the request.  The Call-ID header field of the response MUST equal the
	Call-ID header field of the request.  The CSeq header field of the
	response MUST equal the CSeq field of the request.  The Via header
	field values in the response MUST equal the Via header field values
	in the request and MUST maintain the same ordering.

	If a request contained a To tag in the request, the To header field
	in the response MUST equal that of the request.  However, if the To
	header field in the request did not contain a tag, the URI in the To
	header field in the response MUST equal the URI in the To header
	field; additionally, the UAS MUST add a tag to the To header field in
	the response (with the exception of the 100 (Trying) response, in
	which a tag MAY be present).  This serves to identify the UAS that is
	responding, possibly resulting in a component of a dialog ID.  The
	same tag MUST be used for all responses to that request, both final
	and provisional (again excepting the 100 (Trying)).  Procedures for
	the generation of tags are defined in Section 19.3.
	*/
	this.o_hdr_From = o_request.o_hdr_From;
	this.o_hdr_Call_ID = o_request.o_hdr_Call_ID;
	this.o_hdr_CSeq = o_request.o_hdr_CSeq;
	this.o_hdr_firstVia = o_request.o_hdr_firstVia;
	/* All other VIAs */
	if(this.o_hdr_firstVia){
		var i_index = 1;
		var o_hdr_via;
		while ((o_hdr_via = o_request.get_header_at(tsip_header_type_e.Via, i_index++))) {
			this.add_header(o_hdr_via);
		}
	}
	/* Record routes */
	{
		var i_index = 0;
		var o_hdr_record_route;
		while((o_hdr_record_route = o_request.get_header_at(tsip_header_type_e.Record_Route, i_index++))){
			this.add_header(o_hdr_record_route);
		}
	}
	this.o_hdr_To = o_request.o_hdr_To;
	this.add_header(new tsip_header_Content_Length(0));
}

function tsip_request(s_method, o_uri_request, o_uri_from, o_uri_to, s_call_id, i_cseq){
    if(!s_method || !o_uri_request || !s_call_id){
        tsk_utils_log_error("Invalid argument");
        return null;
    }

    tsip_message.call(this, tsip_message_type_e.REQUEST);
    this.line.request.s_method = s_method;
    this.line.request.o_uri = o_uri_request;
    this.line.request.e_type = tsip_message.prototype.GetRequestType(s_method);

	/* RFC 3261 8.1.1 Generating the Request
		A valid SIP request formulated by a UAC MUST, at a minimum, contain
		the following header fields: To, From, CSeq, Call-ID, Max-Forwards,
		and Via; all of these header fields are mandatory in all SIP
		requests.  These six header fields are the fundamental building
		blocks of a SIP message, as they jointly provide for most of the
		critical message routing services including the addressing of
		messages, the routing of responses, limiting message propagation,
		ordering of messages, and the unique identification of transactions.
		These header fields are in addition to the mandatory request line,
		which contains the method, Request-URI, and SIP version.
	*/
    this.add_headers( 
        new tsip_header_CSeq(i_cseq, s_method),
        new tsip_header_Call_ID(s_call_id),
        new tsip_header_Max_Forwards(TSIP_HEADER_MAX_FORWARDS_DEFAULT),
        /* Via will be added by the transport layer */
		new tsip_header_Content_Length(0));
    if (o_uri_to) {
        this.add_headers(new tsip_header_To(o_uri_to, null));
    }
    if (o_uri_from) {
        this.add_headers(new tsip_header_From(o_uri_from, null));
    }
}

// b_top: optional
tsip_message.prototype.add_header = function (o_hdr, b_top) {
    if (!o_hdr) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    switch (o_hdr.e_type) {
        case tsip_header_type_e.Via:
            {
                if (!this.o_hdr_firstVia) {
                    this.o_hdr_firstVia = o_hdr;
                    return 0;
                }
                break;
            }
        case tsip_header_type_e.From:
            {
                if (!this.o_hdr_From) {
                    this.o_hdr_From = o_hdr;
                    return 0;
                }
                break;
            }
        case tsip_header_type_e.To:
            {
                if (!this.o_hdr_To) {
                    this.o_hdr_To = o_hdr;
                    return 0;
                }
                break;
            }
        case tsip_header_type_e.Contact:
            {
                if (!this.o_hdr_Contact) {
                    this.o_hdr_Contact = o_hdr;
                    return 0;
                }
                break;
            }
        case tsip_header_type_e.Call_ID:
            {
                if (!this.o_hdr_Call_ID) {
                    this.o_hdr_Call_ID = o_hdr;
                    return 0;
                }
                break;
            }
        case tsip_header_type_e.CSeq:
            {
                if (!this.o_hdr_CSeq) {
                    this.o_hdr_CSeq = o_hdr;
                    return 0;
                }
                break;
            }
        case tsip_header_type_e.Expires:
            {
                if (!this.o_hdr_Expires) {
                    this.o_hdr_Expires = o_hdr;
                    return 0;
                }
                break;
            }
        case tsip_header_type_e.Content_Type:
            {
                if (!this.o_hdr_Content_Type) {
                    this.o_hdr_Content_Type = o_hdr;
                    return 0;
                }
                break;
            }
        case tsip_header_type_e.Content_Length:
            {
                if (!this.o_hdr_Content_Length) {
                    this.o_hdr_Content_Length = o_hdr;
                    return 0;
                }
                break;
            }
    }

    if (b_top) {
        this.ao_headers.unshift(o_hdr);
    }
    else {
        this.ao_headers.push(o_hdr);
    }

    return 0;
}

// add_headers(...);
tsip_message.prototype.add_headers = function() {
    for (var i = 0; i < arguments.length; ++i) {
        if (arguments[i]) {
            this.add_header(arguments[i]);
        }
    }
    return 0;
}

tsip_message.prototype.get_header_at = function (e_hdr_type, i_index) {
    var i_pos = 0;

    switch (e_hdr_type) {
        case tsip_header_type_e.Via:
            {
                if (i_index == 0) {
                    return this.o_hdr_firstVia;
                }
                ++i_pos;
                break;
            }
        case tsip_header_type_e.From:
            {
                if (i_index == 0) {
                    return this.o_hdr_From;
                }
                ++i_pos;
                break;
            }
        case tsip_header_type_e.To:
            {
                if (i_index == 0) {
                    return this.o_hdr_To;
                }
                ++i_pos;
                break;
            }
        case tsip_header_type_e.Contact:
            {
                if (i_index == 0) {
                    return this.o_hdr_Contact;
                }
                ++i_pos;
                break;
            }
        case tsip_header_type_e.Call_ID:
            {
                if (i_index == 0) {
                    return this.o_hdr_Call_ID;
                }
                ++i_pos;
                break;
            }
        case tsip_header_type_e.CSeq:
            {
                if (i_index == 0) {
                    return this.o_hdr_CSeq;
                }
                ++i_pos;
                break;
            }
        case tsip_header_type_e.Expires:
            {
                if (i_index == 0) {
                    return this.o_hdr_Expires;
                }
                ++i_pos;
                break;
            }
        case tsip_header_type_e.Content_Type:
            {
                if (i_index == 0) {
                    return this.o_hdr_Content_Type;
                }
                ++i_pos;
                break;
            }
        case tsip_header_type_e.Content_Length:
            {
                if (i_index == 0) {
                    return this.o_hdr_Content_Length;
                }
                ++i_pos;
                break;
            }
    }

    for (var i = 0; i < this.ao_headers.length; ++i) {
        if (this.ao_headers[i].e_type == e_hdr_type) {
            if (i_pos++ >= i_index) {
                return this.ao_headers[i];
            }
        }
    }

    return null;
}

tsip_message.prototype.get_header = function (e_hdr_type) {
    return this.get_header_at(e_hdr_type, 0);
}

tsip_message.prototype.get_response_code = function(){
    return this.is_response() ? this.line.response.i_status_code : 0;
}

tsip_message.prototype.get_response_phrase = function () {
    return this.is_response() ? this.line.response.s_reason_phrase : null;
}

tsip_message.prototype.is_allowed = function (s_method) {
    if (!s_method) {
        tsk_utils_log_error("Invalid argument");
        return false;
    }

    var o_hdr_allow;
    var i_index = 0;

    while ((o_hdr_allow = this.get_header_at(tsip_header_type_e.Allow, i_index++))) {
        if (o_hdr_allow.has_value(s_method)) {
            return true;
        }
    }
    return false;
}

tsip_message.prototype.is_supported = function (s_option) {
    if (!s_option) {
        tsk_utils_log_error("Invalid argument");
        return false;
    }

    var o_hdr_supported;
    var i_index = 0;

    while ((o_hdr_supported = this.get_header_at(tsip_header_type_e.Supported, i_index++))) {
        if (o_hdr_supported.has_value(s_option)) {
            return true;
        }
    }
    return false;
}

tsip_message.prototype.is_required = function (s_option) {
    if (!s_option) {
        tsk_utils_log_error("Invalid argument");
        return false;
    }

    var o_hdr_require;
    var i_index = 0;

    while ((o_hdr_require = this.get_header_at(tsip_header_type_e.Require, i_index++))) {
        if (o_hdr_require.has_value(s_option)) {
            return true;
        }
    }
    return false;
}

tsip_message.prototype.get_expires = function () {
    if (this.o_hdr_Expires) {
        return this.o_hdr_Expires.i_value;
    }
    if (this.o_hdr_Contact) {
        return this.o_hdr_Contact.i_expires;
    }
    return -1;
}

tsip_message.prototype.has_content = function () {
    return this.get_content_length() > 0 && this.o_content;
}

tsip_message.prototype.get_content_length = function () {
    return this.o_hdr_Content_Length ? this.o_hdr_Content_Length.i_value : 0;
}

tsip_message.prototype.get_content_type = function () {
    return (this.o_hdr_Content_Type) ? this.o_hdr_Content_Type.s_type : null;
}

tsip_message.prototype.get_content = function () {
    return this.o_content;
}

tsip_message.prototype.get_content_as_string = function () {
    if (this.o_content) {
        /*if (this.o_content instanceof String) {
            this.o_content;
        }
        else */if (this.o_content instanceof Array) {
            return tsk_buff_u8b2utf8(this.o_content);
        }
    }
    return this.o_content ? this.o_content.toString() : null;
}

// s_content_type is optional
// i_length is optional
tsip_message.prototype.add_content = function (o_content, s_content_type, i_length) {
    if (s_content_type) {
        this.o_hdr_Content_Type = new tsip_header_Content_Type(s_content_type);
    }

    if (o_content && typeof i_length == "undefined") {
        if (o_content instanceof String || typeof o_content == "string") {
            i_length = unescape(encodeURIComponent(o_content)).length;
        }
        else if (o_content.byteLength) {
            i_length = o_content.byteLength;
        }
        else if (o_content.length) {
            i_length = o_content.length;
        }
        else {
            tsk_utils_log_error("cannot stat content-length");
            i_length = 0;
        }
    }


    this.o_hdr_Content_Length = new tsip_header_Content_Length(i_length);
    this.o_content = o_content;
}

tsip_message.prototype.toString = function () {
    var s_str = null;

    if (this.e_type == tsip_message_type_e.REQUEST) {
        s_str = tsk_string_format("{0} {1} {2}\r\n",
                    this.line.request.s_method, tsip_uri_tostring(this.line.request.o_uri, true, false), this.s_version);
    }
    else {
        s_str = tsk_string_format("{0} {1} {2}\r\n", this.s_version, this.line.response.i_status_code, this.line.response.s_reason_phrase);
    }

    /* First Via */
    if (this.o_hdr_firstVia) {
        s_str += this.o_hdr_firstVia.tostring_full();
    }
    /* From */
    if (this.o_hdr_From) {
        s_str += this.o_hdr_From.tostring_full();
    }
    /* To */
    if (this.o_hdr_To) {
        s_str += this.o_hdr_To.tostring_full();
    }
    /* Contact */
    if (this.o_hdr_Contact) {
        s_str += this.o_hdr_Contact.tostring_full();
    }
    /* Call_id */
    if (this.o_hdr_Call_ID) {
        s_str += this.o_hdr_Call_ID.tostring_full();
    }
    /* CSeq */
    if (this.o_hdr_CSeq) {
        s_str += this.o_hdr_CSeq.tostring_full();
    }
    /* Expires */
    if (this.o_hdr_Expires) {
        s_str += this.o_hdr_Expires.tostring_full();
    }
    /* Content-Type */
    if (this.o_hdr_Content_Type) {
        s_str += this.o_hdr_Content_Type.tostring_full();
    }
    /* Content-Length*/
    if (this.o_hdr_Content_Length) {
        s_str += this.o_hdr_Content_Length.tostring_full();
    }

    /* All other headers */
    for (var i = 0; i < this.ao_headers.length; ++i) {
        s_str += this.ao_headers[i].tostring_full();
    }

    /* EMPTY LINE */
    s_str += "\r\n";

    /* CONTENT */
    if (this.has_content()) {
        s_str += this.get_content_as_string();
    }

    return s_str;
}

tsip_message.prototype.is_request = function () {
    return this.e_type == tsip_message_type_e.REQUEST;
}

tsip_message.prototype.is_response = function () {
    return this.e_type == tsip_message_type_e.RESPONSE;
}

tsip_message.prototype.is_req_type = function (e_type) {
    return this.is_request() && this.line.request.e_type == e_type;
};
tsip_message.prototype.is_ack = function () { return this.is_req_type(tsip_request_type_e.ACK); }
tsip_message.prototype.is_bye = function () { return this.is_req_type(tsip_request_type_e.BYE); }
tsip_message.prototype.is_cancel = function () { return this.is_req_type(tsip_request_type_e.CANCEL); }
tsip_message.prototype.is_invite = function () { return this.is_req_type(tsip_request_type_e.INVITE); }
tsip_message.prototype.is_options = function () { return this.is_req_type(tsip_request_type_e.OPTIONS); }
tsip_message.prototype.is_register = function () { return this.is_req_type(tsip_request_type_e.REGISTER); }
tsip_message.prototype.is_subscribe = function () { return this.is_req_type(tsip_request_type_e.SUBSCRIBE); }
tsip_message.prototype.is_notify = function () { return this.is_req_type(tsip_request_type_e.NOTIFY); }
tsip_message.prototype.is_update = function () { return this.is_req_type(tsip_request_type_e.UPDATE); }
tsip_message.prototype.is_message = function () { return this.is_req_type(tsip_request_type_e.MESSAGE); }
tsip_message.prototype.is_publish = function () { return this.is_req_type(tsip_request_type_e.PUBLISH); }
tsip_message.prototype.is_prack = function () { return this.is_req_type(tsip_request_type_e.PRACK); }
tsip_message.prototype.is_refer = function () { return this.is_req_type(tsip_request_type_e.REFER); }
tsip_message.prototype.is_info = function () { return this.is_req_type(tsip_request_type_e.INFO); }

tsip_message.prototype.is_response_to = function (e_req_type) {
     return this.is_response() && this.o_hdr_CSeq && this.o_hdr_CSeq.e_req_type == e_req_type;
};
tsip_message.prototype.is_response_to_ack = function () { return this.is_response_to(tsip_request_type_e.ACK); }
tsip_message.prototype.is_response_to_bye = function () { return this.is_response_to(tsip_request_type_e.BYE); }
tsip_message.prototype.is_response_to_cancel = function () { return this.is_response_to(tsip_request_type_e.CANCEL); }
tsip_message.prototype.is_response_to_invite = function () { return this.is_response_to(tsip_request_type_e.INVITE); }
tsip_message.prototype.is_response_to_options = function () { return this.is_response_to(tsip_request_type_e.OPTIONS); }
tsip_message.prototype.is_response_to_register = function () { return this.is_response_to(tsip_request_type_e.REGISTER); }
tsip_message.prototype.is_response_to_subscribe = function () { return this.is_response_to(tsip_request_type_e.SUBSCRIBE); }
tsip_message.prototype.is_response_to_notify = function () { return this.is_response_to(tsip_request_type_e.NOTIFY); }
tsip_message.prototype.is_response_to_update = function () { return this.is_response_to(tsip_request_type_e.UPDATE); }
tsip_message.prototype.is_response_to_message = function () { return this.is_response_to(tsip_request_type_e.MESSAGE); }
tsip_message.prototype.is_response_to_publish = function () { return this.is_response_to(tsip_request_type_e.PUBLISH); }
tsip_message.prototype.is_response_to_prack = function () { return this.is_response_to(tsip_request_type_e.PRACK); }
tsip_message.prototype.is_response_to_refer = function () { return this.is_response_to(tsip_request_type_e.REFER); }
tsip_message.prototype.is_response_to_info = function () { return this.is_response_to(tsip_request_type_e.INFO); }

tsip_message.prototype.is_response_nxx = function (i_n) {
    return this.is_response() && ((i_n * 100) <= this.get_response_code() && this.get_response_code() <= ((i_n * 100) + 99));
}
tsip_message.prototype.is_response_xxx = function (i_xxx) {
    return this.is_response() && (this.get_response_code() == i_xxx);
}
tsip_message.prototype.is_1xx = function () { return this.is_response_nxx(1); }
tsip_message.prototype.is_2xx = function () { return this.is_response_nxx(2); }
tsip_message.prototype.is_3xx = function () { return this.is_response_nxx(3); }
tsip_message.prototype.is_4xx = function () { return this.is_response_nxx(4); }
tsip_message.prototype.is_5xx = function () { return this.is_response_nxx(5); }
tsip_message.prototype.is_6xx = function () { return this.is_response_nxx(6); }
tsip_message.prototype.is_23456 = function () {
    return this.is_response() && (200 <= this.get_response_code() && this.get_response_code() <= 699);
}
tsip_message.prototype.is_3456 = function () {
    return this.is_response() && (300 <= this.get_response_code() && this.get_response_code() <= 699);
}

tsip_message.prototype.GetRequestType = function(s_method) {
    if (s_method) {
        var s_method_i = s_method.toUpperCase();
        if ((s_method_i == tsip_request_type_e.ACK.s_name)) {
            return tsip_request_type_e.ACK;
        } else if ((s_method_i == tsip_request_type_e.BYE.s_name)) {
            return tsip_request_type_e.BYE;
        } else if ((s_method_i == tsip_request_type_e.CANCEL.s_name)) {
            return tsip_request_type_e.CANCEL;
        } else if ((s_method_i == tsip_request_type_e.INVITE.s_name)) {
            return tsip_request_type_e.INVITE;
        } else if ((s_method_i == tsip_request_type_e.OPTIONS.s_name)) {
            return tsip_request_type_e.OPTIONS;
        } else if ((s_method_i == tsip_request_type_e.REGISTER.s_name)) {
            return tsip_request_type_e.REGISTER;
        } else if ((s_method_i == tsip_request_type_e.SUBSCRIBE.s_name)) {
            return tsip_request_type_e.SUBSCRIBE;
        } else if ((s_method_i == tsip_request_type_e.NOTIFY.s_name)) {
            return tsip_request_type_e.NOTIFY;
        } else if ((s_method_i == tsip_request_type_e.REFER.s_name)) {
            return tsip_request_type_e.REFER;
        } else if ((s_method_i == tsip_request_type_e.INFO.s_name)) {
            return tsip_request_type_e.INFO;
        } else if ((s_method_i == tsip_request_type_e.UPDATE.s_name)) {
            return tsip_request_type_e.UPDATE;
        } else if ((s_method_i == tsip_request_type_e.MESSAGE.s_name)) {
            return tsip_request_type_e.MESSAGE;
        } else if ((s_method_i == tsip_request_type_e.PUBLISH.s_name)) {
            return tsip_request_type_e.PUBLISH;
        } else if ((s_method_i == tsip_request_type_e.PRACK.s_name)) {
            return tsip_request_type_e.PRACK;
        }
    }
    return tsip_request_type_e.NONE;
}

if(!window.__b_release_mode){
    tsip_api_add_js_scripts('head',
    'src/tinySIP/src/parsers/tsip_parser_message.js'
    );
}

/* line 1 "./ragel/tsip_parser_message.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
function prev_not_comma(o_ragel_state, i_p){
	return (o_ragel_state.i_pe <= i_p) || (o_ragel_state.o_data[i_p - 1] != ',');
}


/* line 96 "./ragel/tsip_parser_message.jrl" */



/* line 18 "./src/parsers/tsip_parser_message.js" */
_tsip_machine_parser_message_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 2, 0, 5, 2, 6, 0
];

_tsip_machine_parser_message_key_offsets = [
	0, 0, 16, 31, 35, 47, 50, 52, 
	55, 57, 59, 61, 62, 64, 67, 69, 
	72, 73, 88, 89, 106, 109, 114, 117, 
	121, 142, 146, 147, 149, 166, 183, 197, 
	199, 202, 204, 207, 209, 211, 213, 214, 
	230, 246, 252, 258, 260, 281, 284, 288
];

_tsip_machine_parser_message_trans_keys = [
	33, 37, 39, 83, 115, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	32, 33, 37, 39, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 65, 
	90, 97, 122, 9, 32, 43, 58, 45, 
	46, 48, 57, 65, 90, 97, 122, 9, 
	32, 58, 0, 65535, 32, 0, 65535, 83, 
	115, 73, 105, 80, 112, 47, 48, 57, 
	46, 48, 57, 48, 57, 13, 48, 57, 
	10, 13, 33, 37, 39, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	10, 9, 32, 33, 37, 39, 58, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 58, 9, 13, 32, 
	0, 65535, 13, 0, 65535, 10, 13, 0, 
	65535, 13, 33, 37, 39, 44, 47, 126, 
	0, 41, 42, 57, 58, 64, 65, 90, 
	91, 94, 95, 122, 123, 65535, 10, 13, 
	0, 65535, 10, 9, 32, 32, 33, 37, 
	39, 73, 105, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 32, 33, 
	37, 39, 80, 112, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 32, 
	33, 37, 39, 47, 126, 42, 43, 45, 
	57, 65, 90, 95, 122, 48, 57, 46, 
	48, 57, 48, 57, 32, 48, 57, 48, 
	57, 48, 57, 48, 57, 32, 9, 13, 
	37, 61, 95, 126, 32, 33, 36, 59, 
	63, 90, 97, 122, 128, 255, 9, 13, 
	37, 61, 95, 126, 32, 33, 36, 59, 
	63, 90, 97, 122, 128, 255, 48, 57, 
	65, 70, 97, 102, 48, 57, 65, 70, 
	97, 102, 0, 65535, 13, 33, 37, 39, 
	44, 47, 126, 0, 41, 42, 57, 58, 
	64, 65, 90, 91, 94, 95, 122, 123, 
	65535, 13, 0, 65535, 10, 13, 0, 65535, 
	10, 13, 0, 65535, 0
];

_tsip_machine_parser_message_single_lengths = [
	0, 6, 5, 0, 4, 3, 0, 1, 
	2, 2, 2, 1, 0, 1, 0, 1, 
	1, 5, 1, 7, 3, 3, 1, 2, 
	7, 2, 1, 2, 7, 7, 6, 0, 
	1, 0, 1, 0, 0, 0, 1, 6, 
	6, 0, 0, 0, 7, 1, 2, 2
];

_tsip_machine_parser_message_range_lengths = [
	0, 5, 5, 2, 4, 0, 1, 1, 
	0, 0, 0, 0, 1, 1, 1, 1, 
	0, 5, 0, 5, 0, 1, 1, 1, 
	7, 1, 0, 0, 5, 5, 4, 1, 
	1, 1, 1, 1, 1, 1, 0, 5, 
	5, 3, 3, 1, 7, 1, 1, 1
];

_tsip_machine_parser_message_index_offsets = [
	0, 0, 12, 23, 26, 35, 39, 41, 
	44, 47, 50, 53, 55, 57, 60, 62, 
	65, 67, 78, 80, 93, 97, 102, 105, 
	109, 124, 128, 130, 133, 146, 159, 170, 
	172, 175, 177, 180, 182, 184, 186, 188, 
	200, 212, 216, 220, 222, 237, 240, 244
];

_tsip_machine_parser_message_indicies = [
	0, 0, 0, 2, 2, 0, 0, 0, 
	0, 0, 0, 1, 3, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 1, 5, 
	5, 1, 6, 6, 7, 8, 7, 7, 
	7, 7, 1, 6, 6, 8, 1, 9, 
	1, 10, 9, 1, 11, 11, 1, 12, 
	12, 1, 13, 13, 1, 14, 1, 15, 
	1, 16, 15, 1, 17, 1, 18, 17, 
	1, 19, 1, 20, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 1, 22, 1, 
	23, 23, 24, 24, 24, 25, 24, 24, 
	24, 24, 24, 24, 1, 23, 23, 25, 
	1, 25, 27, 25, 26, 1, 28, 26, 
	1, 29, 28, 26, 1, 30, 31, 31, 
	31, 26, 26, 31, 26, 31, 26, 31, 
	26, 31, 26, 1, 32, 28, 26, 1, 
	33, 1, 26, 26, 1, 3, 4, 4, 
	4, 34, 34, 4, 4, 4, 4, 4, 
	4, 1, 3, 4, 4, 4, 35, 35, 
	4, 4, 4, 4, 4, 4, 1, 3, 
	4, 4, 4, 36, 4, 4, 4, 4, 
	4, 1, 37, 1, 38, 37, 1, 39, 
	1, 40, 39, 1, 41, 1, 42, 1, 
	43, 1, 44, 1, 45, 46, 47, 45, 
	45, 45, 45, 45, 45, 45, 45, 1, 
	48, 49, 50, 48, 48, 48, 48, 48, 
	48, 48, 48, 1, 51, 51, 51, 1, 
	48, 48, 48, 1, 52, 1, 54, 55, 
	55, 55, 53, 53, 55, 53, 55, 53, 
	55, 53, 55, 53, 1, 56, 53, 1, 
	57, 56, 53, 1, 32, 56, 53, 1, 
	0
];

_tsip_machine_parser_message_trans_targs = [
	2, 0, 28, 3, 2, 4, 5, 4, 
	6, 7, 8, 9, 10, 11, 12, 13, 
	14, 15, 16, 17, 18, 19, 43, 20, 
	19, 21, 22, 26, 23, 24, 25, 22, 
	44, 27, 29, 30, 31, 32, 33, 34, 
	35, 36, 37, 38, 39, 40, 16, 41, 
	40, 16, 41, 42, 43, 45, 47, 45, 
	46, 44
];

_tsip_machine_parser_message_trans_actions = [
	1, 0, 1, 3, 0, 1, 0, 0, 
	0, 0, 5, 1, 0, 0, 0, 0, 
	0, 0, 7, 0, 0, 1, 15, 0, 
	0, 0, 0, 0, 0, 0, 13, 20, 
	15, 0, 0, 0, 0, 0, 0, 0, 
	7, 1, 0, 0, 9, 1, 17, 1, 
	0, 11, 0, 0, 0, 0, 13, 20, 
	0, 0
];

tsip_machine_parser_message_start = 1;
tsip_machine_parser_message_first_final = 43;
tsip_machine_parser_message_error = 0;

tsip_machine_parser_message_en_main = 1;


/* line 99 "./ragel/tsip_parser_message.jrl" */

function tsip_message_parser_init(o_ragel_state){
	var cs = 0;

	// Ragel machine initialization.
	
/* line 172 "./src/parsers/tsip_parser_message.js" */
{
	 cs = tsip_machine_parser_message_start;
} /* JSCodeGen::writeInit */

/* line 105 "./ragel/tsip_parser_message.jrl" */
	
	o_ragel_state.i_cs = cs;
}

function tsip_message_parser_execute(o_ragel_state, o_msg, b_extract_content){
    var cs = o_ragel_state.i_cs;
	var p = o_ragel_state.i_p;
	var pe = o_ragel_state.i_pe;
	var eof = o_ragel_state.i_eof;
	var data = o_ragel_state.o_data;

	
/* line 190 "./src/parsers/tsip_parser_message.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_message_key_offsets[cs];
	_trans = _tsip_machine_parser_message_index_offsets[cs];
	_klen = _tsip_machine_parser_message_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_message_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_message_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_message_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_message_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_message_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_message_indicies[_trans];
	cs = _tsip_machine_parser_message_trans_targs[_trans];
	if (_tsip_machine_parser_message_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_message_trans_actions[_trans];
		_nacts = _tsip_machine_parser_message_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_message_actions[_acts - 1]) {
case 0:
/* line 14 "./ragel/tsip_parser_message.jrl" */

		o_ragel_state.i_tag_start = p;
			break;
case 1:
/* line 19 "./ragel/tsip_parser_message.jrl" */

	    o_ragel_state.i_tag_end = p;
		if(o_msg.e_type == tsip_message_type_e.UNKNOWN){
			o_msg.e_type = tsip_message_type_e.REQUEST;
			if(!o_msg.line.request.s_method){
			    o_msg.line.request.s_method = tsk_ragel_parser_get_string(o_ragel_state.s_data, p, o_ragel_state.i_tag_start);
				o_msg.line.request.e_type = tsip_message.prototype.GetRequestType(o_msg.line.request.s_method);
			}
		}
		else{
			o_ragel_state.cs = tsip_machine_parser_message_error;
		}
			break;
case 2:
/* line 34 "./ragel/tsip_parser_message.jrl" */

	    o_ragel_state.i_tag_end = p;
		if(!o_msg.line.request.o_uri){
		    var s_uri = tsk_ragel_parser_get_string(o_ragel_state.s_data, p, o_ragel_state.i_tag_start);
			o_msg.line.request.o_uri = tsip_uri.prototype.Parse(s_uri);
		}
			break;
case 3:
/* line 43 "./ragel/tsip_parser_message.jrl" */

	    o_ragel_state.i_tag_end = p;
		o_msg.s_version = tsk_ragel_parser_get_string(o_ragel_state.s_data, p, o_ragel_state.i_tag_start);
			break;
case 4:
/* line 49 "./ragel/tsip_parser_message.jrl" */

	    o_ragel_state.i_tag_end = p;	
		if(o_msg.e_type == tsip_message_type_e.UNKNOWN){
			o_msg.e_type = tsip_message_type_e.RESPONSE;
			var s_status_code = tsk_ragel_parser_get_string(o_ragel_state.s_data, p, o_ragel_state.i_tag_start);
			o_msg.line.response.i_status_code = parseInt(s_status_code);
		}
		else{
			o_ragel_state.i_cs = tsip_machine_parser_message_error;
		}
			break;
case 5:
/* line 62 "./ragel/tsip_parser_message.jrl" */

	    o_ragel_state.i_tag_end = p;
		if(!o_msg.line.response.s_reason_phrase){
			o_msg.line.response.s_reason_phrase = tsk_ragel_parser_get_string(o_ragel_state.s_data, p, o_ragel_state.i_tag_start);
		}
			break;
case 6:
/* line 70 "./ragel/tsip_parser_message.jrl" */

	    o_ragel_state.i_tag_end = p;
		tsip_header_parse(o_ragel_state, o_msg);
			break;
case 7:
/* line 76 "./ragel/tsip_parser_message.jrl" */

		o_ragel_state.i_cs = cs;
		o_ragel_state.i_p = p;
		o_ragel_state.i_pe = pe;
		o_ragel_state.i_eof = eof;

		tsip_message_parser_eoh(o_ragel_state, o_msg, b_extract_content);

		cs = o_ragel_state.i_cs;
		p = o_ragel_state.i_p;
		pe = o_ragel_state.i_pe;
		eof = o_ragel_state.i_eof;
			break;
/* line 351 "./src/parsers/tsip_parser_message.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 117 "./ragel/tsip_parser_message.jrl" */

    o_ragel_state.i_cs = cs;
	o_ragel_state.i_p = p;
	o_ragel_state.i_pe = pe;
	o_ragel_state.i_eof = eof;
}

function tsip_message_parser_eoh(o_ragel_state, o_msg, b_extract_content){
    if(o_msg && b_extract_content){
        var i_clen = o_msg.get_content_length();
        if((o_ragel_state.i_p + i_clen) < o_ragel_state.i_pe && !o_msg.o_content){
            var i_start = o_ragel_state.i_p + 1;
            var i_end = (i_start + i_clen);
			o_msg.o_content = new Array((i_end - i_start));
            for(var i = i_start, j = 0; i < i_end; ++i, ++j){
                o_msg.o_content[j] = o_ragel_state.o_data[i];
            }
            o_ragel_state.i_p += i_clen;
        }
        else{
            o_ragel_state.i_p = (o_ragel_state.i_pe - 1);
        }
    }
}

tsip_message.prototype.Parse = function(o_ragel_state, b_extract_content){
    var o_msg = null;
    if(!o_ragel_state || !o_ragel_state.o_data){
        return null;
    }
    
    o_msg = new tsip_message(tsip_message_type_e.UNKNOWN);
    
    // ragel init
    tsip_message_parser_init(o_ragel_state);
    
    // state machine execution
    tsip_message_parser_execute(o_ragel_state, o_msg, b_extract_content);
    
    if( o_ragel_state.i_cs < 
/* line 419 "./src/parsers/tsip_parser_message.js" */
43
/* line 156 "./ragel/tsip_parser_message.jrl" */
 ){
		tsk_utils_log_error("Failed to parse message: " + o_ragel_state.s_data);
		return null;
	}
    
    return o_msg;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/**
* Default SIP session expires timeout
*/
tsip_session.prototype.__i_expires_default = 1800000; /* milliseconds */
tsip_session.prototype.__i_session_id = 0;
tsip_session.prototype.__i_session_id_invalid = -1;
tsip_session.prototype.on_event = null;

var tsip_session_param_type_e =
{
    HEADER: 0,
    CAPS: 1,
    USR_DATA: 2,
    TO_STR: 3,
    from_STR: 3,
    TO_URI: 4,
    FROM_URI: 5,
    NO_CONTACT: 6,
    EXPIRES: 7,
    SILENT_HANGUP: 8,
    SIGCOMP_ID: 9,
    PARENT_ID: 10,

    BANDWIDTH: 20,
    VIDEO_SIZE: 21,
    AUDIO_CONSTRAINTS: 22,

    INITIAL_MSG: 50,

    MEDIA: 100
};

/**
* Base SIP session
* @ctor
* @tparam tsip_stack o_stack SIP stack used to create the session
*/
function tsip_session(o_stack) {
    if (!o_stack) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }

    this.i_id = ++tsip_session.prototype.__i_session_id;
    this.i_id_parent = tsip_session.prototype.__i_session_id_invalid; // for call transfer
    this.b_server = false;

    this.o_stack = o_stack;
    this.o_usr_data = null;

    //=======
	// SIP
    //=======
    this.ao_caps = new Array();
    this.ao_headers = new Array();

    this.o_uri_from = o_stack.identity.o_uri_impu;
    this.o_uri_to = null; // will be set by the dialog
    this.i_expires = tsip_session.prototype.__i_expires_default;
    this.b_silent_hangup = false;
    this.b_no_contact = false;

    //=======
    // Media
    //=======
    this.media = {};
    this.media.e_type = tmedia_type_e.NONE;
    this.media.b_100rel = false;
    this.media.o_bandwidth = o_stack.media.o_bandwidth;
    this.media.o_video_size = o_stack.media.o_video_size;
    this.media.o_audio_constraints = o_stack.media.o_audio_constraints;

    this.media.timers = {};
    this.media.timers.s_refresher = null;
    this.media.timers.i_timeout = 0;

    this.media.qos = {};
    this.media.qos.e_type = tmedia_qos_stype_e.NONE;
    this.media.qos.e_strength = tmedia_qos_strength_e.NONE;

    this.media.msrp = {};
    this.media.msrp.fn_callback = null;    
}

/**
* Gets session id
* @treturn int session id
*/
tsip_session.prototype.get_id = function () {
    return this.i_id;
}

/**
* Sets parameters
*/
tsip_session.prototype.set = function () {
    return this.__set(arguments);
}

/**
* Gets SIP stack used to create this session
*/
tsip_session.prototype.get_stack = function(){
    return this.o_stack;
}

/**
* Checks whether the session is connected or not
* @treturn bool true if connected and false otherwise
*/
tsip_session.prototype.is_connected = function () {
    var o_dialog;
    if ((o_dialog = this.o_stack.o_layer_dialog.find_by_ss(this))) {
        return (o_dialog.e_state == tsip_dialog_state_e.ESTABLISHED);
    }
    return false;
}

/*
Internal function
set(...)
*/
tsip_session.prototype.__set = function (ao_params) {
    var o_curr;
    for (var i = 0; i < ao_params.length; ++i) {
        o_curr = ao_params[i];
        if (!o_curr) {
            continue;
        }

        switch (o_curr.e_type) {
            case tsip_session_param_type_e.HEADER:
                {
                    this.ao_headers.push(new tsip_header_Dummy(o_curr.ao_values[0], o_curr.ao_values[1]));
                    break;
                }
            case tsip_session_param_type_e.CAPS:
                {
                    this.ao_caps.push(tsk_param_create(o_curr.ao_values[0], o_curr.ao_values[1]));
                    break;
                }
            case tsip_session_param_type_e.USR_DATA:
                {
                    this.o_usr_data = o_curr.ao_values[0];
                    break;
                }
            case tsip_session_param_type_e.TO_STR:
                {
                    this.o_uri_to = tsip_uri_make_valid(o_curr.ao_values[0], this.o_stack.network.o_uri_realm.s_host);
                    break;
                }
            case tsip_session_param_type_e.FROM_STR:
                {
                    this.o_uri_from = tsip_uri_make_valid(o_curr.ao_values[0], this.o_stack.network.o_uri_realm.s_host);
                    break;
                }
            case tsip_session_param_type_e.TO_URI:
                {
                    if(!o_curr.ao_values[0] || o_curr.ao_values[0] instanceof tsip_uri) { 
                        this.o_uri_to = o_curr.ao_values[0];
                    }
                    else {
                        tsk_utils_log_error("Not a valid uri object");
                    }
                    break;
                }
            case tsip_session_param_type_e.FROM_URI:
                {
                    if(!o_curr.ao_values[0] || o_curr.ao_values[0] instanceof tsip_uri) { 
                        this.o_uri_from = o_curr.ao_values[0];
                    }
                    else {
                        tsk_utils_log_error("Not a valid uri object");
                    }
                    break;
                }
            case tsip_session_param_type_e.NO_CONTACT:
                {
                    this.b_no_contact = o_curr.ao_values[0];
                    break;
                }
            case tsip_session_param_type_e.EXPIRES:
                {
                    this.i_expires = (o_curr.ao_values[0] * 1000); // to milliseconds
                    break;
                }
            case tsip_session_param_type_e.SILENT_HANGUP:
                {
                    break;
                }
            case tsip_session_param_type_e.SIGCOMP_ID:
                {
                    break;
                }
            case tsip_session_param_type_e.PARENT_ID:
                {
                    break;
                }

            case tsip_session_param_type_e.BANDWIDTH:
                {
                    this.media.o_bandwidth = o_curr.ao_values[0];
                    break;
                }
            case tsip_session_param_type_e.VIDEO_SIZE:
                {  
                    this.media.o_video_size = o_curr.ao_values[0];
                    break;
                }
            case tsip_session_param_type_e.AUDIO_CONSTRAINTS:
                {  
                    this.media.o_audio_constraints = o_curr.ao_values[0];
                    break;
                }

            case tsip_session_param_type_e.INITIAL_MSG:
                {
                    var o_message;
                    if ((o_message = o_curr.ao_values[0])) {
                        if (o_message.o_hdr_From && o_message.o_hdr_From.o_uri) {
                            this.o_uri_from = o_message.o_hdr_From.o_uri.clone(false, false);
                        }
                        if (o_message.o_hdr_To && o_message.o_hdr_To.o_uri) {
                            this.o_uri_to = o_message.o_hdr_To.o_uri.clone(false, false);
                        }
                        this.b_server = true;
                    }
                    break;
                }
        }
    }
}

/**
* Adds session-level header
* @tparam String s_name SIP header name
* @tparam String s_value Header value
* @treturn Object Parameter object
*
@code
o_session.set(
    tsip_session.prototype.SetHeader("P-Preferred-Identity", "<sip:alice@doubango.org>"),
    tsip_session.prototype.SetHeader("Date", "Wed, 28 Apr 2010 23:42:50 GMT")
);
@endcode
*/
tsip_session.prototype.SetHeader = function (s_name, s_value) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.HEADER, s_name, s_value);
}

/**
* Sets expires timeout
* @tparam int i_expires Session expires timeout in seconds
* @treturn Object Parameter object
*
@code
o_session.set(tsip_session.prototype.SetExpires(1800));
@endcode
*/
tsip_session.prototype.SetExpires = function (i_expires) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.EXPIRES, i_expires);
}

/*
* Internal function
*/
tsip_session.prototype.SetUsrData = function (o_usr_data) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.USR_DATA, o_usr_data);
}

/**
* Adds session capabilities
* @tparam String s_name Capiblity name
* @tparam String s_value Capability value (optional)
* @treturn Object Parameter object
*
@code
o_session.set(
    tsip_session.prototype.SetCaps("+g.oma.sip-im"),
    tsip_session.prototype.SetCaps("+audio"),
    tsip_session.prototype.SetCaps("language", "\"en,fr\"")
);
@endcode
*/
tsip_session.prototype.SetCaps = function (s_name, s_value) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.CAPS, s_name, s_value);
}

/**
* Sets destination uri
* @tparam String s_to Destination Uri
* @treturn Object Parameter object
*
@code
o_session.set(
    tsip_session.prototype.SetToStr("sip:alice@doubango.org")
);
// or
o_session.set(
    tsip_session.prototype.SetToStr("alice")
); // the SIP Uri will be built using domain name (realm)
@endcode
*/
tsip_session.prototype.SetToStr = function (s_to) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.TO_STR, s_to);
}

tsip_session.prototype.SetToUri = function (o_to) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.TO_URI, o_to);
}

tsip_session.prototype.SetFromStr = function (s_from) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.FROM_STR, s_from);
}

tsip_session.prototype.SetInitialMessage = function (o_sip_message) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.INITIAL_MSG, o_sip_message);
}

tsip_session.prototype.SetBandwidth = function (o_bandwidth) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.BANDWIDTH, o_bandwidth);
}

tsip_session.prototype.SetVideoSize = function (o_video_size) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.VIDEO_SIZE, o_video_size);
}

tsip_session.prototype.SetAudioConstraints = function (o_audio_constraints) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.AUDIO_CONSTRAINTS, o_audio_constraints);
}

tsip_session.prototype.SetInitialMessage = function (o_sip_message) {
    return tsip_session.prototype.SetAny(tsip_session_param_type_e.INITIAL_MSG, o_sip_message);
}


/*
* Internal function
*/
tsip_session.prototype.SetAny = function (e_type) {
    var obj = new Object();
    obj.e_type = e_type;
    obj.ao_values = Array.prototype.slice.call(arguments, 1);
    return obj;
}



if(!window.__b_release_mode){
    tsip_api_add_js_scripts('head',
    'src/tinySIP/src/api/tsip_api_common.js',
    'src/tinySIP/src/api/tsip_api_info.js',
    'src/tinySIP/src/api/tsip_api_invite.js',
    'src/tinySIP/src/api/tsip_api_message.js',
    'src/tinySIP/src/api/tsip_api_options.js',
    'src/tinySIP/src/api/tsip_api_publish.js',
    'src/tinySIP/src/api/tsip_api_register.js',
    'src/tinySIP/src/api/tsip_api_subscribe.js'
    );
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_session.prototype.__action_handle = function(o_action){
    var i_ret = -1
    if(this.o_stack && o_action){
		var o_dialog;
				
		if((o_dialog = this.o_stack.o_layer_dialog.find_by_ss(this))){
			switch(o_action.e_type){
			    case tsip_action_type_e.HANGUP:
					{	/* hang-up is an special case (==> hangup/cancel/nothing) */
						i_ret = o_dialog.hangup(o_action);
						break;
					}
				default:
					{	/* All other cases */
						i_ret = o_dialog.fsm_act(o_action.e_type, null, o_action);
						break;
					}
			}
		}
		else{
		    tsk_utils_log_error("Failed to find dialog with this opid [" + this.i_id + "]");
		}
	}
	else{
		tsk_utils_log_error("Invalid argument");
	}

	return i_ret;
}

// __action_any(e_action_type, ...)
tsip_session.prototype.__action_any = function(e_action_type){
	/* Checks for validity */
	if(!this.o_stack){
		tsk_utils_log_error("Invalid stack");
		return -1;
	}
	
	/* Checks if the stack has been started */
	if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }

	/* execute action */
    var o_action = new tsip_action(e_action_type);
    return this.__action_handle(o_action);
}

// reject(...)
tsip_session.prototype.reject = function () {
    return this.__action_any(tsip_action_type_e.REJECT);
}

// hangup(...)
tsip_session.prototype.hangup = function () {
    return this.__action_any(tsip_action_type_e.HANGUP);
}

// accept(...)
tsip_session.prototype.accept = function () {
    return this.__action_any(tsip_action_type_e.ACCEPT);
}

// cancel(...)
tsip_session.prototype.cancel = function () {
    return this.__action_any(tsip_action_type_e.CANCEL);
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_event_info.prototype = Object.create(tsip_event.prototype);
var tsip_event_info_type_e =
{
    I_INFO: 0,
    AO_INFO: 1
};

function tsip_event_info(o_sip_session, i_code, s_phrase, o_sip_message, e_info_type) {
    //this.__proto__ = new tsip_event(o_sip_session, i_code, s_phrase, o_sip_message, tsip_event_type_e.INFO);
    tsip_event.call(this, o_sip_session, i_code, s_phrase, o_sip_message, tsip_event_type_e.INFO);
    this.e_type = e_info_type;
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_session_invite.prototype = Object.create(tsip_session.prototype);
tsip_event_invite.prototype = Object.create(tsip_event.prototype);

tsip_session_invite.prototype.o_stream_local = null;
tsip_session_invite.prototype.o_stream_remote = null;

/**
* SIP <b>INVITE</b> event types
*/
var tsip_event_invite_type_e = 
{
	// ============================
	//	Sip Events
	//
	I_NEW_CALL: 0,
	
	// in-dialog requests/reponses
	I_REQUEST: 100,
	I_AO_REQUEST: 101,
	
	// 3GPP TS 24.629: Explicit Call Transfer (ECT)
	O_ECT_TRYING: 200,
	O_ECT_ACCEPTED: 201,
	O_ECT_COMPLETED: 202,
	O_ECT_FAILED: 203,
	O_ECT_NOTIFY: 204,
	I_ECT_REQUESTED: 205,
	I_ECT_NEW_CALL: 206,
	I_ECT_COMPLETED: 207,
	I_ECT_FAILED: 208,
	I_ECT_NOTIFY: 209,
	
	// ============================
	//	Media Events
	//

	M_EARLY_MEDIA: 300,
	M_UPDATING: 301, // Trying to update from Audio -> Video for example
	M_UPDATED: 302, // succeed to update
	M_STREAM_CONNECTING: 303,
	M_STREAM_CONNECTED: 304,
    M_STREAM_LOCAL_REQUESTED: 305,
    M_STREAM_LOCAL_ACCEPTED: 306,
    M_STREAM_LOCAL_REFUSED: 307,
    M_STREAM_LOCAL_ADDED: 308,
    M_STREAM_LOCAL_REMOVED: 309,
    M_STREAM_REMOTE_ADDED: 310,
    M_STREAM_REMOTE_REMOVED: 311,
	
	/* 3GPP TS 24.610: Communication Hold */
	M_LOCAL_HOLD_OK: 400,
	M_LOCAL_HOLD_NOK: 401,
	M_LOCAL_RESUME_OK: 402,
	M_LOCAL_RESUME_NOK: 403,
	M_REMOTE_HOLD: 404,
	M_REMOTE_RESUME:405
};

/**
* SIP <b>INVITE</b> session
* @ctor
* Signature: tsip_session_invite(o_stack, ...set())
* @tparam tsip_stack o_stack SIP stack to use to create the session
*
@code
// creates a session to call 'alice'
var o_session = new tsip_session_invite(o_stack,
    tsip_session.prototype.SetToStr("alice"),
    tsip_session.prototype.SetCaps("+sip.ice"),
    tsip_session.prototype.SetHeader("Purpose", "Calling 'alice'")
);
@endcode
*/
function tsip_session_invite(o_stack) {
    tsip_session.call(this, o_stack);
    this.__set(Array.prototype.slice.call(arguments, 1));
}

/**
* SIP <b>INVITE</b> event. <br />
* Used to report <b>INVITE</b> events via @ref tsip_stack::on_event_invite and @ref tsip_stack::on_event_dialog
* @ctor
* @tparam tsip_session_invite o_session SIP session
* @tparam int i_code Event code
* @tparam String s_phrase Event description
* @tparam tsip_message o_sip_message SIP message
* @tparam tsip_event_invite_type_e e_invite_type <b>INVITE</b> event type
*/
function tsip_event_invite(o_session, i_code, s_phrase, o_sip_message, e_invite_type) {
    tsip_event.call(this, o_session, i_code, s_phrase, o_sip_message, tsip_event_type_e.INVITE);
    this.e_invite_type = e_invite_type;
}

/**
* Gets the local video url
* @treturn objectURL valid url object if succeed and null otherwise
* @sa @ref tsip_stack::on_event_invite
*
@code
o_stack.on_event_invite = function (evt) {
     switch (evt.e_invite_type) {
        case tsip_event_invite_type_e.M_STREAM_LOCAL_ADDED:
                {
                    // 'video_local' is a HTML <video> element 
                    document.getElementById("video_local").srcObject = evt.get_session().get_stream_local();
                    break;
                }
     }
};
* @endcode
*/
tsip_session_invite.prototype.get_stream_local = function () {
    return this.o_stream_local;
}

/**
* Gets the remote video url
* @treturn objectURL valid url object if succeed and null otherwise
* @sa @ref tsip_stack::on_event_invite
*
@code
o_stack.on_event_invite = function (evt) {
    switch (evt.e_invite_type) {
        case tsip_event_invite_type_e.M_STREAM_REMOTE_ADDED:
            {
                // 'video_remote' is a HTML <video> element 
                document.getElementById("video_remote").srcObject = evt.get_session().get_stream_remote();
                break;
            }
    }
};
* @endcode
*/
tsip_session_invite.prototype.get_stream_remote = function () {
    return this.o_stream_remote;
}

/*
 Internal function
*/
tsip_session_invite.prototype.__set_stream_local = function (o_stream) {
    this.o_stream_local = o_stream;
}

/*
Internal function
*/
tsip_session_invite.prototype.__set_stream_remote = function (o_stream) {
    this.o_stream_remote = o_stream;
}

/**
* Makes and audio/video call.<br /> Sends SIP <b>INVITE</b> request.<br /> The session state will be reported through @ref tsip_stack::on_event_dialog and @ref tsip_stack::on_event_invite.
*
* Signature: call(e_media_type, ...set())
* @tparam tmedia_type_e e_media_type media type. For now, only tmedia_type_e.AUDIO and tmedia_type_e.AUDIO_VIDEO are supported.
* @treturn int zero if succeed and non-zero otherwise
* @sa @ref hold() <br /> @ref resume()
*
@code
o_session.call(tmedia_type_e.AUDIO_VIDEO,
    tsip_session.prototype.SetHeader("Purpose", "Calling someone")
);
@endcode
*/
tsip_session_invite.prototype.call = function(e_media_type){
    if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }
    
    var i_ret = -1;
    var o_action = new tsip_action(tsip_action_type_e.INVITE);
    if(o_action){
        var b_new_dialog = false;
        o_action.media.e_type = e_media_type;
        var o_dialog = this.o_stack.o_layer_dialog.find_by_ss(this);
        if (!o_dialog) {
            b_new_dialog = true;
            o_dialog = this.o_stack.o_layer_dialog.dialog_new(tsip_dialog_type_e.INVITE, this);
        }
        if((i_ret = o_dialog.fsm_act(o_action.e_type, null, o_action)) == 0){
            if(b_new_dialog){ // otherwise we are trying to refresh the media type and the type will be updated if 200 OK
                this.media.e_type = e_media_type;
            }
        }
    }

	return i_ret;
}

/**
* Puts the call on hold.<br /> The hold/resume state will be reported through @ref tsip_stack::on_event_invite.
*
* Signature: hold(e_media_type, ...set())
* @tparam tmedia_type_e e_media_type media type to hold. Should be the same media type used to make the call.
* @treturn int zero if succeed and non-zero otherwise
* @sa @ref call() <br /> @ref resume()
*
@code
o_session.hold(tmedia_type_e.AUDIO_VIDEO,
    tsip_session.prototype.SetHeader("Purpose", "Holding the call")
);
@endcode
*/
tsip_session_invite.prototype.hold = function(e_media_type){
    if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }

    var i_ret = -1;
    var o_action = new tsip_action(tsip_action_type_e.HOLD);
    if(o_action){
        o_action.media.e_type = e_media_type;
        i_ret = this.__action_handle(o_action);
    }

	return i_ret;
}

/**
* Resumes the call.<br /> The hold/resume state will be reported through @ref tsip_stack::on_event_invite.
*
* Signature: resume(e_media_type, ...set())
* @tparam tmedia_type_e e_media_type media type to resume. Should be the same media type used to make the call.
* @treturn int zero if succeed and non-zero otherwise
* @sa @ref call() <br /> @ref hold()
*
@code
o_session.resume(tmedia_type_e.AUDIO_VIDEO,
    tsip_session.prototype.SetHeader("Purpose", "Resuming the call")
);
@endcode
*/
tsip_session_invite.prototype.resume = function(e_media_type){
    if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }

    var i_ret = -1;
    var o_action = new tsip_action(tsip_action_type_e.RESUME);
    if(o_action){
        o_action.media.e_type = e_media_type;
        i_ret = this.__action_handle(o_action);
    }

	return i_ret;
}

/**
* Sends SIP INFO message. The session must be connected or in early-media state.<br />
* Signature: info(o_content, s_content_type, ...set())
* @tparam Object o_content Message content. Could be a String or ArrayBuffer
* @tparam String s_content_type Message content type
* @treturn int zero if succeed and non-zero otherwise
*
@code
o_session.info("Hello world!", "text/plain");
@endcode
*/
tsip_session_invite.prototype.info = function (o_content, s_content_type) {
    if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }

    var i_ret = -1;
    var o_action = new tsip_action(tsip_action_type_e.INFO);
    if (o_action) {
        if (s_content_type) {
            o_action.add_headers(new tsip_header_Content_Type(s_content_type));
        }
        o_action.set_content(o_content);
        i_ret = this.__action_handle(o_action);
    }

    return i_ret;
}

/**
* Sends DTMF digit using SIP INFO. The session must be connected or in early-media state.<br />
* Signature: dtmf(...set())
* @tparam char c_digit Digit to send
* @treturn int zero if succeed and non-zero otherwise
*
@code
// sends sharp digit
o_session.dtmf('#');
@endcode
*/
tsip_session_invite.prototype.dtmf = function (c_digit) {
    if (!c_digit) {
        tsk_utils_log_error("Invalid parameter");
        return -1;
    }
    return this.info(
        tsk_string_format("Signal={0}\r\nDuration={1}", c_digit, 120),
        "application/dtmf-relay"
    );
}


/**
* Transfers the call using SIP REFER. The session must be connected or in early-media state.<br />
* Signature: dtmf(...set())
* @tparam String s_to Transfer destination uri or phone number
* @treturn int zero if succeed and non-zero otherwise
*
@code
o_session.transfer('alice');
// or
o_session.transfer('sip:alice@doubango.org');
@endcode
*/
tsip_session_invite.prototype.transfer = function (s_to) {
    if (!s_to) {
        tsk_utils_log_error('Invalid parameter');
        return -1;
    }
    if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }
    var o_uri_to = tsip_uri_make_valid(s_to, this.o_stack.network.o_uri_realm.s_host);
    if (!o_uri_to) {
        tsk_utils_log_error("%s is not a valid SIP Uri", s_to);
        return -3;
    }

    var i_ret = -1;
    var o_action = new tsip_action(tsip_action_type_e.ECT);
    if (o_action) {
        o_action.ect.s_to = tsip_uri_tostring(o_uri_to, false, false);
        i_ret = this.__action_handle(o_action);
    }

    return i_ret;
}

/**
* Accepts incoming tgransfer request
* @treturn int zero if succeed and non-zero otherwise
*/
tsip_session_invite.prototype.transfer_accept = function () {
    return this.__action_any(tsip_action_type_e.ECT_ACCEPT);
}

/**
* Rejects incoming tgransfer request
* @treturn int zero if succeed and non-zero otherwise
*/
tsip_session_invite.prototype.transfer_reject = function () {
    return this.__action_any(tsip_action_type_e.ECT_REJECT);
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_session_message.prototype = Object.create(tsip_session.prototype);

var tsip_event_message_type_e =
{
	I_MESSAGE: 0,
	AO_MESSAGE: 1
};

function tsip_event_message(o_sip_session, i_code, s_phrase, o_message, e_message_type) {
    this.__proto__ = new tsip_event(o_sip_session, i_code, s_phrase, o_message, tsip_event_type_e.MESSAGE);
    this.e_message_type = e_message_type;
}

function tsip_session_message(o_stack) {
    tsip_session.call(this, o_stack);    
    this.__set(Array.prototype.slice.call(arguments, 1));
}

// send(o_content, s_content_type, ...)
tsip_session_message.prototype.send = function (o_content, s_content_type) {
    if (!o_content) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }

    var i_ret = -1;
    var o_action = new tsip_action(tsip_action_type_e.MESSAGE);
    if (o_action) {
        var o_dialog = this.o_stack.o_layer_dialog.dialog_new(tsip_dialog_type_e.MESSAGE, this);
        if (o_dialog) {
            o_action.set_content(o_content);
            if (s_content_type) {
                o_action.add_headers(new tsip_header_Content_Type(s_content_type));
            }
            if ((i_ret = o_dialog.fsm_act(o_action.e_type, null, o_action)) == 0) { }
        }
    }

    return i_ret;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var tsip_event_options_type_e = 
{
	I_OPTIONS: 0,
	AO_OPTIONS: 1
};

function tsip_event_options(o_sip_session, i_code, s_phrase, o_sip_message, e_options_type) {
    this.__proto__ = new tsip_event(o_sip_session, i_code, s_phrase, o_sip_message, tsip_event_type_e.OPTIONS);
    this.e_type = e_options_type;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_session_publish.prototype = Object.create(tsip_session.prototype);
tsip_event_publish.prototype = Object.create(tsip_event.prototype);

var tsip_event_publish_type_e =
{
    I_PUBLISH: 0,
    AO_PUBLISH: 1,

    I_UNPUBLISH: 10,
    AO_UNPUBLISH: 11
};

function tsip_event_publish(o_sip_session, i_code, s_phrase, o_sip_message, e_publish_type) {
    tsip_event.call(this, o_sip_session, i_code, s_phrase, o_sip_message, tsip_event_type_e.PUBLISH);
    this.e_publish_type = e_publish_type;
}

/**
* SIP <b>PUBLISH</b> session.
* @ctor
* Signature: tsip_session_publish(o_stack, ...set())
* @tparam tsip_stack o_stack SIP stack to use to create this session
*/
function tsip_session_publish(o_stack) {
    tsip_session.call(this, o_stack);
    this.__set(Array.prototype.slice.call(arguments, 1));
}

tsip_session_publish.prototype.publish = function (o_content, s_content_type) {
    if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }

    var i_ret = -1;
    var o_action = new tsip_action(tsip_action_type_e.PUBLISH);
    if(o_action){
        var o_dialog = this.o_stack.o_layer_dialog.find_by_ss(this);
        if (!o_dialog) {
            o_dialog = this.o_stack.o_layer_dialog.dialog_new(tsip_dialog_type_e.PUBLISH, this);
        }
        
        // add content and content-type to the action object
        o_action.set_content(o_content);
        if (s_content_type) {
            o_action.add_headers(new tsip_header_Content_Type(s_content_type));
        }
        
        i_ret = o_dialog.fsm_act(o_action.e_type, null, o_action);
    }

    return i_ret;
}

tsip_session_publish.prototype.unpublish = function () {
    return this.__action_any(tsip_action_type_e.UNPUBLISH);
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/**
* SIP <b>REGISTER</b> event types
* @var
*/
tsip_session_register.prototype = Object.create(tsip_session.prototype);
tsip_event_register.prototype = Object.create(tsip_event.prototype);

var tsip_event_register_type_e =
{
	I_NEW_REGISTER: 0,

	I_REGISTER: 10, // refresh
	AO_REGISTER: 11,

	I_UNREGISTER: 20,
	AO_UNREGISTER: 21
};

/**
* SIP <b>REGISTER</b> session.
* @ctor
* Signature: tsip_session_register(o_stack, ...set())
* @tparam tsip_stack o_stack SIP stack to use to create this session
*/
function tsip_session_register(o_stack) {
    tsip_session.call(this, o_stack);
    this.__set(Array.prototype.slice.call(arguments, 1));
}

/**
* SIP <b>REGISTER</b> event. <br /> The registration state will be reported through @ref tsip_stack::on_event_dialog.
* Used to report <b>REGISTER</b> events via @ref tsip_stack::on_event_dialog
* @ctor
* @tparam tsip_session_register o_session SIP session
* @tparam int i_code Event code
* @tparam String s_phrase Event description
* @tparam tsip_message o_sip_message SIP message
* @tparam tsip_event_register_type_e e_register_type <b>REGISTER</b> event type
*
@code
o_session = new tsip_session_register(o_stack,
                tsip_session.prototype.SetExpires(1800),
                tsip_session.prototype.SetHeader("Purpose", "Registering"),
                tsip_session.prototype.SetCaps("+g.oma.sip-im"),
                tsip_session.prototype.SetCaps("+audio"),
                tsip_session.prototype.SetCaps("language", "\"en,fr\"")
 );
@endcode
*/
function tsip_event_register(o_session, i_code, s_phrase, o_sip_message, e_register_type) {
    tsip_event.call(this, o_session, i_code, s_phrase, o_sip_message, tsip_event_type_e.REGISTER);
    this.e_register_type = e_register_type;
}

/**
* Registers (login) the session. Sends SIP <b>REGISTER</b> message. <br/>The registration state will be reported through @ref tsip_stack::on_event_dialog. <br />
* Signature: register(...set())
* @treturn int zero if succeed and non-zero otherwise
*
@code
o_session.register();
@endcode
*/
tsip_session_register.prototype.register = function () {
    if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }

    var i_ret = -1;
    var o_action = new tsip_action(tsip_action_type_e.REGISTER);
    if(o_action){
        var o_dialog = this.o_stack.o_layer_dialog.find_by_ss(this);
        if (!o_dialog) {
            o_dialog = this.o_stack.o_layer_dialog.dialog_new(tsip_dialog_type_e.REGISTER, this);
        }
        i_ret = o_dialog.fsm_act(o_action.e_type, null, o_action);
    }

    return i_ret;
}

/**
* UnRegisters (logout) the session. Sends SIP <b>REGISTER</b> message with expires value equal to zero. <br />The registration state will be reported through @ref tsip_stack::on_event_dialog. <br />
* Signature: unregister(...set())
* @treturn int zero if succeed and non-zero otherwise
*
@code
o_session.unregister();
@endcode
*/
tsip_session_register.prototype.unregister = function () {
    return this.__action_any(tsip_action_type_e.UNREGISTER);
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_session_subscribe.prototype = Object.create(tsip_session.prototype);
tsip_event_subscribe.prototype = Object.create(tsip_event.prototype);

var tsip_event_subscribe_type_e =
{
	I_SUBSCRIBE: 0,
	AO_SUBSCRIBE: 1,
	
	I_UNSUBSRIBE: 10,
	AO_UNSUBSCRIBE: 11,

	I_NOTIFY: 20,
	AO_NOTIFY: 21
};

function tsip_event_subscribe(o_sip_session, i_code, s_phrase, o_sip_message, e_subscribe_type) {
    tsip_event.call(this, o_sip_session, i_code, s_phrase, o_sip_message, tsip_event_type_e.SUBSCRIBE);
    this.e_subscribe_type = e_subscribe_type;
}

/**
* SIP <b>SUBSCRIBE</b> session.
* @ctor
* Signature: tsip_session_publish(o_stack, ...set())
* @tparam tsip_stack o_stack SIP stack to use to create this session
*/
function tsip_session_subscribe(o_stack) {
    tsip_session.call(this, o_stack);
    this.__set(Array.prototype.slice.call(arguments, 1));
}

tsip_session_subscribe.prototype.subscribe = function () {
    if (this.o_stack.e_state != tsip_transport_state_e.STARTED) {
        tsk_utils_log_error("Stack not started");
        return -2;
    }

    var i_ret = -1;
    var o_action = new tsip_action(tsip_action_type_e.SUBSCRIBE);
    if(o_action){
        var o_dialog = this.o_stack.o_layer_dialog.find_by_ss(this);
        if (!o_dialog) {
            o_dialog = this.o_stack.o_layer_dialog.dialog_new(tsip_dialog_type_e.SUBSCRIBE, this);
        }
        i_ret = o_dialog.fsm_act(o_action.e_type, null, o_action);
    }

    return i_ret;
}

tsip_session_subscribe.prototype.unsubscribe = function () {
    return this.__action_any(tsip_action_type_e.UNSUBSCRIBE);
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/**@page page_tsip_stack SIP Stack
The SIP stack is the base object used to create all sessions (registration, publication, call...). You must create a stack before starting to make or receive calls.
<h2>Creating a SIP Stack</h2>
@code
var o_stack = new tsip_stack("doubango.org", "alice", "sip:alice@doubango.org", "192.168.0.12", 5062,
    tsip_stack.prototype.SetPassword ("mysecret"),
    tsip_stack.prototype.SetDisplayName("alice"),
    tsip_stack.prototype.SetHeader("User-Agent", "IM-client/OMA1.0 sipML5/v0.0.0000.0"),
    tsip_stack.prototype.SetHeader("Organization", "Doubango Telecom")
);
@endcode
 - 'doubango.org': SIP domain name a.k.a. <i>realm</i>
 - 'alice': Your IMS Private Identity a.k.a <i>authentication name</i>
 - 'sip:alice@doubango.org': Your IMS Public Identity a.k.a <i>SIP address</i>
 - '192.168.0.12': WebSocket outbound proxy Host. Must be a SIP server supporting SIP over WebSockets as per <a href="http://tools.ietf.org/html/draft-ibc-sipcore-sip-websocket-02">draft-ibc-sipcore-sip-websocket-02</a>. If
 your SIP server don't support this protocol then replace the host address by <b>simpl5.org</b>. When using <b>sipML5</b> outbound proxy, all crequests will be forward to your SIP server according to the result of DNS NAPTR + SRV (realm).
 - 5062: Websocket outbound proxy port

 In the above example, the SIP stack is created to connect to a SIP server/proxy supporting SIP o/ WebSocket at '192.168.0.12:5062'. All requests received through the WebSocket channel will be forwarded to 'doubango.org' using UDP, TCP or TLS protocol.

 @image html global_view.png "Global View"

<h2>Setting Outbound Proxy</h2>
It could be useful define an outbound proxy if no DNS entries are defined for the defined <i>realm</i>.
Please note that this outbound proxy could be defined at the stack creation like this:
@code
var o_stack = new tsip_stack(....
    tsip_stack.prototype.SetProxyOutBound("192.168.0.10", 5060, tsip_transport_type_e.UDP)
);

@endcode


*/


/**
* Callback function called to report Stack related events.
*
@code
o_stack.on_event_stack = function (evt: tsip_event) {
tsk_utils_log_info(evt.s_phrase);
    switch (evt.i_code) {
        case tsip_event_code_e.STACK_STARTED:
        case tsip_event_code_e.STACK_STOPPING:
        case tsip_event_code_e.STACK_STOPPED:
        case tsip_event_code_e.STACK_STARTING:
        case tsip_event_code_e.STACK_FAILED_TO_START:
        case tsip_event_code_e.STACK_FAILED_TO_STOP:
        default: break;
    }
};
@endcode
*/
tsip_stack.prototype.on_event_stack = null;
/**
* Callback function called to report dialog events. This event is common to all sessions (INVITE, REGISTER, PUBLISH, INFO...) and used to report connection states (CONNECTED, CONNECTING, TERMINATING, TERMINATED....)
and errors.
*
@code
o_stack.on_event_dialog = function (evt: tsip_event) {
    tsk_utils_log_info("phrase=" + evt.s_phrase);
    tsk_utils_log_info("sesssion id=%d", evt.get_session().get_id());
    switch (evt.i_code) {
        case tsip_event_code_e.DIALOG_TRANSPORT_ERROR:
        case tsip_event_code_e.DIALOG_GLOBAL_ERROR:
        case tsip_event_code_e.DIALOG_MESSAGE_ERROR:
        case tsip_event_code_e.DIALOG_WEBRTC_ERROR:

        case tsip_event_code_e.DIALOG_REQUEST_INCOMING:
        case tsip_event_code_e.DIALOG_REQUEST_OUTGOING:
        case tsip_event_code_e.DIALOG_REQUEST_CANCELLED:
        case tsip_event_code_e.DIALOG_REQUEST_SENT:
        case tsip_event_code_e.DIALOG_MEDIA_ADDED:
        case tsip_event_code_e.DIALOG_MEDIA_REMOVED:

        case tsip_event_code_e.DIALOG_CONNECTING:
        case tsip_event_code_e.DIALOG_CONNECTED:

        case tsip_event_code_e.DIALOG_TERMINATING:
        case tsip_event_code_e.DIALOG_TERMINATED:
        
        default: break;
    }
};
@endcode
*/
tsip_stack.prototype.on_event_dialog = null;
/**
* Callback function used to report audio/video call (SIP INVITE) session events. Note that this callback won't report connection state. To get connection state, you should use @ref on_event_dialog event.
*
@code
o_stack.on_event_invite = function (evt: tsip_event_invite) {
    tsk_utils_log_info("phrase=" + evt.s_phrase);
    tsk_utils_log_info("sesssion id=%d", evt.get_session().get_id());
    switch (evt.e_invite_type) {
        case tsip_event_invite_type_e.I_NEW_CALL:
	
	    case tsip_event_invite_type_e.I_REQUEST:
	    case tsip_event_invite_type_e.I_AO_REQUEST:
	
        case tsip_event_invite_type_e.O_ECT_TRYING:
        case tsip_event_invite_type_e.O_ECT_ACCEPTED:
        case tsip_event_invite_type_e.O_ECT_COMPLETED:
        case tsip_event_invite_type_e.O_ECT_FAILED:
        case tsip_event_invite_type_e.O_ECT_NOTIFY:
        case tsip_event_invite_type_e.I_ECT_REQUESTED:
        case tsip_event_invite_type_e.I_ECT_NEW_CALL:
        case tsip_event_invite_type_e.I_ECT_COMPLETED:
        case tsip_event_invite_type_e.I_ECT_FAILED:
        case tsip_event_invite_type_e.I_ECT_NOTIFY:

	    case tsip_event_invite_type_e.M_EARLY_MEDIA:
	    case tsip_event_invite_type_e.M_UPDATING:
	    case tsip_event_invite_type_e.M_UPDATED:
	    case tsip_event_invite_type_e.M_STREAM_CONNECTING:
	    case tsip_event_invite_type_e.M_STREAM_CONNECTED:
        case tsip_event_invite_type_e.M_STREAM_LOCAL_ADDED:
        case tsip_event_invite_type_e.M_STREAM_LOCAL_REMOVED:
        case tsip_event_invite_type_e.M_STREAM_REMOTE_ADDED:
        case tsip_event_invite_type_e.M_STREAM_REMOTE_REMOVED:
	
	    case tsip_event_invite_type_e.M_LOCAL_HOLD_OK:
	    case tsip_event_invite_type_e.M_LOCAL_HOLD_NOK:
	    case tsip_event_invite_type_e.M_LOCAL_RESUME_OK:
	    case tsip_event_invite_type_e.M_LOCAL_RESUME_NOK:
	    case tsip_event_invite_type_e.M_REMOTE_HOLD:
	    case tsip_event_invite_type_e.M_REMOTE_RESUME:

        default: break;
    }
};
@endcode
*/
tsip_stack.prototype.on_event_invite = null;
/**
* Callback function used to report messaging (SIP MESSAGE) session events.
*
@code
o_stack.on_event_message = function (evt: tsip_event_message) {
    tsk_utils_log_info("phrase=" + evt.s_phrase);
    tsk_utils_log_info("sesssion id=%d", evt.get_session().get_id());
    switch (evt.e_message_type) {
        case tsip_event_message_type_e.I_MESSAGE:
        case tsip_event_message_type_e.AO_MESSAGE:
        default: break;
    }
};
@endcode
*/
tsip_stack.prototype.on_event_message = null;

tsip_stack.prototype.on_event_publish = null;
tsip_stack.prototype.on_event_subscribe = null;

/* Parameter type (Internal use) */
var tsip_stack_param_type_e =
{	
	/* === Identity === */
	DISPLAY_NAME : 0,
	IMPU : 1,
	PREFERRED_ID : 2,
	IMPI : 3,
	PASSWORD : 4,
	DIGEST : 5,

	/* === SigComp === */
	SIGCOMP : 10,
	SIGCOMP_ADD_COMPARTMENT : 11,
	SIGCOMP_REMOVE_COMPARTMENT : 12,

	/* === Network === */
	REALM : 20,
	LOCAL_IP : 21,
	LOCAL_PORT : 22,
	AOR : 23,
	DISCOVERY_NAPTR : 24,
	DISCOVERY_DHCP : 25,
	PROXY_CSCF : 26,
	DNSSERVER : 27,
	MODE_SERVER: 28,
	PROXY_OUTBOUND: 30,
	WEBSOCKET_SERVER_URL: 31,
    ICE_SERVERS: 32,
	ENABLE_RTCWEB_BREAKER: 33,
    ENABLE_CLICK2CALL: 34,
    ENABLE_SECURE_TRANSPORT: 35,
	
	/* === Security === */
	EARLY_IMS : 40,
	SECAGREE_IPSEC : 41,
	SECAGREE_TLS : 42,
	AMF : 43,
	OPERATOR_ID : 44,
	TLS_CERTS : 45,
	IPSEC_PARAMS : 46,

	/* === Dummy Headers === */
	HEADER: 50,

	/* Nat Traversal */
	STUN_SERVER : 60,
	STUN_CRED : 61,

    /* === Media === */
	CACHE_MEDIA_STREAM : 70,
    BANDWIDTH: 71,
    VIDEO_SIZE: 72,
    AUDIO_CONSTRAINTS: 73,

	/* === User Data === */
	USERDATA : 80
};

/* Network transport state (Internal use) */
var tsip_transport_state_e =
{
    NONE: -1,

    STARTING: 0,
    STARTED: 1,
    STOPPING: 3,
    STOPPED: 4
};

/**
* Signature: tsip_stack_create(s_realm, s_impi, s_impu_uri, s_proxy_cscf_host, i_proxy_cscf_port, ...set())
* @ctor
* This is the main function (constructor) used to create a SIP/IMS stack and it <b>takes variable arguments</b>.
* @tparam String s_realm the SIP domain name. e.g. 'doubango.org'
* @tparam String s_impi the IMS Private identity. e.g. 'alice'
* @tparam String s_impu_uri the IMS public identity wich must be a valid SIP Uri. e.g. 'sip:alice@doubango.org'
* @tparam String s_proxy_cscf_host the Proxy domain name or IP address. e.g. '192.168.0.1' or 'example.org'.
* @tparam int i_proxy_cscf_port the proxy port.
*
*@code
* var o_stack = new tsip_stack("doubango.org", "alice", "sip:alice@doubango.org", "192.168.0.12", 5062,
    tsip_stack.prototype.SetPassword ("mypassword"),
    tsip_stack.prototype.SetDisplayName("alice"),
    tsip_stack.prototype.SetHeader("User-Agent", "IM-client/OMA1.0 sipML5/v0.0.0000.0"),
    tsip_stack.prototype.SetHeader("Organization", "Doubango Telecom")
);
@endcode
*/
function tsip_stack(s_realm, s_impi, s_impu_uri, s_proxy_cscf_host, i_proxy_cscf_port) {
    if (!s_realm || !s_impi || !s_impu_uri) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }

    var o_uri_impu = tsip_uri.prototype.Parse(s_impu_uri);
    if (!o_uri_impu) {
        tsk_utils_log_error("'" + s_impu_uri + "' is not a valid IMPU Uri");
        return null;
    }

    if (tsk_string_index_of(s_realm, s_realm.length, "sip:") != 0 && tsk_string_index_of(s_realm, s_realm.length, "sips:") != 0){
        s_realm = tsk_string_format("sip:{0}", s_realm);
    }
    var o_uri_realm = tsip_uri.prototype.Parse(s_realm);
    if(!o_uri_realm){
        tsk_utils_log_error("'" + s_realm + "' is not a valid realm");
        return null;
    }

    this.e_state = tsip_transport_state_e.NONE;

    /* === Identity === */
    this.identity = {};
    this.identity.s_display_name = o_uri_impu.s_user_name;
    this.identity.o_uri_impu = o_uri_impu;
    this.identity.o_uri_pref = null;
    this.identity.s_impi = s_impi;
    this.identity.s_password = null;
		this.identity.s_digest = null;

    /* === Network === */
    this.network = {};
    this.network.o_transport = null;
    this.network.s_transport = "ws";
    this.network.s_local_ip = null;
    this.network.i_local_port = 0;
    this.network.s_proxy_cscf_host = s_proxy_cscf_host;
    this.network.i_proxy_cscf_port = i_proxy_cscf_port;
    // IMPORTANT: Safari and Opera support WebSocket but they are using the old version
    this.network.e_proxy_cscf_type = tsk_utils_have_webrtc4all() ? tsip_transport_type_e.UDP : tsip_transport_type_e.WS;
    this.network.o_uri_realm = o_uri_realm;
    this.network.s_proxy_outbound_host = null;
    this.network.i_proxy_outbound_port = 5060;
    this.network.e_proxy_outbound_type = this.network.e_proxy_cscf_type;
    this.network.s_websocket_server_url = null;
    this.network.ao_ice_servers = null;
    this.network.b_rtcweb_enabled = false;
    this.network.b_click2call_enabled = false;

    this.network.aor = {};
    this.network.aor.s_ip = null;
    this.network.aor.i_port = 0;

    /* === Security === */
    this.security = {};
    this.security.b_earlyIMS = true;

    this.security.tls = {};
    this.security.tls.s_ca = null;
    this.security.tls.s_pbk = null;
    this.security.tls.s_pvk = null;

    /* NAT Traversal */
    this.natt = {};
    this.natt.stun = {};
    this.natt.stun.s_ip = null;
    this.natt.stun.i_port = 0;
    this.natt.stun.s_login = null;
    this.natt.stun.s_pwd = null;

    /* Media */
    this.media = {};
    this.media.b_cache_stream = false;
    this.media.o_bandwidth = { audio:undefined, video:undefined };
    this.media.o_video_size = { minWidth:undefined, minHeight:undefined, maxWidth:undefined, maxHeight:undefined };
    this.media.o_audio_constraints = { googEchoCancellation: undefined, googNoiseSuppression: undefined, googAutoGainControl: undefined };

    /* Internals */
    this.o_timers = new tsip_timers();
    this.ao_sessions = new Array();
    this.ao_headers = new Array();
    this.o_usr_data = null;

    this.ao_uri_paths = new Array();
    this.ao_uri_service_routes = new Array();
    this.ao_uri_associated_uris = new Array();

    /* Layers */
    this.o_layer_dialog = new tsip_dialog_layer(this);
    this.o_layer_transac = new tsip_transac_layer(this);
    this.o_layer_transport = new tsip_transport_layer(this);

    this.__set(Array.prototype.slice.call(arguments, 5));
}

/**
* Starts the SIP stack. This function must be the first one to be called. This function is asynchronous which means that the stack will not be immediately started after the call.
* To get feedbacks about the status (success or error), you must subscribe to @ref on_event_stack.
* @treturn int 0 if succeed and non-zero value otherwise
*/
tsip_stack.prototype.start = function () {
    
    if (this.e_state == tsip_transport_state_e.STARTED) {
        tsk_utils_log_warn("Already started");
        return 0;
    }
    else if (this.e_state == tsip_transport_state_e.STARTING) {
        this.stop();
    }

    if (!this.network.s_proxy_cscf_host) {
        tsk_utils_log_error("'" + this.network.s_proxy_cscf_host + "' not valid as proxy host");
        return -2;
    }

    tsk_utils_log_info("SIP stack start: proxy='" + this.network.s_proxy_cscf_host + ":" + this.network.i_proxy_cscf_port + "', realm='" + this.network.o_uri_realm + "', impi='" + this.identity.s_impi + "', impu='" + this.identity.o_uri_impu + "'");

    this.network.o_transport = this.o_layer_transport.transport_new(this.network.e_proxy_cscf_type, this.network.s_proxy_cscf_host, this.network.i_proxy_cscf_port, "SIP Transport", __tsip_stack_transport_callback);
    if (!this.network.o_transport) {
        tsk_utils_log_error("Failed to create transport with type= " + this.network.e_proxy_cscf_type);
        return -2;
    }

    this.e_state = tsip_transport_state_e.STARTING;
    this.signal(tsip_event_code_e.STACK_STARTING, "Stack starting");
    return this.network.o_transport.start();
}

/**
* Stops the SIP stack. Feedbacks will be reported to @ref on_event_stack callback function
* @tparam int i_timeout Optional parameter used to defined maximum time in milliseconds to take to stop the stack. 
* Default value: 2000 millis
* @treturn int 0 if succeed and non-zero value otherwise
*/
tsip_stack.prototype.stop = function (i_timeout) {
    var This = this;
    setTimeout(function () {
        switch (This.e_state) {
            case tsip_transport_state_e.STOPPED:
            case tsip_transport_state_e.STOPPING:
            case tsip_transport_state_e.NONE:
                return 0;
            default:
                break;
        }

        if (typeof i_timeout == "undefined") {
            i_timeout = tsip_dialog.prototype.__i_timer_shutdown;
        }

        var i_register_dialogs_count = 0;
        var b_has_non_register_dialogs = false;
        var b_register_shutdown_sent = false;
        var i_ret;
        var i_timeout_non_register = (i_timeout << 1) / 3;
        var o_date_start = o_date_start = new Date();

        // shutdown all non-REGISTER dialogs
        for (var i = 0; i < This.o_layer_dialog.ao_dialogs.length; ++i) {
            if (This.o_layer_dialog.ao_dialogs[i].e_type == tsip_dialog_type_e.REGISTER) {
                ++i_register_dialogs_count;
                continue;
            }
            if ((i_ret = This.o_layer_dialog.ao_dialogs[i].shutdown()) == 0) {
                b_has_non_register_dialogs = true;
            }
        }

        var func_shutdown_non_register = function () {
            if (b_has_non_register_dialogs) {
                do {
                    if ((This.o_layer_dialog.ao_dialogs.length <= i_register_dialogs_count)) {
                        setTimeout(func_shutdown_register, 1); // success: move to next
                        return;
                    }
                    if ((new Date() - o_date_start) >= i_timeout_non_register) {
                        setTimeout(func_shutdown_register, 1); // timeout: move to next
                        return;
                    }
                }
                while (false);
            }

            setTimeout(func_shutdown_non_register, 1); // again
        }

        var func_shutdown_register = function () {
            // shutdown all REGISTER dialogs
            if (!b_register_shutdown_sent) {
                if (i_register_dialogs_count > 0) {
                    i_register_dialogs_count = 0;
                    for (var i = 0; i < This.o_layer_dialog.ao_dialogs.length; ++i) {
                        if (This.o_layer_dialog.ao_dialogs[i].e_type == tsip_dialog_type_e.REGISTER) {
                            if ((i_ret = This.o_layer_dialog.ao_dialogs[i].shutdown()) == 0) {
                                ++i_register_dialogs_count;
                            }
                        }
                    }
                }
                b_register_shutdown_sent = true;
            }

            do {
                if (This.o_layer_dialog.ao_dialogs.length == 0 || (new Date() - o_date_start) >= i_timeout) {
                    setTimeout(func_shutdown_transport, 1); // timeout/no-dialog-left: move to next
                    return;
                }
            }
            while (false);

            setTimeout(func_shutdown_register, 1); // again
        }

        var func_shutdown_transport = function () {
            if (This.o_layer_transport) {
                This.o_layer_transport.stop();
            }

            This.signal(tsip_event_code_e.STACK_STOPPED, "Stack stopped");
        }


        // Execute
        if (b_has_non_register_dialogs) {
            func_shutdown_non_register();
        }
        else if (i_register_dialogs_count) {
            func_shutdown_register();
        }
        else {
            func_shutdown_transport();
        }

    }, 1);

    return 0;
}

/**
* Sets static parameters.
* The function takes parameters created using static functions @b tsip_stack.prototype.Set*
* @sa @ref SetDisplayName
*/
tsip_stack.prototype.set = function () {
    return this.__set(arguments);
}

/**
* Sets SIP Display Name
* @tparam String s_display_name New SIP Display Name value
* @treturn Object Parameter object
*
@code
o_stack.set(tsip_stack.prototype.SetDisplayName('alice'));
@endcode
*/
tsip_stack.prototype.SetDisplayName = function (s_display_name) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.DISPLAY_NAME, s_display_name);
}

/**
* Sets SIP password for authentication
* @tparam String s_password SIP password for authentication
* @treturn Object Parameter object
*
@code
o_stack.set(tsip_stack.prototype.SetPassword('mysecret'));
@endcode
*/
tsip_stack.prototype.SetPassword = function (s_password) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.PASSWORD, s_password);
}

tsip_stack.prototype.SetDigest = function (s_digest) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.DIGEST, s_digest);
}


/**
* Updates SIP Proxy host, port and type. Using version 1.0 of sipML5 only WebSocket type is supported.
* @tparam String s_proxy_host Proxy IP address or hostname
* @tparam int i_proxy_port Proxy port
* @tparam tsip_transport_type_e e_proxy_type Network type. For now only @b WS and @b WSS are supported.
* @treturn Object Parameter object
*
@code
o_stack.set(tsip_stack.prototype.SetProxyCSCF("192.168.0.10", 5060, tsip_transport_type_e.UDP));
@endcode
*/
tsip_stack.prototype.SetProxyCSCF = function (s_proxy_host, i_proxy_port, e_proxy_type) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.PROXY_CSCF, s_proxy_host, i_proxy_port, e_proxy_type);
}

/**
* Static parameter function used to set the SIP outbound proxy. This function is only needed if there is no DNS entries for the @b realm defined in the SIP stack creation.
* @tparam String s_proxy_host Outbound proxy host IP address or domain name. e.g. '192.168.0.10' or 'example.com'
* @tparam int i_proxy_port Outbound proxy port. e.g. 5060
* @tparam tsip_transport_type_e e_proxy_type Transport protocol type
*
@code
var o_stack = new tsip_stack("doubango.org", "alice", "sip:alice@doubango.org", "192.168.0.12", 5062,
tsip_stack.prototype.SetProxyOutBound("192.168.0.10", 5060, tsip_transport_type_e.UDP)
tsip_stack.prototype.SetPassword ("mypassword"),
tsip_stack.prototype.SetDisplayName("alice"),
tsip_stack.prototype.SetHeader("User-Agent", "IM-client/OMA1.0 sipML5/v0.0.0000.0"),
tsip_stack.prototype.SetHeader("Organization", "Doubango Telecom")
);
// or
o_stack.set(tsip_stack.prototype.SetProxyOutBound("192.168.0.10", 5060, tsip_transport_type_e.UDP));
@endcode
@sa @ref SetWebsocketServerUrl
*/
tsip_stack.prototype.SetProxyOutBound = function (s_proxy_host, i_proxy_port, e_proxy_type) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.PROXY_OUTBOUND, s_proxy_host, i_proxy_port, e_proxy_type);
}

/**
* Static parameter function used to set the SIP outbound proxy url.
@code
var o_stack = new tsip_stack("doubango.org", "alice", "sip:alice@doubango.org", "192.168.0.12", 5062,
tsip_stack.prototype.SetProxyOutBoundUrl("udp://192.168.0.12:5060"),
tsip_stack.prototype.SetPassword ("mypassword"),
tsip_stack.prototype.SetDisplayName("alice"),
tsip_stack.prototype.SetHeader("User-Agent", "IM-client/OMA1.0 sipML5/v0.0.0000.0"),
tsip_stack.prototype.SetHeader("Organization", "Doubango Telecom")
);
// or
o_stack.set(tsip_stack.prototype.SetProxyOutBoundUrl("udp://192.168.0.12:5060"));
@endcode
@sa @ref SetProxyOutBound
*/
tsip_stack.prototype.SetProxyOutBoundUrl = function (s_url) {
    if (!s_url) {
        // restore default values
        return tsip_stack.prototype.SetProxyOutBound(null, 5060, tsip_transport_type_e.UDP);
    }

    var ao_params = tsk_string_parse_url(s_url);
    if (!ao_params || ao_params.length < 3) {
        tsk_utils_log_error(s_url + " not valid as outbound proxy url");
        return null;
    }

    var e_tranport;
    switch (ao_params[0]) {
        case "udp": default: e_tranport = tsip_transport_type_e.UDP; break;
        case "tcp": e_tranport = tsip_transport_type_e.TCP; break;
        case "tls": e_tranport = tsip_transport_type_e.TLS; break;
        case "dtls": e_tranport = tsip_transport_type_e.DTLS; break;
        case "sctp": e_tranport = tsip_transport_type_e.SCTP; break;
        case "ws": e_tranport = tsip_transport_type_e.WS; break;
        case "wss": e_tranport = tsip_transport_type_e.WSS; break;
    }
    return tsip_stack.prototype.SetProxyOutBound(ao_params[1], ao_params[2], e_tranport);
}

tsip_stack.prototype.SetWebsocketServerUrl = function (s_websocket_server_url) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.WEBSOCKET_SERVER_URL, s_websocket_server_url);
}

// x_ice_server_urls : 'string' or 'array'
tsip_stack.prototype.SetIceServers = function (x_ice_server_urls) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.ICE_SERVERS, x_ice_server_urls);
}

tsip_stack.prototype.SetMediaStreamCacheEnabled = function (b_cache_media_stream) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.CACHE_MEDIA_STREAM, b_cache_media_stream);
}

tsip_stack.prototype.SetBandwidth = function (o_bandwidth) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.BANDWIDTH, o_bandwidth);
}

tsip_stack.prototype.SetVideoSize = function (o_video_size) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.VIDEO_SIZE, o_video_size);
}

tsip_stack.prototype.SetAudioConstraints = function (o_audio_constraints) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.AUDIO_CONSTRAINTS, o_audio_constraints);
}

tsip_stack.prototype.SetRTCWebBreakerEnabled = function (b_enabled) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.ENABLE_RTCWEB_BREAKER, b_enabled);
}

tsip_stack.prototype.SetClick2CallEnabled = function (b_enabled) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.ENABLE_CLICK2CALL, b_enabled);
}

tsip_stack.prototype.SetSecureTransportEnabled = function (b_enabled) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.ENABLE_SECURE_TRANSPORT, b_enabled);
}

/**
* Whether to enable EarlyIMS (3GPP TR 33.978).
*/
tsip_stack.prototype.SetEarlyIMSEnabled = function (b_enabled) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.EARLY_IMS, b_enabled);
}




/**
* Adds SIP header to all sessions created using this stack
* @tparam String s_name SIP header name
* @tparam String s_value SIP valaue
* @treturn Object Parameter object
*
@code
o_stack.set(
    tsip_stack.prototype.SetHeader('User-Agent', 'sipML5 client'),
    tsip_stack.prototype.SetHeader('Organization', 'Doubango Telecom')
);
@endcode
*/
tsip_stack.prototype.SetHeader = function(s_name, s_value) {
    return tsip_stack.prototype.SetAny(tsip_stack_param_type_e.HEADER, s_name, s_value);
}

/*
* Internal function used to set any parameter
*/
tsip_stack.prototype.__set = function (ao_params) {
    var o_curr;
    for (var i = 0; i < ao_params.length; ++i) {
        o_curr = ao_params[i];
        if (!o_curr) {
            continue;
        }

        switch (o_curr.e_type) {

            /* === Identity === */ 
            case tsip_stack_param_type_e.DISPLAY_NAME:
                {
                    this.identity.s_display_name = o_curr.ao_values[0];
                    if(this.identity.o_uri_impu){
                        this.identity.o_uri_impu.s_display_name = this.identity.s_display_name;
                    }
                    break;
                }
            case tsip_stack_param_type_e.PASSWORD:
                {
                    this.identity.s_password = o_curr.ao_values[0];
                    break;
                }
            case tsip_stack_param_type_e.DIGEST:
                {
                    this.identity.s_digest = o_curr.ao_values[0];
                    break;
                }


                /* === Network === */
            case tsip_stack_param_type_e.PROXY_CSCF:
                {
                    this.network.s_proxy_cscf_host = o_curr.ao_values[0];
                    this.network.i_proxy_cscf_port = o_curr.ao_values[1];
                    this.network.e_proxy_cscf_type = o_curr.ao_values[2];
                    break;
                }
            case tsip_stack_param_type_e.PROXY_OUTBOUND:
                {
                    this.network.s_proxy_outbound_host = o_curr.ao_values[0];
                    this.network.i_proxy_outbound_port = o_curr.ao_values[1];
                    this.network.e_proxy_outbound_type = o_curr.ao_values[2];
                    break;
                }
            case tsip_stack_param_type_e.WEBSOCKET_SERVER_URL:
                {
                    // e.g. wss://192.168.0.10:5060/myurl
                    this.network.s_websocket_server_url = o_curr.ao_values[0];
                    // the default transport is WS and must be changed if the user provides it's own url
                    if (this.network.s_websocket_server_url) {
                        if (this.network.s_websocket_server_url.indexOf("wss://") == 0) {
                            this.network.e_proxy_cscf_type = tsip_transport_type_e.WSS;
                        }
                        else if (this.network.s_websocket_server_url.indexOf("ws://") == 0) {
                            this.network.e_proxy_cscf_type = tsip_transport_type_e.WS;
                        }
                    }
                    break;
                }
            case tsip_stack_param_type_e.ICE_SERVERS:
                {
                    if(!tsk_string_is_null_or_empty(o_curr.ao_values[0])){
                        try{
                            if (o_curr.ao_values[0] instanceof String || typeof o_curr.ao_values[0] == "string") {
                                eval("this.network.ao_ice_servers = " + o_curr.ao_values[0] + ";");
                            }
                            else if(o_curr.ao_values[0] instanceof Array || typeof o_curr.ao_values[0] == "array"){
                                this.network.ao_ice_servers = o_curr.ao_values[0];
                            }
                            else{
                                tsk_utils_log_warn(o_curr.ao_values[0] + " not valid as ICE servers");
                            }
                        }
                        catch(e){
                            tsk_utils_log_error('Failed to set ICE servers:' + e);
                        }
                    }
                    
                    break;
                }
            case tsip_stack_param_type_e.ENABLE_RTCWEB_BREAKER:
                {
                    this.network.b_rtcweb_enabled = !!o_curr.ao_values[0];
                    break;
                }
            case tsip_stack_param_type_e.ENABLE_CLICK2CALL:
                {
                    this.network.b_click2call_enabled = !!o_curr.ao_values[0];
                    break;
                }

            case tsip_stack_param_type_e.ENABLE_SECURE_TRANSPORT:
                {
                    if (o_curr.ao_values[0] && this.network.e_proxy_cscf_type == tsip_transport_type_e.WS) {
                        this.network.e_proxy_cscf_type = tsip_transport_type_e.WSS;
                    }
                    break;
                }


                /* === Security === */
            case tsip_stack_param_type_e.EARLY_IMS:
                {
                    this.security.b_earlyIMS = !!o_curr.ao_values[0];
                    break;
                }

                /* === Media === */
            case tsip_stack_param_type_e.CACHE_MEDIA_STREAM:
                {
                    this.media.b_cache_stream = !!o_curr.ao_values[0];
                    break;
                }
            case tsip_stack_param_type_e.BANDWIDTH:
                {
                    this.media.o_bandwidth = o_curr.ao_values[0];
                    break;
                }
            case tsip_stack_param_type_e.VIDEO_SIZE:
                {  
                    this.media.o_video_size = o_curr.ao_values[0];
                    break;
                }
             case tsip_stack_param_type_e.AUDIO_CONSTRAINTS:
                {  
                    this.media.o_audio_constraints = o_curr.ao_values[0];
                    break;
                }

                /* === Dummy Headers === */
            case tsip_stack_param_type_e.HEADER:
                {
                    if (o_curr.ao_values[1]) { // add
                        this.ao_headers.push(new tsip_header_Dummy(o_curr.ao_values[0], o_curr.ao_values[1]));
                    }
                    else { // remove
                        var i_index = tsip_header.prototype.IndexOfByName(this.ao_headers, o_curr.ao_values[0]);
                        if (i_index != -1) {
                            this.ao_headers.splice(i_index, 1);
                        }
                    }
                    break;
                }
        }

    }
    return 0;
}

/*
* Internal function
*/
tsip_stack.prototype.__get_contact_uri = function (s_protocol) {
    for (var i = 0; i < this.o_layer_transport.ao_transports.length; ++i) {
        var o_uri = this.o_layer_transport.ao_transports[i].get_uri(false);
        if (o_uri) {
            o_uri.s_user_name = this.identity.o_uri_impu.s_user_name;
            return o_uri;
        }
    }
    return null;
}

/*
* Internal function
*/
tsip_stack.prototype.__get_proxy_outbound_uri_string = function () {
    if (this.network.s_proxy_outbound_host) {
        var s_tansport;
        switch (this.network.e_proxy_outbound_type) {
            case tsip_transport_type_e.TCP: s_tansport= "tcp"; break;
            case tsip_transport_type_e.TLS: s_tansport= "tls"; break;
            case tsip_transport_type_e.SCTP: s_tansport= "sctp"; break;
            case tsip_transport_type_e.DTLS: s_tansport= "dtls"; break;
            case tsip_transport_type_e.WS: s_tansport= "ws"; break;
            case tsip_transport_type_e.WSS: s_tansport= "wss"; break;
            case tsip_transport_type_e.UDP: default: s_tansport= "udp"; break;
        }
        return tsk_string_format("<sip:{0}:{1};lr;sipml5-outbound;transport={2}>", this.network.s_proxy_outbound_host, this.network.i_proxy_outbound_port, s_tansport);
    }
    return null;
}

/*
* Internal function
*/
tsip_stack.prototype.SetAny = function(e_type){
    var obj = new Object();
    obj.e_type = e_type;
    obj.ao_values = Array.prototype.slice.call(arguments, 1);
    return obj;
}

/*
* Internal function
*/
tsip_stack.prototype.signal = function (i_code, s_phrase) {
    if (this.on_event_stack) {
        var on_event = this.on_event_stack;
        var o_event = new tsip_event(null, i_code, s_phrase, null, tsip_event_type_e.STACK);
        o_event.o_stack = this;
        setTimeout(function () { on_event(o_event) }, 1);
    }
    return 0;
}

/*
* Internal function
*/
function __tsip_stack_transport_callback(evt) {
    var o_stack = evt.o_transport.o_stack;

    switch (evt.e_type) {
        case tsip_transport_event_type_e.STARTED:
            {
                o_stack.e_state = tsip_transport_state_e.STARTED;
                o_stack.signal(tsip_event_code_e.STACK_STARTED, "Stack started");
                break;
            }

        case tsip_transport_event_type_e.STOPPED:
            {
                if (o_stack.e_state == tsip_transport_state_e.STARTING) {
                    o_stack.signal(tsip_event_code_e.STACK_FAILED_TO_START, "Failed to connet to the server");
                }
                else {
                    o_stack.signal(tsip_event_code_e.STACK_STOPPED, "Stack stopped");
                }
                o_stack.e_state = tsip_transport_state_e.STOPPED;
                o_stack.o_layer_transport.transport_remove(evt.o_transport);
                break;
            }

        case tsip_transport_event_type_e.ERROR:
            {
                break;
            }
    }
        
    return 0;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_timers.prototype.TIMER_T1 = 500;
tsip_timers.prototype.TIMER_T4 = 5000;

var tsip_timers_e =
{
    T1: tsip_timers.prototype.TIMER_T1,
    T2: 4000,
    T4: tsip_timers.prototype.TIMER_T4,
    A: tsip_timers.prototype.TIMER_T1,
    B: 64 * tsip_timers.prototype.TIMER_T1,
    C: 5*60000,
    D: 50000,
    E: tsip_timers.prototype.TIMER_T1,
    F: 64 * tsip_timers.prototype.TIMER_T1,
    G: tsip_timers.prototype.TIMER_T1,
    H: 64 * tsip_timers.prototype.TIMER_T1,
    I: tsip_timers.prototype.TIMER_T4,
    J: 64 * tsip_timers.prototype.TIMER_T1,
    K: tsip_timers.prototype.TIMER_T4,
    L: 64 * tsip_timers.prototype.TIMER_T1,
    M: 64 * tsip_timers.prototype.TIMER_T1
};

function tsip_timers() {
    this.T1 = tsip_timers_e.T1;
    this.T2 = tsip_timers_e.T2;
    this.T4 = tsip_timers_e.T4;
    this.A = tsip_timers_e.A;
    this.B = tsip_timers_e.B;
    this.C = tsip_timers_e.C;
    this.D = tsip_timers_e.D;
    this.E = tsip_timers_e.E;
    this.F = tsip_timers_e.F;
    this.G = tsip_timers_e.G;
    this.H = tsip_timers_e.H;
    this.I = tsip_timers_e.I;
    this.J = tsip_timers_e.J;
    this.K = tsip_timers_e.K;
    this.L = tsip_timers_e.L;
    this.M = tsip_timers_e.M;
}

tsip_timers.prototype.getA = function () { return this.A; }
tsip_timers.prototype.getB = function () { return this.B; }
tsip_timers.prototype.getC = function () { return this.C; }
tsip_timers.prototype.getD = function () { return this.D; }
tsip_timers.prototype.getE = function () { return this.E; }
tsip_timers.prototype.getF = function () { return this.F; }
tsip_timers.prototype.getG = function () { return this.G; }
tsip_timers.prototype.getH = function () { return this.H; }
tsip_timers.prototype.getI = function () { return this.I; }
tsip_timers.prototype.getJ = function () { return this.J; }
tsip_timers.prototype.getK = function () { return this.K; }
tsip_timers.prototype.getL = function () { return this.L; }
tsip_timers.prototype.getM = function () { return this.M; }
tsip_timers.prototype.getT1 = function () { return this.T1; }
tsip_timers.prototype.getT2 = function () { return this.T2; }
tsip_timers.prototype.getT4 = function () { return this.T4; }

tsip_timers.prototype.setT1 = function(i_t1){
	this.T1 = i_t1;
	this.A = this.E = this.G = this.T1;
	this.B = this.F = this.H = this.J = (this.T1*64);
}

tsip_timers.prototype.setT2 = function(i_t2){
	this.T2 = i_t2;
}

tsip_timers.prototype.setT4 = function(i_t4){
	this.T4 = i_t4;
	this.I = this.K = this.T4;
}

tsip_timers.prototype.setA = function(i_a){
	 this.A = i_a;
}

tsip_timers.prototype.setB = function(i_b){
    if(this){
	    this.B = i_b;
    }
}

tsip_timers.prototype.setC = function(i_c){
    this.C = i_c;
}

tsip_timers.prototype.setD = function(i_d){
    this.D = i_d;
}

tsip_timers.prototype.setE = function(i_e){
    this.E = i_e;
}

tsip_timers.prototype.setF = function(i_f){
    this.F = i_f;
}

tsip_timers.prototype.setG = function(i_g){
    this.G = i_g;
}

function tsip_timers_setH(i_h){
    this.H = i_h;
}

tsip_timers.prototype.setI = function(i_i){
    this.I = i_i;
}

tsip_timers.prototype.setJ = function(i_j){
    this.J = i_j;
}

tsip_timers.prototype.setK = function(i_k){
    this.K = i_k;
}

tsip_timers.prototype.setL = function(i_l){
    this.L = i_l;
}

tsip_timers.prototype.setM = function(i_m){
    this.M = i_m;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var tsip_uri_type_e =
{
    unknown: { i_id: 0, s_scheme: "unknown" },
    sip: { i_id: 1, s_scheme: "sip" },
    sips: { i_id: 2, s_scheme: "sips" },
    tel: { i_id: 3, s_scheme: "tel" }
};

var tsip_host_type_e =
{
    unknown: { i_id: 0, s_name: "unknown" },
    hostname: { i_id: 1, s_name: "hostname" },
    ipv4: { i_id: 2, s_name: "ipv4" },
    ipv6: { i_id: 3, s_name: "ipv6" }
};

function tsip_uri(e_type) {
    this.e_type = e_type;
    this.s_scheme = null;
    this.s_host = null;
    this.e_host_type = tsip_host_type_e.unknown;
    this.i_port = 0;
    this.s_user_name = null;
    this.s_password = null;
    this.s_display_name = null;
    this.ao_params = new Array();
    this.toString = function () {
        return tsip_uri_tostring(this, true, true);
    };
}

tsip_uri.prototype.tostring = function(b_with_params, b_quote){
    return tsip_uri_tostring(this, b_with_params, b_quote);
}

tsip_uri.prototype.compare = function (o_uri) {
    var s_str = tsip_uri_compare(this, o_uri);
}

tsip_uri.prototype.clone = function (b_with_params, b_quote) {
    var s_str = tsip_uri_tostring(this, b_with_params, b_quote);
    if (s_str) {
        return tsip_uri.prototype.Parse(s_str);
    }
    return null;
}

function tsip_uri_make_valid(s_uri, s_domain) {
    if (!s_uri || !s_domain) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    if (tsk_string_index_of(s_uri, s_uri.length, "\"") == 0 || tsk_string_index_of(s_uri, s_uri.length, "<") == 0) {
        return tsip_uri.prototype.Parse(s_uri);
    }
    var b_teluri = (tsk_string_index_of(s_uri, s_uri.length, "tel:") == 0);
    if (tsk_string_index_of(s_uri, s_uri.length, "sip:") != 0 && tsk_string_index_of(s_uri, s_uri.length, "sips:") != 0 && !b_teluri) {
        s_uri = "sip:" + s_uri;
    }
    if (!b_teluri && tsk_string_index_of(s_uri, s_uri.length, "@") == -1) { /* no domain name in tel: uri */
        s_uri += "@" + s_domain;
    }
    return tsip_uri.prototype.Parse(s_uri); 
}

function __tsip_uri_tostring(o_self, b_with_params) {
	// e.g. sip:alice:secretword@atlanta.com:65535
	var s_uri = tsk_string_format("{0}:{1}{2}{3}{4}{5}{6}{7}{8}{9}", 

		o_self.s_scheme ? o_self.s_scheme : "sip", /* default scheme is sip: */

		o_self.s_user_name ? o_self.s_user_name : "",

		o_self.s_password ? ":" : "",
		o_self.s_password ? o_self.s_password : "",

		o_self.s_host ? (o_self.s_user_name ? "@" : "") : "",
		o_self.e_host_type == tsip_host_type_e.ipv6 ? "[" : "",
		o_self.s_host ? o_self.s_host : "",
		o_self.e_host_type == tsip_host_type_e.ipv6 ? "]" : "",

		o_self.i_port > 0 ? ":" : "",
		o_self.i_port > 0 ? o_self.i_port : ""
		);
	
	// Params
	if (s_uri && b_with_params && o_self.ao_params.length > 0) {
        s_uri += tsk_string_format(";{0}", tsk_params_tostring(o_self.ao_params, ';'));
    }
	
	return s_uri;
}


function tsip_uri_tostring(o_self, b_with_params, b_quote){
	if(o_self){
	    if (b_quote) {
	        var s_str = "";
			if(o_self.s_display_name){
                s_str += tsk_string_format("\"{0}\"", o_self.s_display_name);
			}
            s_str += tsk_string_format("<{0}>", __tsip_uri_tostring(o_self, b_with_params));
            return s_str;
		}
		else{
		    return __tsip_uri_tostring(o_self, b_with_params);
		}
	}
	else{
		tsk_utils_log_error("Invalid argument");
		return null;
	}
}

function tsip_uri_strcmp(s_s1, s_s2, b_case_sensitive){
	if(s_s1 && s_s2){
		var b_s1_is_encoded = false;
		var b_s2_is_encoded = false;

		if(tsk_string_contains(s_s1, s_s1.length, "%")){
			b_s1_is_encoded = true;
			s_s1 = decodeURIComponent(s_s1);
		}
		if(tsk_string_contains(s_s2, s_s2.length, "%")){
			b_s2_is_encoded = true;
			s_s2 = decodeURIComponent(s_s2);
		}

		return b_case_sensitive ? s_s1.localeCompare(s_s2) : s_s1.toLowerCase().localeCompare(s_s2.toLowerCase());
	}
	return -1;
}

function tsip_uri_strequals(s_s1, s_s2) { return (tsip_uri_strcmp(s_s1, s_s2, true) == 0); }
function tsip_uri_striequals(s_s1, s_s2) { return (tsip_uri_strcmp(s_s1, s_s2, false) == 0);}

function tsip_uri_compare_parameter(o_uri_1, o_uri_2, s_pname){
    var o_param_1 = tsk_param_get_by_name(o_uri_1.ao_params, s_pname);
	var o_param_2 = tsk_param_get_by_name(o_uri_2.ao_params, s_pname);
	if((o_param_1 || o_param_2) && ((o_param_1 && !o_param_2) || (!o_param_1 && o_param_2) || (!tsip_uri_striequals(o_param_1.s_value, o_param_2.s_value)))){
		return -3;
	}
    return 0;
}

function tsip_uri_compare(o_uri_1, o_uri_2){
	if(o_uri_1 && o_uri_2){
		var o_param_1;
		var o_param_2;
        var i_ret;

		/* RFC 3261 - 19.1.4 URI Comparison

			Comparison of the userinfo of SIP and SIPS URIs is case-sensitive.  This includes userinfo containing passwords or
			formatted as telephone-subscribers.  Comparison of all other components of the URI is case-insensitive unless explicitly
			defined otherwise.

			An IP address that is the result of a DNS lookup of a host name does not match that host name.

			For two URIs to be equal, the user, password, host, and port components must match.

			A URI omitting the user component will not match a URI that includes one.  A URI omitting the password component will not
			match a URI that includes one.

			userinfo	= 	( user   /   telephone-subscriber )   [ ":" password ]   "@" 
		*/
		if(!tsk_string_equals(o_uri_1.s_scheme, o_uri_2.s_scheme) ||
			!tsip_uri_strequals(o_uri_1.s_user_name, o_uri_2.s_user_name) ||
			!tsip_uri_strequals(o_uri_1.s_host, o_uri_2.s_host) ||
			!tsk_string_equals(o_uri_1.s_password, o_uri_2.s_password) ||
			o_uri_1.i_port != o_uri_2.i_port){
				return -2;
		}

		/* Is there parameters */
		if((!o_uri_1.ao_params && !o_uri_2.ao_params) || (o_uri_1.ao_params.length == 0 && o_uri_2.ao_params.length == 0)){
			return 0;
		}

		/*	RFC 3261 - 19.1.4 URI Comparison
			
			A URI omitting any component with a default value will not match a URI explicitly containing that component with its
			default value.  For instance, a URI omitting the optional port component will not match a URI explicitly declaring port 5060.
			The same is true for the transport-parameter, ttl-parameter, user-parameter, and method components.

			-  A user, ttl, or method uri-parameter appearing in only one URI never matches, even if it contains the default value.
			-  A URI that includes an maddr parameter will not match a URI that contains no maddr parameter.
		*/
        if((i_ret = tsip_uri_compare_parameter(o_uri_1, o_uri_2, "transport")) != 0){
            return i_ret;
        }
        if((i_ret = tsip_uri_compare_parameter(o_uri_1, o_uri_2, "ttl")) != 0){
            return i_ret;
        }
        if((i_ret = tsip_uri_compare_parameter(o_uri_1, o_uri_2, "user")) != 0){
            return i_ret;
        }
        if((i_ret = tsip_uri_compare_parameter(o_uri_1, o_uri_2, "method")) != 0){
            return i_ret;
        }
        if((i_ret = tsip_uri_compare_parameter(o_uri_1, o_uri_2, "maddr")) != 0){
            return i_ret;
        }

		/*	RFC 3261 - 19.1.4 URI Comparison
			
			URI uri-parameter components are compared as follows:

			1 -  Any uri-parameter appearing in both URIs must match.
			2 -  All other uri-parameters appearing in only one URI are ignored when comparing the URIs.

			o  URI header components are never ignored.  Any present header component MUST be present in both URIs and match for the URIs
			to match.  The matching rules are defined for each header field in Section 20.
		*/
		for(var i = 0; i < o_uri_1.ao_params.length; ++i){
			o_param_1 = o_uri_1.ao_params[i];
			if((o_param_2 = tsk_param_get_by_name(o_uri_2.ao_params, o_param_1.s_name))){
				if(!tsip_uri_striequals(o_param_1.s_value, o_param_2.s_value)){
					return -4;
				}
			}
		}
        for(var i = 0; i < o_uri_2.ao_params.length; ++i){
			o_param_2 = o_uri_2.ao_params[i];
			if((o_param_1 = tsk_param_get_by_name(o_uri_1.ao_params, o_param_2.s_name))){
				if(!tsip_uri_striequals(o_param_1.s_value, o_param_2.s_value)){
					return -4;
				}
			}
		}
		return 0;
	}
	else{
		return (!o_uri_1 && !o_uri_2) ? 0 : -1;
	}
}

if(!window.__b_release_mode){
    tsip_api_add_js_scripts('head',
    'src/tinySIP/src/parsers/tsip_parser_uri.js'
    );
}

/* line 1 "./ragel/tsip_parser_uri.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

/* line 110 "./ragel/tsip_parser_uri.jrl" */



/* line 14 "./src/parsers/tsip_parser_uri.js" */
_tsip_machine_parser_uri_actions = [
	0, 1, 0, 1, 5, 1, 7, 1, 
	9, 1, 11, 1, 12, 1, 13, 1, 
	14, 1, 17, 1, 18, 1, 20, 1, 
	21, 1, 22, 1, 23, 2, 1, 15, 
	2, 2, 15, 2, 4, 6, 2, 7, 
	10, 2, 7, 16, 2, 8, 10, 2, 
	9, 16, 2, 9, 19, 2, 13, 0, 
	2, 13, 6, 3, 0, 8, 10, 3, 
	13, 0, 6, 3, 13, 3, 0
];

_tsip_machine_parser_uri_key_offsets = [
	0, 0, 7, 15, 22, 28, 34, 40, 
	53, 66, 72, 78, 80, 93, 99, 105, 
	118, 124, 130, 143, 156, 162, 168, 182, 
	196, 202, 208, 229, 231, 247, 262, 278, 
	292, 300, 306, 320, 336, 350, 366, 380, 
	388, 396, 404, 420, 436, 452, 468, 484, 
	500, 506, 508, 525, 540, 554, 568, 582, 
	592, 602, 613, 613, 622, 622, 632, 642, 
	651, 654, 669, 683, 698, 714, 730, 746, 
	750, 765, 782, 788, 795, 801, 808, 814, 
	821, 828, 831, 838, 841, 848, 851, 868, 
	885, 901, 917, 933, 949, 953, 967, 984, 
	1001, 1018, 1024, 1031, 1038, 1041, 1044
];

_tsip_machine_parser_uri_trans_keys = [
	45, 48, 57, 65, 90, 97, 122, 45, 
	46, 48, 57, 65, 90, 97, 122, 45, 
	48, 57, 65, 90, 97, 122, 48, 57, 
	65, 90, 97, 122, 48, 57, 65, 70, 
	97, 102, 48, 57, 65, 70, 97, 102, 
	33, 37, 93, 95, 126, 36, 43, 45, 
	58, 65, 91, 97, 122, 33, 37, 93, 
	95, 126, 36, 43, 45, 58, 65, 91, 
	97, 122, 48, 57, 65, 70, 97, 102, 
	48, 57, 65, 70, 97, 102, 0, 65535, 
	33, 37, 93, 95, 126, 36, 43, 45, 
	58, 65, 91, 97, 122, 48, 57, 65, 
	70, 97, 102, 48, 57, 65, 70, 97, 
	102, 33, 37, 93, 95, 126, 36, 43, 
	45, 58, 65, 91, 97, 122, 48, 57, 
	65, 70, 97, 102, 48, 57, 65, 70, 
	97, 102, 33, 37, 59, 61, 63, 95, 
	126, 35, 57, 65, 90, 97, 122, 33, 
	37, 58, 61, 64, 95, 126, 35, 59, 
	63, 90, 97, 122, 48, 57, 65, 70, 
	97, 102, 48, 57, 65, 70, 97, 102, 
	33, 37, 61, 64, 95, 126, 36, 46, 
	48, 57, 65, 90, 97, 122, 33, 37, 
	61, 64, 95, 126, 36, 46, 48, 57, 
	65, 90, 97, 122, 48, 57, 65, 70, 
	97, 102, 48, 57, 65, 70, 97, 102, 
	58, 59, 83, 84, 91, 115, 116, 0, 
	47, 48, 57, 60, 64, 65, 90, 92, 
	96, 97, 122, 123, 65535, 0, 65535, 45, 
	46, 0, 47, 48, 57, 58, 64, 65, 
	90, 91, 96, 97, 122, 123, 65535, 45, 
	0, 47, 48, 57, 58, 64, 65, 90, 
	91, 96, 97, 122, 123, 65535, 45, 46, 
	0, 47, 48, 57, 58, 64, 65, 90, 
	91, 96, 97, 122, 123, 65535, 0, 47, 
	48, 57, 58, 64, 65, 90, 91, 96, 
	97, 122, 123, 65535, 45, 46, 48, 57, 
	65, 90, 97, 122, 48, 57, 65, 90, 
	97, 122, 0, 47, 48, 57, 58, 64, 
	65, 90, 91, 96, 97, 122, 123, 65535, 
	45, 46, 0, 47, 48, 57, 58, 64, 
	65, 90, 91, 96, 97, 122, 123, 65535, 
	0, 47, 48, 57, 58, 64, 65, 90, 
	91, 96, 97, 122, 123, 65535, 45, 46, 
	0, 47, 48, 57, 58, 64, 65, 90, 
	91, 96, 97, 122, 123, 65535, 0, 47, 
	48, 57, 58, 64, 65, 90, 91, 96, 
	97, 122, 123, 65535, 45, 46, 48, 57, 
	65, 90, 97, 122, 45, 46, 48, 57, 
	65, 90, 97, 122, 45, 46, 48, 57, 
	65, 90, 97, 122, 45, 46, 0, 47, 
	48, 57, 58, 64, 65, 90, 91, 96, 
	97, 122, 123, 65535, 45, 46, 0, 47, 
	48, 57, 58, 64, 65, 90, 91, 96, 
	97, 122, 123, 65535, 45, 46, 0, 47, 
	48, 57, 58, 64, 65, 90, 91, 96, 
	97, 122, 123, 65535, 45, 46, 0, 47, 
	48, 57, 58, 64, 65, 90, 91, 96, 
	97, 122, 123, 65535, 45, 46, 0, 47, 
	48, 57, 58, 64, 65, 90, 91, 96, 
	97, 122, 123, 65535, 45, 46, 0, 47, 
	48, 57, 58, 64, 65, 90, 91, 96, 
	97, 122, 123, 65535, 0, 47, 48, 57, 
	58, 65535, 48, 57, 33, 37, 44, 92, 
	94, 96, 126, 0, 35, 36, 58, 59, 
	64, 65, 122, 123, 65535, 33, 37, 59, 
	61, 93, 95, 126, 36, 43, 45, 58, 
	65, 91, 97, 122, 33, 37, 59, 93, 
	95, 126, 36, 43, 45, 58, 65, 91, 
	97, 122, 0, 47, 48, 57, 58, 64, 
	65, 70, 71, 96, 97, 102, 103, 65535, 
	0, 47, 48, 57, 58, 64, 65, 70, 
	71, 96, 97, 102, 103, 65535, 45, 46, 
	73, 105, 48, 57, 65, 90, 97, 122, 
	45, 46, 80, 112, 48, 57, 65, 90, 
	97, 122, 45, 46, 58, 83, 115, 48, 
	57, 65, 90, 97, 122, 45, 46, 58, 
	48, 57, 65, 90, 97, 122, 45, 46, 
	69, 101, 48, 57, 65, 90, 97, 122, 
	45, 46, 76, 108, 48, 57, 65, 90, 
	97, 122, 45, 46, 58, 48, 57, 65, 
	90, 97, 122, 59, 0, 65535, 33, 37, 
	59, 61, 93, 95, 126, 36, 43, 45, 
	58, 65, 91, 97, 122, 33, 37, 59, 
	93, 95, 126, 36, 43, 45, 58, 65, 
	91, 97, 122, 58, 0, 47, 48, 57, 
	59, 64, 65, 70, 71, 96, 97, 102, 
	103, 65535, 58, 93, 0, 47, 48, 57, 
	59, 64, 65, 70, 71, 96, 97, 102, 
	103, 65535, 58, 93, 0, 47, 48, 57, 
	59, 64, 65, 70, 71, 96, 97, 102, 
	103, 65535, 58, 93, 0, 47, 48, 57, 
	59, 64, 65, 70, 71, 96, 97, 102, 
	103, 65535, 58, 93, 0, 65535, 58, 0, 
	47, 48, 57, 59, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 46, 58, 93, 
	0, 47, 48, 57, 59, 64, 65, 70, 
	71, 96, 97, 102, 103, 65535, 0, 47, 
	48, 57, 58, 65535, 46, 0, 47, 48, 
	57, 58, 65535, 0, 47, 48, 57, 58, 
	65535, 46, 0, 47, 48, 57, 58, 65535, 
	0, 47, 48, 57, 58, 65535, 93, 0, 
	47, 48, 57, 58, 65535, 93, 0, 47, 
	48, 57, 58, 65535, 93, 0, 65535, 46, 
	0, 47, 48, 57, 58, 65535, 46, 0, 
	65535, 46, 0, 47, 48, 57, 58, 65535, 
	46, 0, 65535, 46, 58, 93, 0, 47, 
	48, 57, 59, 64, 65, 70, 71, 96, 
	97, 102, 103, 65535, 46, 58, 93, 0, 
	47, 48, 57, 59, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 58, 93, 0, 
	47, 48, 57, 59, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 58, 93, 0, 
	47, 48, 57, 59, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 58, 93, 0, 
	47, 48, 57, 59, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 58, 93, 0, 
	47, 48, 57, 59, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 58, 93, 0, 
	65535, 0, 47, 48, 57, 58, 64, 65, 
	70, 71, 96, 97, 102, 103, 65535, 46, 
	58, 93, 0, 47, 48, 57, 59, 64, 
	65, 70, 71, 96, 97, 102, 103, 65535, 
	46, 58, 93, 0, 47, 48, 57, 59, 
	64, 65, 70, 71, 96, 97, 102, 103, 
	65535, 46, 58, 93, 0, 47, 48, 57, 
	59, 64, 65, 70, 71, 96, 97, 102, 
	103, 65535, 0, 47, 48, 57, 58, 65535, 
	46, 0, 47, 48, 57, 58, 65535, 46, 
	0, 47, 48, 57, 58, 65535, 46, 0, 
	65535, 58, 0, 65535, 0
];

_tsip_machine_parser_uri_single_lengths = [
	0, 1, 2, 1, 0, 0, 0, 5, 
	5, 0, 0, 0, 5, 0, 0, 5, 
	0, 0, 7, 7, 0, 0, 6, 6, 
	0, 0, 7, 0, 2, 1, 2, 0, 
	2, 0, 0, 2, 0, 2, 0, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	0, 0, 7, 7, 6, 0, 0, 4, 
	4, 5, 0, 3, 0, 4, 4, 3, 
	1, 7, 6, 1, 2, 2, 2, 2, 
	1, 3, 0, 1, 0, 1, 0, 1, 
	1, 1, 1, 1, 1, 1, 3, 3, 
	2, 2, 2, 2, 2, 0, 3, 3, 
	3, 0, 1, 1, 1, 1, 0
];

_tsip_machine_parser_uri_range_lengths = [
	0, 3, 3, 3, 3, 3, 3, 4, 
	4, 3, 3, 1, 4, 3, 3, 4, 
	3, 3, 3, 3, 3, 3, 4, 4, 
	3, 3, 7, 1, 7, 7, 7, 7, 
	3, 3, 7, 7, 7, 7, 7, 3, 
	3, 3, 7, 7, 7, 7, 7, 7, 
	3, 1, 5, 4, 4, 7, 7, 3, 
	3, 3, 0, 3, 0, 3, 3, 3, 
	1, 4, 4, 7, 7, 7, 7, 1, 
	7, 7, 3, 3, 3, 3, 3, 3, 
	3, 1, 3, 1, 3, 1, 7, 7, 
	7, 7, 7, 7, 1, 7, 7, 7, 
	7, 3, 3, 3, 1, 1, 0
];

_tsip_machine_parser_uri_index_offsets = [
	0, 0, 5, 11, 16, 20, 24, 28, 
	38, 48, 52, 56, 58, 68, 72, 76, 
	86, 90, 94, 105, 116, 120, 124, 135, 
	146, 150, 154, 169, 171, 181, 190, 200, 
	208, 214, 218, 226, 236, 244, 254, 262, 
	268, 274, 280, 290, 300, 310, 320, 330, 
	340, 344, 346, 359, 371, 382, 390, 398, 
	406, 414, 423, 424, 431, 432, 440, 448, 
	455, 458, 470, 481, 490, 500, 510, 520, 
	524, 533, 544, 548, 553, 557, 562, 566, 
	571, 576, 579, 584, 587, 592, 595, 606, 
	617, 627, 637, 647, 657, 661, 669, 680, 
	691, 702, 706, 711, 716, 719, 722
];

_tsip_machine_parser_uri_indicies = [
	1, 2, 2, 2, 0, 3, 4, 5, 
	5, 5, 0, 3, 5, 5, 5, 0, 
	5, 2, 2, 0, 7, 7, 7, 6, 
	8, 8, 8, 6, 9, 10, 9, 9, 
	9, 9, 9, 9, 9, 6, 11, 12, 
	11, 11, 11, 11, 11, 11, 11, 6, 
	13, 13, 13, 6, 11, 11, 11, 6, 
	14, 0, 16, 17, 16, 16, 16, 16, 
	16, 16, 16, 15, 18, 18, 18, 15, 
	19, 19, 19, 15, 20, 21, 20, 20, 
	20, 20, 20, 20, 20, 15, 22, 22, 
	22, 15, 20, 20, 20, 15, 23, 25, 
	23, 23, 23, 23, 23, 23, 23, 23, 
	24, 26, 27, 28, 26, 29, 26, 26, 
	26, 26, 26, 24, 30, 30, 30, 24, 
	26, 26, 26, 24, 31, 32, 31, 33, 
	31, 31, 31, 31, 31, 31, 24, 34, 
	35, 34, 36, 34, 34, 34, 34, 34, 
	34, 24, 37, 37, 37, 24, 34, 34, 
	34, 24, 40, 41, 43, 44, 45, 43, 
	44, 38, 39, 38, 42, 38, 42, 38, 
	24, 38, 46, 47, 48, 38, 49, 38, 
	50, 38, 50, 38, 46, 47, 38, 50, 
	38, 50, 38, 50, 38, 46, 47, 51, 
	38, 50, 38, 50, 38, 50, 38, 46, 
	38, 50, 38, 2, 38, 2, 38, 46, 
	1, 53, 2, 2, 2, 52, 5, 2, 
	2, 52, 38, 54, 38, 2, 38, 2, 
	38, 46, 47, 55, 38, 56, 38, 50, 
	38, 50, 38, 46, 38, 57, 38, 2, 
	38, 2, 38, 46, 47, 58, 38, 59, 
	38, 50, 38, 50, 38, 46, 38, 60, 
	38, 2, 38, 2, 38, 46, 3, 4, 
	61, 5, 5, 52, 3, 4, 62, 5, 
	5, 52, 3, 4, 5, 5, 5, 52, 
	47, 58, 38, 63, 38, 50, 38, 50, 
	38, 46, 47, 58, 38, 50, 38, 50, 
	38, 50, 38, 46, 47, 55, 38, 64, 
	38, 50, 38, 50, 38, 46, 47, 55, 
	38, 50, 38, 50, 38, 50, 38, 46, 
	47, 48, 38, 65, 38, 50, 38, 50, 
	38, 46, 47, 48, 38, 50, 38, 50, 
	38, 50, 38, 46, 38, 66, 38, 46, 
	66, 67, 9, 68, 38, 38, 38, 38, 
	9, 38, 9, 38, 9, 38, 46, 8, 
	70, 71, 72, 8, 8, 8, 8, 8, 
	8, 8, 69, 11, 12, 71, 11, 11, 
	11, 11, 11, 11, 11, 69, 38, 73, 
	38, 73, 38, 73, 38, 46, 38, 8, 
	38, 8, 38, 8, 38, 46, 1, 53, 
	74, 74, 2, 2, 2, 52, 1, 53, 
	75, 75, 2, 2, 2, 52, 1, 53, 
	76, 77, 77, 2, 2, 2, 52, 78, 
	1, 53, 79, 2, 2, 2, 52, 80, 
	1, 53, 81, 81, 2, 2, 2, 52, 
	1, 53, 82, 82, 2, 2, 2, 52, 
	1, 53, 83, 2, 2, 2, 52, 86, 
	85, 84, 19, 88, 89, 90, 19, 19, 
	19, 19, 19, 19, 19, 87, 20, 21, 
	89, 20, 20, 20, 20, 20, 20, 20, 
	87, 92, 38, 91, 38, 91, 38, 91, 
	38, 46, 94, 95, 38, 93, 38, 93, 
	38, 93, 38, 46, 94, 95, 38, 96, 
	38, 96, 38, 96, 38, 46, 94, 95, 
	38, 97, 38, 97, 38, 97, 38, 46, 
	94, 95, 38, 46, 99, 38, 98, 38, 
	91, 38, 91, 38, 46, 100, 94, 95, 
	38, 101, 38, 93, 38, 93, 38, 46, 
	38, 102, 38, 46, 103, 38, 104, 38, 
	46, 38, 105, 38, 46, 106, 38, 107, 
	38, 46, 38, 108, 38, 46, 95, 38, 
	109, 38, 46, 95, 38, 110, 38, 46, 
	95, 38, 46, 106, 38, 111, 38, 46, 
	106, 38, 46, 103, 38, 112, 38, 46, 
	103, 38, 46, 100, 94, 95, 38, 113, 
	38, 96, 38, 96, 38, 46, 100, 94, 
	95, 38, 97, 38, 97, 38, 97, 38, 
	46, 115, 95, 38, 114, 38, 114, 38, 
	114, 38, 46, 117, 95, 38, 116, 38, 
	116, 38, 116, 38, 46, 117, 95, 38, 
	118, 38, 118, 38, 118, 38, 46, 117, 
	95, 38, 119, 38, 119, 38, 119, 38, 
	46, 117, 95, 38, 46, 38, 120, 38, 
	114, 38, 114, 38, 46, 100, 117, 95, 
	38, 121, 38, 116, 38, 116, 38, 46, 
	100, 117, 95, 38, 122, 38, 118, 38, 
	118, 38, 46, 100, 117, 95, 38, 119, 
	38, 119, 38, 119, 38, 46, 38, 123, 
	38, 46, 100, 38, 124, 38, 46, 100, 
	38, 125, 38, 46, 100, 38, 46, 99, 
	38, 46, 24, 0
];

_tsip_machine_parser_uri_trans_targs = [
	26, 1, 32, 3, 4, 2, 26, 6, 
	51, 51, 5, 52, 9, 10, 64, 26, 
	65, 13, 14, 65, 66, 16, 17, 19, 
	0, 20, 19, 20, 22, 102, 21, 23, 
	24, 102, 23, 24, 102, 25, 27, 28, 
	48, 50, 32, 55, 61, 67, 26, 29, 
	34, 46, 30, 31, 26, 33, 35, 36, 
	44, 37, 38, 42, 39, 40, 41, 43, 
	45, 47, 49, 26, 53, 26, 5, 7, 
	8, 54, 56, 57, 58, 59, 26, 60, 
	26, 62, 63, 11, 26, 64, 12, 26, 
	13, 12, 15, 68, 101, 69, 72, 26, 
	70, 71, 73, 88, 74, 86, 75, 76, 
	84, 77, 78, 82, 79, 80, 81, 83, 
	85, 87, 89, 97, 90, 93, 91, 92, 
	94, 95, 96, 98, 99, 100
];

_tsip_machine_parser_uri_trans_actions = [
	25, 0, 13, 0, 0, 0, 27, 0, 
	13, 53, 1, 13, 0, 0, 67, 23, 
	53, 1, 0, 13, 13, 0, 0, 1, 
	0, 1, 0, 0, 5, 38, 0, 1, 
	1, 59, 0, 0, 44, 0, 0, 35, 
	0, 0, 56, 63, 56, 3, 21, 0, 
	0, 0, 0, 0, 17, 13, 0, 0, 
	0, 0, 0, 0, 13, 13, 13, 0, 
	0, 0, 0, 19, 1, 50, 0, 7, 
	0, 0, 13, 13, 0, 13, 29, 0, 
	32, 13, 13, 0, 41, 13, 5, 47, 
	0, 7, 0, 0, 0, 0, 0, 15, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0
];

_tsip_machine_parser_uri_to_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 9, 0, 0, 0, 0, 0, 
	0, 0, 9, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0
];

_tsip_machine_parser_uri_from_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 11, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0
];

_tsip_machine_parser_uri_eof_trans = [
	0, 1, 1, 1, 1, 7, 7, 7, 
	7, 7, 7, 1, 16, 16, 16, 16, 
	16, 16, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 47, 47, 47, 47, 47, 
	53, 53, 47, 47, 47, 47, 47, 53, 
	53, 53, 47, 47, 47, 47, 47, 47, 
	47, 68, 47, 70, 70, 47, 47, 53, 
	53, 53, 79, 53, 81, 53, 53, 53, 
	85, 88, 88, 47, 47, 47, 47, 47, 
	47, 47, 47, 47, 47, 47, 47, 47, 
	47, 47, 47, 47, 47, 47, 47, 47, 
	47, 47, 47, 47, 47, 47, 47, 47, 
	47, 47, 47, 47, 47, 47, 0
];

tsip_machine_parser_uri_start = 26;
tsip_machine_parser_uri_first_final = 26;
tsip_machine_parser_uri_error = 0;

tsip_machine_parser_uri_en_sip_usrinfo = 18;
tsip_machine_parser_uri_en_main = 26;


/* line 113 "./ragel/tsip_parser_uri.jrl" */

tsip_uri.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var uri = new tsip_uri(tsip_uri_type_e.unknown);
	
	
/* line 425 "./src/parsers/tsip_parser_uri.js" */
{
	 cs = tsip_machine_parser_uri_start;
	 ts = null;
	 te = null;
	 act = 0;
} /* JSCodeGen::writeInit */

/* line 124 "./ragel/tsip_parser_uri.jrl" */
	
/* line 435 "./src/parsers/tsip_parser_uri.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_acts = _tsip_machine_parser_uri_from_state_actions[cs];
	_nacts = _tsip_machine_parser_uri_actions[_acts];
	_acts += 1;
	while (_nacts > 0) {
		_nacts -= 1;
		_acts += 1;
		switch (_tsip_machine_parser_uri_actions[_acts - 1]) {
			case 12:
/* line 1 "NONE" */
ts = p
		break;
/* line 471 "./src/parsers/tsip_parser_uri.js" */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	_keys = _tsip_machine_parser_uri_key_offsets[cs];
	_trans = _tsip_machine_parser_uri_index_offsets[cs];
	_klen = _tsip_machine_parser_uri_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_uri_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_uri_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_uri_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_uri_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_uri_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_uri_indicies[_trans];
	}
	if (_goto_level <= _eof_trans) {
	cs = _tsip_machine_parser_uri_trans_targs[_trans];
	if (_tsip_machine_parser_uri_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_uri_trans_actions[_trans];
		_nacts = _tsip_machine_parser_uri_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_uri_actions[_acts - 1]) {
case 0:
/* line 13 "./ragel/tsip_parser_uri.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 18 "./ragel/tsip_parser_uri.jrl" */

	    uri.e_type = tsip_uri_type_e.sip;
	    uri.s_scheme = uri.e_type.s_scheme;
			break;
case 2:
/* line 22 "./ragel/tsip_parser_uri.jrl" */
 
	    uri.e_type = tsip_uri_type_e.sips;
	    uri.s_scheme = uri.e_type.s_scheme;
			break;
case 3:
/* line 26 "./ragel/tsip_parser_uri.jrl" */
 
	    uri.e_type = tsip_uri_type_e.tel;
	    uri.s_scheme = uri.e_type.s_scheme;
			break;
case 4:
/* line 32 "./ragel/tsip_parser_uri.jrl" */
 
	    uri.e_host_type = tsip_host_type_e.ipv4; 
			break;
case 5:
/* line 35 "./ragel/tsip_parser_uri.jrl" */
 
	    uri.e_host_type = tsip_host_type_e.ipv6; 
			break;
case 6:
/* line 38 "./ragel/tsip_parser_uri.jrl" */
 
	    uri.e_host_type = tsip_host_type_e.hostname; 
			break;
case 7:
/* line 46 "./ragel/tsip_parser_uri.jrl" */

	    uri.s_user_name = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 8:
/* line 50 "./ragel/tsip_parser_uri.jrl" */

	    uri.s_password = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 9:
/* line 62 "./ragel/tsip_parser_uri.jrl" */

	    var o_param = tsk_ragel_parser_get_param(s_str, p, i_tag_start);
        if (o_param){
            uri.ao_params.push(o_param);
        }
			break;
case 10:
/* line 75 "./ragel/tsip_parser_uri.jrl" */
 	{
		cs = 26;
		_trigger_goto = true;
		_goto_level = _again;
		break;
	}
 		break;
case 13:
/* line 1 "NONE" */
te = p+1
		break;
case 14:
/* line 88 "./ragel/tsip_parser_uri.jrl" */
te = p+1
 {
							    uri.s_host = tsk_ragel_scanner_get_string(s_str, ts, te);
								if(uri.e_host_type.i_id == tsip_host_type_e.ipv6.i_id){
								    uri.s_host = tsk_string_unquote(uri.s_host, '[', ']');
								}
							 }
		break;
case 15:
/* line 79 "./ragel/tsip_parser_uri.jrl" */
te = p
p = p - 1; {
								if(tsk_string_contains(s_str.substring(te), (pe - te), "@")){
										{
		cs = 18;
		_trigger_goto = true;
		_goto_level = _again;
		break;
	}

								}
							 }
		break;
case 16:
/* line 85 "./ragel/tsip_parser_uri.jrl" */
te = p
p = p - 1; {  }
		break;
case 17:
/* line 88 "./ragel/tsip_parser_uri.jrl" */
te = p
p = p - 1; {
							    uri.s_host = tsk_ragel_scanner_get_string(s_str, ts, te);
								if(uri.e_host_type.i_id == tsip_host_type_e.ipv6.i_id){
								    uri.s_host = tsk_string_unquote(uri.s_host, '[', ']');
								}
							 }
		break;
case 18:
/* line 96 "./ragel/tsip_parser_uri.jrl" */
te = p
p = p - 1; {
								ts++;
								uri.i_port = tsk_ragel_scanner_get_int(s_str, ts, te);
							 }
		break;
case 19:
/* line 101 "./ragel/tsip_parser_uri.jrl" */
te = p
p = p - 1; {   }
		break;
case 20:
/* line 102 "./ragel/tsip_parser_uri.jrl" */
te = p
p = p - 1; {   }
		break;
case 21:
/* line 85 "./ragel/tsip_parser_uri.jrl" */
 { p = ((te))-1; }
 {  }
		break;
case 22:
/* line 88 "./ragel/tsip_parser_uri.jrl" */
 { p = ((te))-1; }
 {
							    uri.s_host = tsk_ragel_scanner_get_string(s_str, ts, te);
								if(uri.e_host_type.i_id == tsip_host_type_e.ipv6.i_id){
								    uri.s_host = tsk_string_unquote(uri.s_host, '[', ']');
								}
							 }
		break;
case 23:
/* line 101 "./ragel/tsip_parser_uri.jrl" */
 { p = ((te))-1; }
 {   }
		break;
/* line 685 "./src/parsers/tsip_parser_uri.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	_acts = _tsip_machine_parser_uri_to_state_actions[cs];
	_nacts = _tsip_machine_parser_uri_actions[_acts];
	_acts += 1;
	while (_nacts > 0) {
		_nacts -= 1;
		_acts += 1;
		switch (_tsip_machine_parser_uri_actions[_acts - 1]) {
case 11:
/* line 1 "NONE" */
ts = null;		break;
/* line 704 "./src/parsers/tsip_parser_uri.js" */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	if (p == eof) {
	if (_tsip_machine_parser_uri_eof_trans[cs] > 0) {
		_trans = _tsip_machine_parser_uri_eof_trans[cs] - 1;
		_goto_level = _eof_trans;
		continue;
	}
}
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 125 "./ragel/tsip_parser_uri.jrl" */
	
	if( cs < 
/* line 738 "./src/parsers/tsip_parser_uri.js" */
26
/* line 126 "./ragel/tsip_parser_uri.jrl" */
 ){
		tsk_utils_log_error("Failed to parse SIP/SIPS/TEL URI: " + s_str);
		return null;
	}
	
	return uri;
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
// Generates HTTP-basic response as per RFC 2617.
function tsip_auth_basic_response(s_userid, s_password){
	/* RFC 2617 - 2 Basic Authentication Scheme
	
	To receive authorization, the client sends the userid and password,
	separated by a single colon (":") character, within a base64 [7]
	encoded string in the credentials.
	*/
	
    return Base64.encode(tsk_string_format("{0}:{1}", s_userid, s_password));
}

// Generates digest HA1 value as per RFC 2617 subclause 3.2.2.2. 
function tsip_auth_digest_HA1(s_username, s_realm, s_password){
	/* RFC 2617 - 3.2.2.2 A1
		A1       = unq(username-value) ":" unq(realm-value) ":" passwd
	*/
    return MD5.hexdigest(tsk_string_format("{0}:{1}:{2}", s_username, s_realm, s_password));
}


// Generates digest HA1 value for 'MD5-sess' algo as per RFC 2617 subclause 3.2.2.2.
function tsip_auth_digest_HA1sess(s_username, s_realm, s_password, s_nonce, s_cnonce){

	/* RFC 2617 - 3.2.2.2 A1
			A1       = H( unq(username-value) ":" unq(realm-value)
                     ":" passwd )
                     ":" unq(nonce-value) ":" unq(cnonce-value)
	*/
    return MD5.hexdigest(tsk_string_format("{0}:{1}:{2}:{3}:{4}", s_username, s_realm, s_password, s_nonce, s_cnonce));
}


// Generates digest HA2 value as per RFC 2617 subclause 3.2.2.3. 
function tsip_auth_digest_HA2(s_method, s_url, o_entity_body, s_qop){
	/* RFC 2617 - 3.2.2.3 A2

	If the "qop" directive's value is "auth" or is unspecified, then A2
	is:
	A2       = Method ":" digest-url-value

	If the "qop" value is "auth-int", then A2 is:
	A2       = Method ":" digest-url-value ":" H(entity-body)
	*/

	var s_a2 = null;

	if(tsk_string_is_null_or_empty(s_qop) || tsk_string_iequals(s_qop, "auth")){
		s_a2 = tsk_string_format("{0}:{1}", s_method, s_url);
	}
	else if(tsk_string_iequals(s_qop, "auth-int")){
		if(o_entity_body){
			var s_hEntity = MD5.hash(o_entity_body);
			s_a2 = tsk_string_format("{0}:{1}:{2}", s_method, s_url, s_hEntity);
		}
		else{
            s_a2 = tsk_string_format("{0}:{1}:{2}", s_method, s_url, "d41d8cd98f00b204e9800998ecf8427e");
		}
	}

    return MD5.hexdigest(s_a2);
}


// Generates HTTP digest response as per RFC 2617 subclause 3.2.2.1.
function tsip_auth_digest_response(s_ha1, s_nonce, s_noncecount, s_cnonce, s_qop, s_ha2){
	/* RFC 2617 3.2.2.1 Request-Digest

	============ CASE 1 ============
	If the "qop" value is "auth" or "auth-int":
	request-digest  = <"> < KD ( H(A1),     unq(nonce-value)
	":" nc-value
	":" unq(cnonce-value)
	":" unq(qop-value)
	":" H(A2)
	) <">
	============ CASE 2 ============
	If the "qop" directive is not present (this construction is for
	compatibility with RFC 2069):
	request-digest  =
	<"> < KD ( H(A1), unq(nonce-value) ":" H(A2) ) >
	<">
	*/

	if(tsk_string_iequals(s_qop, "auth") || tsk_string_iequals(s_qop, "auth-int")){
		/* CASE 1 */
	    return MD5.hexdigest(tsk_string_format("{0}:{1}:{2}:{3}:{4}:{5}", s_ha1, s_nonce, s_noncecount, s_cnonce, s_qop, s_ha2));
	}
	else{
		/* CASE 2 */
	    return MD5.hexdigest(tsk_string_format("{0}:{1}:{2}", s_ha1, s_nonce, s_ha2));
	}
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
function tsip_challenge(o_stack, b_isproxy, s_scheme, s_realm, s_nonce, s_opaque, s_algorithm, s_qop) {
    this.o_stack = o_stack;
    this.b_isproxy = b_isproxy;
	this.s_scheme = s_scheme;
	this.s_realm = s_realm;
	this.s_nonce = s_nonce;
	this.s_opaque = s_opaque;
	this.s_algorithm = s_algorithm;
	this.s_cnonce = null;
	this.i_nc = 0;
	if (s_qop) {
	    this.s_qop = tsk_string_contains(s_qop, s_qop.length, "auth-int") ? "auth-int" :
					(tsk_string_contains(s_qop, s_qop.length, "auth") ? "auth" : null);
	    this.reset_cnonce();
	}
}

tsip_challenge.prototype.get_username = function(){
    return this.o_stack.identity.s_impi;
}

tsip_challenge.prototype.get_password = function(){
    return this.o_stack.identity.s_password;
}

tsip_challenge.prototype.get_digest = function(){
    return this.o_stack.identity.s_digest;
}

tsip_challenge.prototype.reset_cnonce = function () {
    if (this.s_qop) {
        this.s_cnonce = MD5.hexdigest(tsk_string_random(21));
        this.i_nc = 1;
    }
}

tsip_challenge.prototype.get_response = function (s_method, s_uristring, o_entity_body) {
    if (tsk_string_iequals(this.s_scheme, "Digest")) {
        var s_nc = "";

				/* NCC: addded digest */ 
			
        /* ===
        Calculate HA1 = MD5(A1) = M5(username:realm:secret)
        */
        var s_ha1 = this.get_digest() || tsip_auth_digest_HA1(this.get_username(), this.s_realm, this.get_password());

        /* ===
        HA2 
        */
        var s_ha2 = tsip_auth_digest_HA2(s_method, s_uristring, o_entity_body, this.s_qop);

        /* RESPONSE */
        if (this.i_nc) {
            s_nc = tsip_challenge.prototype.Ncount2String(this.i_nc);
        }
        var s_md5_response = tsip_auth_digest_response(s_ha1, this.s_nonce, s_nc, this.s_cnonce, this.s_qop, s_ha2);

        if (this.s_qop) {
            ++this.i_nc;
        }
        return s_md5_response;
    }
    return null;
}

tsip_challenge.prototype.update = function (s_scheme, s_realm, s_nonce, s_opaque, s_algorithm, s_qop) {
    var b_noncechanged = !tsk_string_iequals(this.s_nonce, s_nonce);

    this.s_scheme = s_scheme;
    this.s_realm = s_realm;
    this.s_nonce = s_nonce;
    this.s_opaque = s_opaque;
    this.s_algorithm = s_algorithm;
    if (s_qop) {
        this.s_qop = tsk_string_contains(s_qop, s_qop.length, "auth-int") ? "auth-int" :
					(tsk_string_contains(s_qop, s_qop.length, "auth") ? "auth" : null);
    }

    if (b_noncechanged && this.s_qop) {
        this.reset_cnonce();
    }
    return 0;
}

tsip_challenge.prototype.create_header_authorization = function(o_request){
	var s_nc = null;
	var s_uristring = null;
	var o_header = null;

    if(!(s_uristring = tsip_uri_tostring(o_request.line.request.o_uri, true, false))){
        tsk_utils_log_error("Failed to parse URI: " + o_request.line.request.o_uri);
        return null;
    }

	/* We compute the nc here because @ref tsip_challenge_get_response function will increment it's value. */
	if (this.i_nc) {
        s_nc = tsip_challenge.prototype.Ncount2String(this.i_nc);
    }

	/* entity_body ==> request-content */
    var s_response = this.get_response(o_request.line.request.s_method, s_uristring, o_request.o_content);

    o_header = new tsip_header_Authorization();
    o_header.e_type = this.b_isproxy ? tsip_header_type_e.Proxy_Authorization : tsip_header_type_e.Authorization;
	o_header.s_scheme = this.s_scheme;
	o_header.s_username = this.get_username();
	o_header.s_realm = this.s_realm;
	o_header.s_nonce = this.s_nonce;
	o_header.s_uri = s_uristring;
	o_header.s_response = s_response;
	o_header.s_algorithm = this.s_algorithm ? this.s_algorithm : "MD5";
	o_header.s_cnonce = this.i_nc ? this.s_cnonce : null;
	o_header.s_opaque = this.s_opaque;
	o_header.s_qop = this.s_qop;
	o_header.s_nc = s_nc;

	return o_header;
}

tsip_challenge.prototype.CreateEmptyHeaderAuthorization = function(s_username, s_realm, s_uristring){
	var o_header = new tsip_header_Authorization();

	if(o_header){
        o_header.e_type = tsip_header_type_e.Authorization;
		o_header.s_scheme = "Digest";
		o_header.s_username = s_username;
		o_header.s_realm = s_realm;
		o_header.s_nonce = "";
		o_header.s_response = "";
		o_header.s_uri = s_uristring;
	}

	return o_header;
}

tsip_challenge.prototype.Ncount2String = function (i_nc) {
    var i = 7;
    var s_nc = "";
    do {
        s_nc += "0123456789abcdef"[(i_nc >> i * 4) & 0xF];
    }
    while (i--);
    //return s_nc.split("").reverse().join("");
    return s_nc;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_dialog.prototype.__i_timer_shutdown = 3000; // milliseconds

var tsip_dialog_type_e =
{
    UNKNOWN: { i_id: 0, s_name: "Unknown" },
    INVITE: { i_id: 1, s_name: "INVITE" },
    MESSAGE: { i_id: 2, s_name: "MESSAGE" },
    INFO: { i_id: 3, s_name: "INFO" },
    OPTIONS: { i_id: 4, s_name: "OPTIONS" },
    PUBLISH: { i_id: 5, s_name: "PUBLISH" },
    REGISTER: { i_id: 6, s_name: "REGISTER" },
    SUBSCRIBE: { i_id: 7, s_name: "SUBSCRIBE" }
};

var tsip_dialog_state_e =
{
    INITIAL: { i_id: 0, s_name: "Initial" },
    EARLY: { i_id: 1, s_name: "Early" },
    ESTABLISHED: { i_id: 2, s_name: "Established" },
    TERMINATED: { i_id: 3, s_name: "Terminated" }
};

var tsip_dialog_event_type_e =
{
    I_MSG: { i_id: 0, s_name: "I_MSG" },
    O_MSG: { i_id: 1, s_name: "O_MSG" },
    TRANSAC_OK: { i_id: 2, s_name: "TRANSAC_OK" },
    CANCELED: { i_id: 3, s_name: "CANCELED" },
    TERMINATED: { i_id: 4, s_name: "TERMINATED" },
    TIMEDOUT: { i_id: 5, s_name: "TIMEDOUT" },
    ERROR: { i_id: 6, s_name: "ERROR" },
    TRANSPORT_ERROR: { i_id: 7, s_name: "TRANSPORT_ERROR" }
};

function tsip_dialog() {
    this.e_type = tsip_dialog_type_e.UNKNOWN;

    this.o_fsm = null;

    this.o_session = null;
    this.o_action_curr = null;

    this.e_state = tsip_dialog_state_e.INITIAL;
    this.b_initialized = false;
    this.b_running = false;

    this.last_error = {};
    this.last_error.s_phrase = null;
    this.last_error.i_code = 0;
    this.last_error.o_message = null;

    this.s_tag_local = null;
    this.o_uri_local = null;
    this.s_tag_remote = null;
    this.o_uri_remote = null;
    this.o_uri_remote_target = null;

    this.i_cseq_value = 0;
    this.s_cseq_method = null;

    this.i_expires = 0; // in milliseconds

    this.s_callid = null;

    this.ao_hdr_record_routes = null;
    this.ao_challenges = null;

    this.fn_callback = null;
}

tsip_dialog.prototype.init = function (e_type, s_callid, o_session, i_fsm_state_curr, i_fsm_state_term) {
    if (this.b_initialized) {
        tsk_utils_log_error("Dialog already initialized");
        return -2;
    }

    this.e_state = tsip_dialog_state_e.INITIAL;
    this.e_type = e_type;

    this.ao_hdr_record_routes = new Array();
    this.ao_challenges = new Array();

    this.i_expires = tsip_session.prototype.__i_expires_default;

    var b_svr_side = !tsk_string_is_null_or_empty(s_callid);
    this.s_callid = b_svr_side ? s_callid : tsk_string_random_uuid();

    if ((this.o_session = o_session)) {
        // expires
        this.i_expires = o_session.i_expires;
        // From
        this.o_uri_local = b_svr_side ? o_session.o_uri_to : o_session.o_uri_from;
        // To
        if (o_session.o_uri_to) {
            this.o_uri_remote = o_session.o_uri_to;
            this.o_uri_remote_target = o_session.o_uri_to; // request-uri
        }
        else {
            this.o_uri_remote = o_session.o_uri_from;
            this.o_uri_remote_target = o_session.o_stack.network.o_uri_realm; // request-uri
        }
    }

    // tags
    this.s_tag_local = tsk_string_random(20);
    this.s_tag_remote = null;

    // CSeq
    this.i_cseq_value = Math.floor((Math.random() * 0x0000FFFF));

    // FSM
    this.o_fsm = new tsk_fsm(i_fsm_state_curr, i_fsm_state_term, null, this);

    this.b_initialized = true;

    return 0;
}

tsip_dialog.prototype.deinit = function () {
    this.get_layer_dialog().dialog_remove(this);
    this.get_layer_transac().cancel_by_dialog(this);
    this.b_initialized = false;

    return 0;
}

tsip_dialog.prototype.compare = function (o_dialog) {
    return tsip_dialog_compare(this, o_dialog);
};

tsip_dialog.prototype.request_new = function (s_method) {
    if (!this.o_session || !this.o_session.o_stack || !s_method) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    var o_request = null;
    var o_uri_to = null;
    var o_uri_from = null;
    var o_uri_request = null;
    var i_copy_routes_start = -1; //none
    var s_callid = null;
    var o_session = this.o_session;
    var o_stack = o_session.o_stack;


    /*
    RFC 3261 - 12.2.1.1 Generating the Request

    The Call-ID of the request MUST be set to the Call-ID of the dialog.
    */
    s_callid = this.s_callid;

    /*
    RFC 3261 - 12.2.1.1 Generating the Request

    Requests within a dialog MUST contain strictly monotonically
    increasing and contiguous CSeq sequence numbers (increasing-by-one)
    in each direction (excepting ACK and CANCEL of course, whose numbers
    equal the requests being acknowledged or cancelled).  Therefore, if
    the local sequence number is not empty, the value of the local
    sequence number MUST be incremented by one, and this value MUST be
    placed into the CSeq header field.
    */
    /*if(!tsk_striequals(method, "ACK") && !tsk_striequals(method, "CANCEL"))
    {
    this.cseq_value +=1;
    }
    ===> See send method (cseq will be incremented before sending the request)
    */


    /*
    RFC 3261 - 12.2.1.1 Generating the Request

    The URI in the To field of the request MUST be set to the remote URI
    from the dialog state.  The tag in the To header field of the request
    MUST be set to the remote tag of the dialog ID.  The From URI of the
    request MUST be set to the local URI from the dialog state.  The tag
    in the From header field of the request MUST be set to the local tag
    of the dialog ID.  If the value of the remote or local tags is null,
    the tag parameter MUST be omitted from the To or From header fields,
    respectively.
    */
    o_uri_to = this.o_uri_remote;
    o_uri_from = this.o_uri_local;


    /*
    RFC 3261 - 12.2.1.1 Generating the Request

    If the route set is empty, the UAC MUST place the remote target URI
    into the Request-URI.  The UAC MUST NOT add a Route header field to
    the request.
    */
    if (!this.ao_hdr_record_routes || this.ao_hdr_record_routes.length == 0) {
        o_uri_request = this.o_uri_remote_target;
    }

    /*
    RFC 3261 - 12.2.1.1 Generating the Request

    If the route set is not empty, and the first URI in the route set
    contains the lr parameter (see Section 19.1.1), the UAC MUST place
    the remote target URI into the Request-URI and MUST include a Route
    header field containing the route set values in order, including all
    parameters.

    If the route set is not empty, and its first URI does not contain the
    lr parameter, the UAC MUST place the first URI from the route set
    into the Request-URI, stripping any parameters that are not allowed
    in a Request-URI.  The UAC MUST add a Route header field containing
    the remainder of the route set values in order, including all
    parameters.  The UAC MUST then place the remote target URI into the
    Route header field as the last value.

    For example, if the remote target is sip:user@remoteua and the route
    set contains:

    <sip:proxy1>,<sip:proxy2>,<sip:proxy3;lr>,<sip:proxy4>
    */
    else {
        o_uri_first_route = this.ao_hdr_record_routes[0].o_uri;
        if (tsk_params_have_param(o_uri_first_route.ao_params, "lr")) {
            o_uri_request = this.o_uri_remote_target;
            i_copy_routes_start = 0;
        }
        else {
            o_uri_request = o_uri_first_route;
            i_copy_routes_start = 1;
        }
    }

    /*=====================================================================
    */
    o_request = new tsip_request(s_method, o_uri_request, o_uri_from, o_uri_to, s_callid, this.i_cseq_value);
    o_request.o_hdr_To.s_tag = this.s_tag_remote;
    o_request.o_hdr_From.s_tag = this.s_tag_local;
    o_request.b_update = true; /* Now signal that the message should be updated by the transport layer (e.g. Contact, SigComp, IPSec, ...) */

    /*
    RFC 3261 - 12.2.1.1 Generating the Request

    A UAC SHOULD include a Contact header field in any target refresh
    requests within a dialog, and unless there is a need to change it,
    the URI SHOULD be the same as used in previous requests within the
    dialog.  If the "secure" flag is true, that URI MUST be a SIPS URI.
    As discussed in Section 12.2.2, a Contact header field in a target
    refresh request updates the remote target URI.  This allows a UA to
    provide a new contact address, should its address change during the
    duration of the dialog.
    */
    switch (o_request.line.request.e_type) {
        case tsip_request_type_e.MESSAGE:
        case tsip_request_type_e.PUBLISH:
        case tsip_request_type_e.BYE:
            {
                if (o_request.line.request.e_type == tsip_request_type_e.PUBLISH) {
                    o_request.add_header(new tsip_header_Expires(this.i_expires / 1000));
                }
                /* add caps in "Accept-Contact" headers */
                for (var i = 0; i < this.o_session.ao_caps.length; ++i) {
                    var s_value = tsk_string_format("*;{0}", tsk_param_tostring(this.o_session.ao_caps[i]));
                    if (s_value) {
                        o_request.add_header(new tsip_header_Dummy("Accept-Contact", s_value));
                    }
                }
                break;
            }

        default:
            {
                var s_contact = null;
                var ao_hdr_contacts = null;

                if (o_request.line.request.e_type == tsip_request_type_e.OPTIONS ||
					o_request.line.request.e_type == tsip_request_type_e.PUBLISH ||
					o_request.line.request.e_type == tsip_request_type_e.REGISTER) {
                    /**** with expires */
                    s_contact = tsk_string_format("m: \"{1}\"<{0}:{2}@{3}:{4};rtcweb-breaker={5}>;click2call={6};expires={7}\r\n",
                        "sip",
                        o_stack.identity.s_display_name,
                        o_uri_from.s_user_name,
                        "127.0.0.1",
                        5060,
                        o_stack.network.b_rtcweb_enabled ? "yes" : "no",
                        o_stack.network.b_click2call_enabled ? "yes" : "no",
                        Math.floor(this.i_expires / 1000));
					//SKOROZVON we need header "Expires" for unregister
					if (o_request.line.request.e_type == tsip_request_type_e.REGISTER && this.i_expires == 0)
						o_request.add_header(new tsip_header_Expires(0));
                }
                else {
                    /**** without expires */
                    if (o_request.line.request.e_type == tsip_request_type_e.SUBSCRIBE) {
                        /* RFC 3265 - 3.1.1. Subscription Duration
                        An "expires" parameter on the "Contact" header has no semantics for SUBSCRIBE and is explicitly 
                        not equivalent to an "Expires" header in a SUBSCRIBE request or response.
                        */
                        o_request.add_header(new tsip_header_Expires(this.i_expires / 1000));
                    }
                    s_contact = tsk_string_format("m: \"{1}\"<{0}:{2}@{3}:{4};rtcweb-breaker={5};click2call={6}>",
                        "sip",
                        o_stack.identity.s_display_name,
                        o_uri_from.s_user_name,
                        "127.0.0.1",
                        5060,
                        o_stack.network.b_rtcweb_enabled ? "yes" : "no",
                        o_stack.network.b_click2call_enabled ? "yes" : "no");

                    if (o_request.line.request.e_type == tsip_request_type_e.INVITE && o_stack.network.b_rtcweb_enabled) {
                        // contact parameters must be encoded as the ABNF is:
                        // gen_value = token | host | quoted_string;
	                    // generic_param = token ( EQUAL gen_value )?;
                        // for example, impi with value equal to "mamadou@example.org" whill be encoded as "mamadou%40example.org"
                        s_contact += ";impi=" + encodeURIComponent(o_stack.identity.s_impi);
                        s_contact += ";ha1=" + tsip_auth_digest_HA1(o_stack.identity.s_impi, o_stack.network.o_uri_realm.s_host, o_stack.identity.s_password);
                    }
                    s_contact += "\r\n";
                }
                ao_hdr_contacts = tsip_header_Contact.prototype.Parse(s_contact);
                if (ao_hdr_contacts && ao_hdr_contacts.length > 0) {
                    o_request.o_hdr_Contact = ao_hdr_contacts[0];
                }

                /* Add capabilities as per RFC 3840 */
                if (o_request.o_hdr_Contact) {
                    for (var i = 0; i < this.o_session.ao_caps.length; ++i) {
                        tsk_params_add_param(o_request.o_hdr_Contact.ao_params, this.o_session.ao_caps[i]);
                    }
                }

                break;
            }
    }

    /* Update authorizations */
    if (this.e_state == tsip_dialog_state_e.INITIAL && this.ao_challenges.length == 0) {
        /* 3GPP TS 33.978 6.2.3.1 Procedures at the UE
        On sending a REGISTER request in order to indicate support for early IMS security procedures, the UE shall not
        include an Authorization header field and not include header fields or header field values as required by RFC3329.
        */
        if (o_request.is_register() && !o_stack.security.b_earlyIMS) {
            /*	3GPP TS 24.229 - 5.1.1.2.2 Initial registration using IMS AKA
            On sending a REGISTER request, the UE shall populate the header fields as follows:
            a) an Authorization header field, with:
            - the "username" header field parameter, set to the value of the private user identity;
            - the "realm" header field parameter, set to the domain name of the home network;
            - the "uri" header field parameter, set to the SIP URI of the domain name of the home network;
            - the "nonce" header field parameter, set to an empty value; and
            - the "response" header field parameter, set to an empty value;
            */
            var s_realm = o_stack.network.o_uri_realm ? o_stack.network.o_uri_realm.s_host : "(null)";
            var s_uri_request = tsip_uri_tostring(o_request.line.request.o_uri, false, false);
            var hdr_auth = tsip_challenge.prototype.CreateEmptyHeaderAuthorization(o_stack.identity.s_impi, s_realm, s_uri_request);
            o_request.add_header(hdr_auth);
        }
    }
    else if (this.ao_challenges.length > 0) {
        for (var i = 0; i < this.ao_challenges.length; ++i) {
            var o_hdr_auth = this.ao_challenges[i].create_header_authorization(o_request);
            if (o_hdr_auth) {
                o_request.add_header(o_hdr_auth);
            }
        }
    }

    /* Update CSeq */
    /*	RFC 3261 - 13.2.2.4 2xx Responses
    Generating ACK: The sequence number of the CSeq header field MUST be
    the same as the INVITE being acknowledged, but the CSeq method MUST
    be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
    the 2xx contains an offer (based on the rules above), the ACK MUST
    carry an answer in its body.
    ==> CSeq number will be added/updated by the caller of this function,
    credentials were added above.
    */
    if (!o_request.is_ack() && !o_request.is_cancel()) {
        o_request.o_hdr_CSeq.i_seq = ++(this.i_cseq_value);
    }

    /* Route generation 
    *	==> http://betelco.blogspot.com/2008/11/proxy-and-service-route-discovery-in.html
    * The dialog Routes have been copied above.

    3GPP TS 24.229 - 5.1.2A.1 UE-originating case

    The UE shall build a proper preloaded Route header field value for all new dialogs and standalone transactions. The UE
    shall build a list of Route header field values made out of the following, in this order:
    a) the P-CSCF URI containing the IP address or the FQDN learnt through the P-CSCF discovery procedures; and
    b) the P-CSCF port based on the security mechanism in use:

    - if IMS AKA or SIP digest with TLS is in use as a security mechanism, the protected server port learnt during
    the registration procedure;
    - if SIP digest without TLS, NASS-IMS bundled authentciation or GPRS-IMS-Bundled authentication is in
    use as a security mechanism, the unprotected server port used during the registration procedure;
    c) and the values received in the Service-Route header field saved from the 200 (OK) response to the last
    registration or re-registration of the public user identity with associated contact address.
    */
    if (!o_request.is_register()) {	// According to the above link ==> Initial/Re/De registration do not have routes.
        if (i_copy_routes_start != -1) {	/* The dialog already have routes ==> copy them. */
            if (this.e_state == tsip_dialog_state_e.EARLY || this.e_state == tsip_dialog_state_e.ESTABLISHED) {
                var i_index = -1;
                for (var i = 0; i < this.ao_hdr_record_routes.length; ++i) {
                    var o_uri = this.ao_hdr_record_routes[i].o_uri;
                    var hdr_route = null;
                    if (++i_index < i_copy_routes_start || !o_uri) {
                        continue;
                    }

                    if ((hdr_route = new tsip_header_Route(o_uri))) {
                        // copy parameters: see http://code.google.com/p/imsdroid/issues/detail?id=52
                        for (var j = 0; j < this.ao_hdr_record_routes[i].ao_params.length; ++j) {
                            hdr_route.ao_params.push(this.ao_hdr_record_routes[i].ao_params[j]);
                        }

                        o_request.add_header(hdr_route);
                    }
                }
            }
        }
        else {	/* No routes associated to this dialog. */
            if (this.e_state == tsip_dialog_state_e.INITIAL || this.e_state == tsip_dialog_state_e.EARLY) {
                /*	GPP TS 24.229 section 5.1.2A [Generic procedures applicable to all methods excluding the REGISTER method]:
                The UE shall build a proper preloaded Route header field value for all new dialogs and standalone transactions. The UE
                shall build a list of Route header field values made out of the following, in this order:
                a) the P-CSCF URI containing the IP address or the FQDN learnt through the P-CSCF discovery procedures; and
                b) the P-CSCF port based on the security mechanism in use:
                - if IMS AKA or SIP digest with TLS is in use as a security mechanism, the protected server port learnt during
                the registration procedure;
                - if SIP digest without TLS, NASS-IMS bundled authentciation or GPRS-IMS-Bundled authentication is in
                use as a security mechanism, the unprotected server port used during the registration procedure;
                c) and the values received in the Service-Route header field saved from the 200 (OK) response to the last
                registration or re-registration of the public user identity with associated contact address.
                */

                //var o_uri = o_stack.get_pcscf_uri(true);
                // Proxy-CSCF as first route
                //if(o_uri){
                //    o_request.add_header(new tsip_header_Route(o_uri));
                //}

                // Service routes
                for (var i = 0; i < o_stack.ao_uri_service_routes.length; ++i) {
                    o_request.add_header(new tsip_header_Service_Route(o_stack.ao_uri_service_routes[i]));
                }
            }
        }
    }

    /* Add outbound proxy */
    // The outbound proxy is added as Route header only if the transport is WS/WSS to allow webrtc2sip to forward the request to the right destination
    // For all other protocols (e.g UDP) the request will already be sent to the outbound proxy address
    if (o_stack.network.e_proxy_cscf_type == tsip_transport_type_e.WS || o_stack.network.e_proxy_cscf_type == tsip_transport_type_e.WSS) {
        var s_proxy_outbound = o_stack.__get_proxy_outbound_uri_string();
        if (s_proxy_outbound) {
            o_request.add_header(new tsip_header_Dummy("Route", s_proxy_outbound), true/*top*/);
        }
    }

    /* Add headers associated to the dialog's session */
    for (var i = 0; i < o_session.ao_headers.length; ++i) {
        o_request.add_header(o_session.ao_headers[i]);
    }

    /* Add headers associated to the dialog's stack */
    for (var i = 0; i < o_stack.ao_headers.length; ++i) {
        o_request.add_header(o_stack.ao_headers[i]);
    }

    /* Add common headers */
    this.add_common_headers(o_request);

    /* SigComp */
    if (o_session.s_sigcomp_id) {
        /* should be added in this field instead of 'Contact' or 'Via' headers
        * it's up to the transport layer to copy it to these headers */
        o_request.s_sigcomp_id = o_session.s_sigcomp_id;
    }

    return o_request;
}

tsip_dialog.prototype.response_new = function (i_status, s_phrase, o_request) {
    /* Reponse is created as per RFC 3261 subclause 8.2.6 and (headers+tags) are copied
    * as per subclause 8.2.6.2.
    */
    var o_response;
    if ((o_response = new tsip_response(i_status, s_phrase, o_request))) {
        switch (o_request.line.request.e_type) {
            case tsip_request_type_e.MESSAGE:
            case tsip_request_type_e.PUBLISH:
                break;
            default:
                /* Is there a To tag?  */
                if (o_response.o_hdr_To && !o_response.o_hdr_To.s_tag) {
                    o_response.o_hdr_To.s_tag = this.s_tag_local;
                }
                /* Contact Header (for 101-299 reponses) */
                if (this.o_uri_local && i_status >= 101 && i_status <= 299) {
                    var ao_hdr_contacts;

                    var s_contact = tsk_string_format("m: <{0}:{1}@{2}:{3}>\r\n", "sip", this.o_uri_local.s_user_name, "127.0.0.1", 5060);
                    var ao_hdr_contacts = tsip_header_Contact.prototype.Parse(s_contact);
                    if (ao_hdr_contacts != null && ao_hdr_contacts.length > 0) {
                        o_response.o_hdr_Contact = ao_hdr_contacts[0];
                        o_response.b_update = true; /* Now signal that the message should be updated by the transport layer (e.g. Contact, SigComp, IPSec, ...) */
                    }
                }
                break;
        }

        /* SigComp */
        if (this.get_session().s_sigcomp_id) {
            /* should be added in this field instead of 'Contact' or 'Via' headers
            * it's up to the transport layer to copy it to these headers */
            o_response.s_sigcomp_id = this.get_session().s_sigcomp_id;
        }
    }
    return o_response;
}

tsip_dialog.prototype.response_send = function (o_response) {
    var i_ret = -1;
    var o_layer_transac = this.get_layer_transac();

    if (o_layer_transac) {
        /* As this is a response ...then use the associate server transaction */
        var o_transac = o_layer_transac.find_server(o_response);
        if (o_transac) {
            setTimeout(function () { o_transac.callback(tsip_transac_event_type_e.OUTGOING_MSG, o_response); }, 1);
            i_ret = 0;
        }
        else {
            tsk_utils_log_error("Failed to find associated server transaction.");
            // Send "408 Request Timeout" (should be done by the transaction layer)?
        }
    }
    else {
        tsk_utils_log_error("Invalid parameter");
    }
    return i_ret;
}

tsip_dialog.prototype.get_session = function () {
    return this.o_session;
}

tsip_dialog.prototype.get_stack = function () {
    if (this.o_session) {
        return this.o_session.o_stack;
    }
    return null;
}

tsip_dialog.prototype.get_layer_transac = function () {
    var o_stack = this.get_stack();
    if (o_stack) {
        return o_stack.o_layer_transac;
    }
    return null;
}

tsip_dialog.prototype.get_layer_dialog = function () {
    var o_stack = this.get_stack();
    if (o_stack) {
        return o_stack.o_layer_dialog;
    }
    return null;
}

tsip_dialog.prototype.get_layer_transport = function () {
    var o_stack = this.get_stack();
    if (o_stack) {
        return o_stack.o_layer_transport;
    }
    return null;
}

tsip_dialog.prototype.request_send = function (o_request) {
    if (!o_request) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    /*	RFC 3261 - 13.2.2.4 2xx Responses
    Once the ACK has been constructed, the procedures of [4] are used to
    determine the destination address, port and transport.  However, the
    request is passed to the transport layer directly for transmission,
    rather than a client transaction.  This is because the UAC core
    handles retransmissions of the ACK, not the transaction layer.  The
    ACK MUST be passed to the client transport every time a
    retransmission of the 2xx final response that triggered the ACK
    arrives.
    */
    if (o_request.is_ack()) {
        if (this.get_layer_transport().send(null, o_request) > 0) {
            return 0;
        }
        return -2;
    }

    var o_layer_transac = this.get_layer_transac();
    if (!o_layer_transac) {
        tsk_utils_log_error("Invalid transac layer");
        return -1;
    }

    var i_ret = -1;

    /*	Create new transaction. The new transaction will be added to the transaction layer. 
    The transaction has all information to create the right transaction type (NICT or ICT).
    As this is an outgoing request ==> It shall be a client transaction (NICT or ICT).
    For server transactions creation see "tsip_dialog_response_send()".
    */
    var o_transac = o_layer_transac.transac_new(true, o_request, this);

    /* Set the transaction's dialog. All events comming from the transaction (timeouts, errors ...) will be signaled to this dialog. */
    if (o_transac) {
        switch (o_transac.e_type) {
            case tsip_transac_type_e.ICT:
            case tsip_transac_type_e.NICT:
                {
                    /* Start the newly create IC/NIC transaction */
                    i_ret = o_transac.start(o_request);
                    break;
                }
        }
    }

    return i_ret;
};

tsip_dialog.prototype.add_common_headers = function (o_request) {
    var b_earlyIMS = false;
    var o_uri_preferred_identity = null;
    var s_netinfo = null;
    var o_stack = this.get_stack();

    if (!o_request || !o_stack) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    b_earlyIMS = o_stack.security.b_earlyIMS;
    o_uri_preferred_identity = o_stack.identity.o_uri_pref;

    //	P-Preferred-Identity
    if (o_uri_preferred_identity) {
        /*	3GPP TS 33.978 6.2.3.1 Procedures at the UE
        The UE shall use the temporary public user identity (IMSI-derived IMPU, cf. section 6.1.2) only in registration
        messages (i.e. initial registration, re-registration or de-registration), but not in any other type of SIP requests.
        */
        switch (o_request.line.request.e_type) {
            case tsip_request_type_e.BYE:
            case tsip_request_type_e.INVITE:
            case tsip_request_type_e.OPTIONS:
            case tsip_request_type_e.SUBSCRIBE:
            case tsip_request_type_e.NOTIFY:
            case tsip_request_type_e.REFER:
            case tsip_request_type_e.MESSAGE:
            case tsip_request_type_e.PUBLISH:
            case tsip_request_type_e.REGISTER:
                {
                    if (!b_earlyIMS || (b_earlyIMS && o_request.is_register())) {
                        o_request.add_header(new tsip_header_P_Preferred_Identity(o_uri_preferred_identity));
                    }
                    break;
                }
        }
    }

    //	P-Access-Network-Info
    if (s_netinfo) {
        switch (o_request.line.request.e_type) {
            case tsip_request_type_e.BYE:
            case tsip_request_type_e.INVITE:
            case tsip_request_type_e.OPTIONS:
            case tsip_request_type_e.REGISTER:
            case tsip_request_type_e.SUBSCRIBE:
            case tsip_request_type_e.NOTIFY:
            case tsip_request_type_e.PRACK:
            case tsip_request_type_e.INFO:
            case tsip_request_type_e.UPDATE:
            case tsip_request_type_e.REFER:
            case tsip_request_type_e.MESSAGE:
            case tsip_request_type_e.PUBLISH:
                {
                    o_request.add_header(new tsip_header_P_Access_Network_Info(s_netinfo));
                    break;
                }
        }
    }

    return 0;
}

tsip_dialog.prototype.get_action_curr = function () {
    return this.o_action_curr;
}

tsip_dialog.prototype.set_action_curr = function (o_action) {
    this.o_action_curr = o_action;
    return 0;
}

// o_message: optional
tsip_dialog.prototype.set_last_error = function (i_code, s_phrase, o_message) {
    this.last_error.i_code = i_code;
    this.last_error.s_phrase = s_phrase;
    this.last_error.o_message = o_message;
    return 0;
}

// o_message: optional
tsip_dialog.prototype.signal = function (i_code, s_phrase, o_message) {
    return tsip_event.prototype.Signal(tsip_event_type_e.DIALOG, this.o_session, i_code, s_phrase, o_message);
}

tsip_dialog.prototype.timer_schedule = function (T, N) {
    this.timer_cancel(N);
    var This = this;
    var s_code = tsk_string_format("This.o_timer{1} = setTimeout(function(){ __tsip_dialog_{0}_timer_callback(This, This.o_timer{1})}, This.i_timer{1});", T, N);
    eval(s_code);
}

tsip_dialog.prototype.timer_cancel = function (N) {
    var s_code = tsk_string_format("if(this.o_timer{0}) { clearTimeout(this.o_timer{0}); this.o_timer{0} = null; }", N);
    eval(s_code);
}

tsip_dialog.prototype.callback = function (e_event_type, o_message) {
    if (this.fn_callback) {
        return this.fn_callback(this, e_event_type, o_message);
    }
    tsk_utils_log_error("Invalid callback function");
    return -1;
}

tsip_dialog.prototype.set_callback = function (fn_callback) {
    this.fn_callback = fn_callback;
}

tsip_dialog.prototype.fsm_act = function (i_action, o_message, o_action) {
    if (!this.o_fsm) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }
    return this.o_fsm.act(i_action, this.o_fsm.get_usr_data(), o_message, this.o_fsm.get_usr_data(), o_message, o_action);
}

tsip_dialog.prototype.hangup = function (o_action) {
    if (this.e_state == tsip_dialog_state_e.ESTABLISHED || (this.o_session && this.o_session.b_server && this.e_state == tsip_dialog_state_e.EARLY) || this.e_type != tsip_dialog_type_e.INVITE) {
        return this.fsm_act(tsip_action_type_e.HANGUP, null, o_action); // 603 Decline or BYE
    }
    else {
        return this.fsm_act(tsip_action_type_e.CANCEL, null, o_action); // CANCEL -> only for INVITE dialog
    }
}

// o_action is optional
tsip_dialog.prototype.shutdown = function (o_action) {
    return this.fsm_act(tsip_action_type_e.SHUTDOWN, null, o_action);
}

tsip_dialog.prototype.update_with_response = function (o_response) {
    if (!o_response || !o_response.is_response() || !o_response.o_hdr_To) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    var i_code = o_response.get_response_code();
    var s_tag = o_response.o_hdr_To.s_tag;

    /* 	1xx (!100) or 2xx  */
    /*	401 or 407 or 421 or 494 */
    if (i_code == 401 || i_code == 407 || i_code == 421 || i_code == 494) {
        var b_acceptNewVector;

        /* 3GPP IMS - Each authentication vector is used only once.
        *	==> Re-registration/De-registration ==> Allow 401/407 challenge.
        */
        b_acceptNewVector = (o_response.is_response_to_register() && this.e_state == tsip_dialog_state_e.ESTABLISHED);
        return this.update_challenges(o_response, b_acceptNewVector);
    }
    else if (100 < i_code && i_code < 300) {
        var e_state = this.e_state;

        /* 1xx */
        if (i_code <= 199) {
            if (tsk_string_is_null_or_empty(o_response.o_hdr_To.s_tag)) {
                tsk_utils_log_error("Invalid tag  parameter");
                return -1;
            }
            e_state = tsip_dialog_state_e.EARLY;
        }
        /* 2xx */
        else {
            e_state = tsip_dialog_state_e.ESTABLISHED;
        }

        /* Remote target */
        {
            /*	RFC 3261 12.2.1.2 Processing the Responses
            When a UAC receives a 2xx response to a target refresh request, it
            MUST replace the dialog's remote target URI with the URI from the
            Contact header field in that response, if present.

            FIXME: Because PRACK/UPDATE sent before the session is established MUST have
            the rigth target URI to be delivered to the UAS ==> Do not not check that we are connected
            */
            if (!o_response.is_response_to_register() && o_response.o_hdr_Contact && o_response.o_hdr_Contact.o_uri) {
                this.o_uri_remote_target = tsip_uri.prototype.Parse(tsip_uri_tostring(o_response.o_hdr_Contact.o_uri, true, false));
            }
        }

        /* Route sets */
        {
            var i_index;
            var o_hdr_recordRoute;
            this.ao_hdr_record_routes.splice(0, this.ao_hdr_record_routes.length);
            for (i_index = 0; (o_hdr_recordRoute = o_response.get_header_at(tsip_header_type_e.Record_Route, i_index)); ++i_index) {
                this.ao_hdr_record_routes.push(o_hdr_recordRoute);
            }
            this.ao_hdr_record_routes.reverse();
        }


        /* cseq + tags + ... */
        if (this.e_state == tsip_dialog_state_e.ESTABLISHED && tsk_string_iequals(this.s_tag_remote, s_tag)) {
            return 0;
        }
        else {
            if (!o_response.is_response_to_register() && !o_response.is_response_to_publish()) { /* REGISTER and PUBLISH don't establish dialog */
                this.s_tag_remote = s_tag
            }
            // PRACK and BYE will have same CSeq value ==> Let CSeq value to be incremented by "tsip_dialog_request_new()"
            //if (false) {
            //    this.i_cseq_value = o_response.o_hdr_CSeq ? o_response.o_hdr_CSeq.i_seq : this.i_cseq_value;
            //}

        }

        this.e_state = e_state;

        return 0;
    }

    return 0;
}

tsip_dialog.prototype.update_with_invite = function (o_invite) {
    if (!o_invite) {
        tsk_utils_log_error("Invalid parameter");
        return -1;
    }

    /* Remote target */
    if (o_invite.o_hdr_Contact && o_invite.o_hdr_Contact.o_uri) {
        this.o_uri_remote_target = tsip_uri.prototype.Parse(tsip_uri_tostring(o_invite.o_hdr_Contact.o_uri, true, false));
    }

    /* cseq + tags + remote-uri */
    this.s_tag_remote = o_invite.o_hdr_From ? o_invite.o_hdr_From.s_tag : "tag_doubango";
    /* self->cseq_value = invite->CSeq ? invite->CSeq->seq : self->cseq_value; */
    if (o_invite.o_hdr_From && o_invite.o_hdr_From.o_uri) {
        this.o_uri_remote = o_invite.o_hdr_From.o_uri;
    }

    /* Route sets */
    {
        var i_index;
        var o_hdr_recordRoute;
        this.ao_hdr_record_routes.splice(0, this.ao_hdr_record_routes.length);
        for (i_index = 0; (o_hdr_recordRoute = o_invite.get_header_at(tsip_header_type_e.Record_Route, i_index)); ++i_index) {
            this.ao_hdr_record_routes.push(o_hdr_recordRoute);
        }
    }

    this.e_state = tsip_dialog_state_e.EARLY;

    return 0;
}

tsip_dialog.prototype.update_challenges = function (o_response, b_acceptNewVector) {
    var i_ret = -1;
    var o_challenge;

    var o_hdr_WWW_Authenticate;
    var o_hdr_Proxy_Authenticate;

    /* RFC 2617 - HTTP Digest Session

    *	(A) The client response to a WWW-Authenticate challenge for a protection
    space starts an authentication session with that protection space.
    The authentication session lasts until the client receives another
    WWW-Authenticate challenge from any server in the protection space.

    (B) The server may return a 401 response with a new nonce value, causing the client
    to retry the request; by specifying stale=TRUE with this response,
    the server tells the client to retry with the new nonce, but without
    prompting for a new username and password.
    */
    /* RFC 2617 - 1.2 Access Authentication Framework
    The realm directive (case-insensitive) is required for all authentication schemes that issue a challenge.
    */

    /* FIXME: As we perform the same task ==> Use only one loop */

    for (var i = 0; (o_hdr_WWW_Authenticate = o_response.get_header_at(tsip_header_type_e.WWW_Authenticate, i)); i++) {
        var b_isnew = true;

        for (var j = 0; j < this.ao_challenges.length; ++j) {
            o_challenge = this.ao_challenges[j];
            if (o_challenge.b_isproxy) continue;

            if (tsk_string_iequals(o_challenge.s_realm, o_hdr_WWW_Authenticate.s_realm) && (o_hdr_WWW_Authenticate.b_stale || b_acceptNewVector)) {
                /*== (B) ==*/
                if ((i_ret = o_challenge.update(
					o_hdr_WWW_Authenticate.s_scheme,
					o_hdr_WWW_Authenticate.s_realm,
					o_hdr_WWW_Authenticate.s_nonce,
					o_hdr_WWW_Authenticate.s_opaque,
					o_hdr_WWW_Authenticate.s_algorithm,
					o_hdr_WWW_Authenticate.s_qop))) {
                    return i_ret;
                }
                else {
                    b_isnew = false;
                    continue;
                }
            }
            else {
                tsk_utils_log_error("Failed to handle new challenge");
                return -1;
            }
        }

        if (b_isnew) {
            if ((o_challenge = new tsip_challenge(this.get_stack(),
					false,
					o_hdr_WWW_Authenticate.s_scheme,
					o_hdr_WWW_Authenticate.s_realm,
					o_hdr_WWW_Authenticate.s_nonce,
					o_hdr_WWW_Authenticate.s_opaque,
					o_hdr_WWW_Authenticate.s_algorithm,
					o_hdr_WWW_Authenticate.s_qop))) {
                this.ao_challenges.push(o_challenge);
            }
            else {
                tsk_utils_log_error("Failed to handle new challenge");
                return -1;
            }
        }
    }

    for (var i = 0; (o_hdr_Proxy_Authenticate = o_response.get_header_at(tsip_header_type_e.Proxy_Authenticate, i)); i++) {
        var b_isnew = true;

        for (var j = 0; j < this.ao_challenges.length; ++j) {
            o_challenge = this.ao_challenges[j];
            if (!o_challenge.b_isproxy) continue;

            if (tsk_string_iequals(o_challenge.s_realm, o_hdr_Proxy_Authenticate.s_realm) && (o_hdr_Proxy_Authenticate.b_stale || b_acceptNewVector)) {
                /*== (B) ==*/
                if ((i_ret = o_challenge.update(
					o_hdr_Proxy_Authenticate.s_scheme,
					o_hdr_Proxy_Authenticate.s_realm,
					o_hdr_Proxy_Authenticate.s_nonce,
					o_hdr_Proxy_Authenticate.s_opaque,
					o_hdr_Proxy_Authenticate.s_algorithm,
					o_hdr_Proxy_Authenticate.s_qop))) {
                    return i_ret;
                }
                else {
                    b_isnew = false;
                    continue;
                }
            }
            else {
                tsk_utils_log_error("Failed to handle new challenge");
                return -1;
            }
        }

        if (b_isnew) {
            if ((o_challenge = new tsip_challenge(this.get_stack(),
					true,
					o_hdr_Proxy_Authenticate.s_scheme,
					o_hdr_Proxy_Authenticate.s_realm,
					o_hdr_Proxy_Authenticate.s_nonce,
					o_hdr_Proxy_Authenticate.s_opaque,
					o_hdr_Proxy_Authenticate.s_algorithm,
					o_hdr_Proxy_Authenticate.s_qop))) {
                this.ao_challenges.push(o_challenge);
            }
            else {
                tsk_utils_log_error("Failed to handle new challenge");
                return -1;
            }
        }
    }
    return 0;
}

tsip_dialog.prototype.get_newdelay = function (o_message) {
    var i_expires = this.i_expires / 1000; // in seconds
    var i_newdelay = i_expires; /* default value */
    var o_hdr;
    var i_index;
    var b_found = false;

    /* NOTIFY with subscription-state header with expires parameter */
    if (o_message.is_notify()) {
        var o_hdr_state;
        if ((o_hdr_state = o_message.get_header(tsip_header_type_e.Subscription_State))) {
            if (o_hdr_state.i_expires > 0) {
                i_expires = o_hdr_state.i_expires;
                b_found = true;
            }
        }
    }

    /* Expires header */
    if (!b_found && (o_hdr = o_message.get_header(tsip_header_type_e.Expires))) {
        i_expires = o_hdr.i_value;
        b_found = true;
    }

    /* Contact header */
    for (i_index = 0; !b_found && (o_hdr = o_message.get_header_at(tsip_header_type_e.Contact, i_index)); ++i_index) {
        var o_hdr_contact = o_hdr;
        if (o_hdr_contact.o_uri) {
            var s_transport = tsk_param_get_value_by_name(o_hdr_contact.o_uri.ao_params, "transport");
            var o_contactUri = this.get_stack().__get_contact_uri(s_transport ? s_transport : "udp");
            if (o_contactUri) {
                if (tsk_string_equals(o_hdr_contact.o_uri.s_user_name, o_contactUri.s_user_name)
					&& tsk_string_equals(o_hdr_contact.o_uri.s_host, o_contactUri.s_host)
					&& o_hdr_contact.o_uri.i_port == o_contactUri.i_port) {
                    if (o_hdr_contact.i_expires >= 0) { /* No expires parameter ==> -1*/
                        i_expires = o_hdr_contact.i_expires;

                        b_found = false;
                        break;
                    }
                }
            }
        }
    }

    /* 3GPP TS 24.229 - 
    *	The UE shall reregister the public user identity either 600 seconds before the expiration time if the initial 
    *	registration was for greater than 1200 seconds, or when half of the time has expired if the initial registration 
    *	was for 1200 seconds or less.
    */
    i_newdelay = (i_expires > 1200) ? (i_expires - 600) : (i_expires >> 1);

    return (i_newdelay * 1000); // milliseconds
}


tsip_dialog.prototype.ApplyAction = function (o_message, o_action) {
    if (!o_message || !o_action) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    // headers
    for (var i = 0; i < o_action.ao_headers.length; ++i) {
        o_message.add_header(o_action.ao_headers[i]);
    }

    // response line
    if (o_action.line_resp.i_code && o_action.line_resp.s_phrase && o_message.is_response()) {
        o_message.line.response.i_status_code = o_action.line_resp.i_code;
        o_message.line.response.s_reason_phrase = o_action.line_resp.s_phrase; 
    }

    // payload
    if (o_action.o_content) {
        o_message.add_content(o_action.o_content);
    }

    return 0;
}

function tsip_dialog_compare(o_d1, o_d2) {
    if (o_d1 && o_d2) {
        if ((o_d1.s_callid == o_d2.s_callid)
			&& ((o_d1.s_tag_local == o_d2.s_tag_local))
			&& ((o_d1.s_tag_remote == o_d2.s_tag_remote))) {
            return 0;
        }
    }
    return -1;
}

if(!window.__b_release_mode){
    tsip_api_add_js_scripts('head',
        'src/tinySIP/src/dialogs/tsip_dialog_generic.js',
        'src/tinySIP/src/dialogs/tsip_dialog_invite.js',
        'src/tinySIP/src/dialogs/tsip_dialog_register.js'
    );
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/* MESSAGE, OPTIONS, INFO, PUBLISH, SUBSCRIBE */

// SIP dialog SUBSCRIBE (Client side) as per RFC 3265
// SIP dialog OPTIONS as per RFC 3261 section 11
// SIP dialog PUBLISH as per RFC 3903
// SIP dialog MESSAGE as per RFC 3428
// SIP dialog INFO as per RFC 6086

tsip_dialog_generic.prototype = Object.create(tsip_dialog.prototype);
tsip_dialog_generic.prototype.__b_debug_state_machine = true;

var tsip_dialog_generic_actions_e =
{
    ACCEPT: tsip_action_type_e.ACCEPT,
    REJECT: tsip_action_type_e.REJECT,
    HANGUP: tsip_action_type_e.HANGUP,
    CANCEL: tsip_action_type_e.CANCEL,
    SHUTDOWN: tsip_action_type_e.SHUTDOWN,

    O_SUBSCRIBE: tsip_action_type_e.SUBSCRIBE,
    O_OPTIONS: tsip_action_type_e.OPTIONS,
    O_MESSAGE: tsip_action_type_e.MESSAGE,
    O_INFO: tsip_action_type_e.INFO,
    O_PUBLISH: tsip_action_type_e.PUBLISH,
    O_UNPUBLISH: tsip_action_type_e.UNPUBLISH,

    I_SUBSCRIBE: 10000,
    I_MESSAGE: 10001,
    I_OPTIONS: 10002,
    I_INFO: 10003,
    I_PUBLISH: 10004,
    I_NOTIFY: 10005,

    I_1XX: 50000,
    I_2XX: 50001,
    I_401_407_421_494: 50002,
    I_423: 50003,
    I_300_to_699: 50004,

    SHUTDOWN_TIMEDOUT: 60000,
    TRANSPORT_ERROR: 60002,
    ERROR: 60003	
};

var tsip_dialog_generic_states_e =
{
    STARTED: 0,
    INPROGRESS: 1, // outgoing(client)
    INCOMING: 2, // incoming (server)
    CONNECTED: 3,
    TERMINATED: 4
};

function tsip_dialog_generic(e_type, o_session, s_call_id) {
    tsip_dialog.call(this);

    this.b_disconnecting = false;
    this.o_last_iMessage = null;

    this.o_timerRefresh = null;
    this.o_timerShutdown = null;
    this.i_timerShutdown = (tsip_dialog.prototype.__i_timer_shutdown << 1) / 3;

    this.init(e_type, s_call_id, o_session, tsip_dialog_generic_states_e.STARTED, tsip_dialog_generic_states_e.TERMINATED);
    this.set_callback(__tsip_dialog_generic_event_callback);
    this.o_fsm.set_debug_enabled(tsip_dialog_generic.prototype.__b_debug_state_machine);
    this.o_fsm.set_onterm_callback(__tsip_dialog_generic_onterm, this);


    // initialize state machines
    this.init_message(); // MESSAGE Dialog
    this.init_publish(); // PUBLISH Dialog
    this.init_subscribe(); // SUBSCRIBE DIALOG
    this.o_fsm.set(
        /*=======================
        * === Started === 
        */
        // Up to each dialog (MESSAGE, PUBLISH, SUBSCRIBE...)


        /*=======================
        * === InProgress === 
        */
        // InProgress -> (1xx) -> InProgress
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_actions_e.I_1XX, tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_InProgress_2_InProgress_X_1xx, "tsip_dialog_generic_InProgress_2_InProgress_X_1xx"),
        
        // InProgress -> (2xx dialogless) -> Terminated
        tsk_fsm_entry.prototype.Create(tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_actions_e.I_2XX, __tsip_dialog_generic_cond_is_dialogless, tsip_dialog_generic_states_e.TERMINATED, tsip_dialog_generic_InProgress_2_Terminated_X_2xx, "tsip_dialog_generic_InProgress_2_Terminated_X_2xx"),
        // InProgress -> (2xx disconnecting) -> Terminated
        tsk_fsm_entry.prototype.Create(tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_actions_e.I_2XX, __tsip_dialog_generic_cond_is_disconnecting, tsip_dialog_generic_states_e.TERMINATED, tsip_dialog_generic_InProgress_2_Terminated_X_2xx, "tsip_dialog_generic_InProgress_2_Terminated_X_2xx"),
        // InProgress -> (2xx dialogfull and connecting) -> Connected
        tsk_fsm_entry.prototype.Create(tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_actions_e.I_2XX, __tsip_dialog_generic_cond_is_dialogfull, tsip_dialog_generic_states_e.CONNECTED, tsip_dialog_generic_InProgress_2_Connected_X_2xx, "tsip_dialog_generic_InProgress_2_Connected_X_2xx"),
        // InProgress -> (401/407/421/494) -> InProgress
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_actions_e.I_401_407_421_494, tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_InProgress_2_InProgress_X_401_407_421_494, "tsip_dialog_generic_InProgress_2_InProgress_X_401_407_421_494"),
        // InProgress -> (300_to_699) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_actions_e.I_300_to_699, tsip_dialog_generic_states_e.TERMINATED, tsip_dialog_generic_InProgress_2_Terminated_X_300_to_699, "tsip_dialog_generic_InProgress_2_Terminated_X_300_to_699"),
        // InProgress -> (cancel) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_actions_e.CANCEL, tsip_dialog_generic_states_e.TERMINATED, tsip_dialog_generic_InProgress_2_Terminated_X_cancel, "tsip_dialog_generic_InProgress_2_Terminated_X_cancel"),
        // InProgress -> (shutdown) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_actions_e.SHUTDOWN, tsip_dialog_generic_states_e.TERMINATED, null, "tsip_dialog_generic_InProgress_2_Terminated_X_shutdown"),
        // InProgress -> (Any) -> InProgress
        // tsk_fsm_entry.prototype.CreateAlwaysNothing(tsip_dialog_generic_states_e.INPROGRESS, "tsip_dialog_generic_InProgress_2_InProgress_X_any"),

        /*=======================
        * === Incoming === 
        */
        // Incoming -> (accept) -> Terminated
        tsk_fsm_entry.prototype.Create(tsip_dialog_generic_states_e.INCOMING, tsip_dialog_generic_actions_e.ACCEPT, __tsip_dialog_generic_cond_is_dialogless, tsip_dialog_generic_states_e.TERMINATED, tsip_dialog_generic_Incoming_2_Terminated_X_accept, "tsip_dialog_generic_Incoming_2_Terminated_X_accept"),
        // Incoming -> (accept) -> Connected
        tsk_fsm_entry.prototype.Create(tsip_dialog_generic_states_e.INCOMING, tsip_dialog_generic_actions_e.ACCEPT, __tsip_dialog_generic_cond_is_dialogfull, tsip_dialog_generic_states_e.CONNECTED, tsip_dialog_generic_Incoming_2_Connected_X_accept, "tsip_dialog_generic_Incoming_2_Connected_X_accept"),
        // Incoming -> (rejected) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_generic_states_e.INCOMING, tsip_dialog_generic_actions_e.REJECT, tsip_dialog_generic_states_e.TERMINATED, tsip_dialog_generic_Incoming_2_Terminated_X_reject, "tsip_dialog_generic_Incoming_2_Terminated_X_reject"),
        // Incoming -> (Any) -> Incoming
        tsk_fsm_entry.prototype.CreateAlwaysNothing(tsip_dialog_generic_states_e.INCOMING, "tsip_dialog_generic_Incoming_2_Incoming_X_any"),

        /*=======================
        * === Any === 
        */
        // Any -> (hangup) -> InProgress
		tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.HANGUP, __tsip_dialog_generic_cond_not_silent_hangup, tsip_dialog_generic_states_e.INPROGRESS, __tsip_dialog_generic_Any_2_InProgress_X_hangup, "tsip_dialog_generic_Any_2_InProgress_X_hangup"),
        // Any -> (silenthangup) -> Terminated
		tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.HANGUP, __tsip_dialog_generic_cond_silent_hangup, tsip_dialog_generic_states_e.TERMINATED, null, "tsip_dialog_generic_Any_2_InProgress_X_silenthangup"),
        // Any -> (shutdown) -> InProgress
		tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.SHUTDOWN, __tsip_dialog_generic_cond_not_silent_shutdown, tsip_dialog_generic_states_e.INPROGRESS, __tsip_dialog_generic_Any_2_InProgress_X_shutdown, "tsip_dialog_generic_Any_2_InProgress_X_shutdown"),
		// Any -> (silentshutdown) -> Terminated
		tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.SHUTDOWN, __tsip_dialog_generic_cond_silent_shutdown, tsip_dialog_generic_states_e.TERMINATED, null, "tsip_dialog_generic_Any_2_InProgress_X_silentshutdown"),
		// Any -> (shutdown timedout) -> Terminated
		tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.SHUTDOWN_TIMEDOUT, tsip_dialog_generic_states_e.TERMINATED, null, "tsip_dialog_generic_shutdown_timedout"),
        // Any -> (transport error) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.TRANSPORT_ERROR, tsip_dialog_generic_states_e.TERMINATED, tsip_dialog_generic_Any_2_Terminated_X_transportError, "tsip_dialog_generic_Any_2_Terminated_X_transportError"),
        // Any -> (error) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.ERROR, tsip_dialog_generic_states_e.TERMINATED, tsip_dialog_generic_Any_2_Terminated_X_Error, "tsip_dialog_generic_Any_2_Terminated_X_Error")

    );
}

tsip_dialog_generic.prototype.signal_ao = function (i_code, s_phrase, o_response) {
    var o_event;
    switch (this.e_type) {
        case tsip_dialog_type_e.MESSAGE:
            {
                var o_event = new tsip_event_message(this.get_session(), i_code, s_phrase, o_response, tsip_event_message_type_e.AO_MESSAGE);
                return o_event.signal();
            }
        case tsip_dialog_type_e.PUBLISH:
            {
                var o_event = new tsip_event_publish(this.get_session(), i_code, s_phrase, o_response, tsip_event_publish_type_e.AO_PUBLISH);
                return o_event.signal();
            }
        case tsip_dialog_type_e.SUBSCRIBE:
            {
                var o_event = new tsip_event_subscribe(this.get_session(), i_code, s_phrase, o_response, tsip_event_subscribe_type_e.AO_SUBSCRIBE);
                return o_event.signal();
            }
    }

    tsk_utils_log_error("not implemented");
    return -1;
}

tsip_dialog_generic.prototype.signal_i = function (i_code, s_phrase, o_request) {
    var o_event;
    switch (this.e_type) {
        case tsip_dialog_type_e.MESSAGE:
            {
                if (o_request.is_message()) {
                    var o_event = new tsip_event_message(this.get_session(), i_code, s_phrase, o_request, tsip_event_message_type_e.I_MESSAGE);
                    return o_event.signal();
                }
                break;
            }
        case tsip_dialog_type_e.SUBSCRIBE:
            {
                if (o_request.is_notify()) {
                    var o_event = new tsip_event_subscribe(this.get_session(), i_code, s_phrase, o_request, tsip_event_subscribe_type_e.I_NOTIFY);
                    return o_event.signal();
                }
                break;
            }
    }

    tsk_utils_log_error("not implemented");
    return -1;
}

function __tsip_dialog_generic_timer_callback(o_self, o_timer) {
    var i_ret = -1;
    if (o_self) {
        if (o_self.o_timerRefresh == o_timer) {
            switch (o_self.e_type) {
                case tsip_dialog_type_e.PUBLISH: i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.O_PUBLISH, null, null); break;
                case tsip_dialog_type_e.SUBSCRIBE: i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.O_SUBSCRIBE, null, null); break; 
            }
        }
        else if (o_self.o_timerShutdown == o_timer) {
            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.SHUTDOWN, null, null);
        }
    }
    return i_ret;
}

function __tsip_dialog_generic_event_callback(o_self, e_type, o_message) {
    var i_ret = -1;

    switch (e_type) {
        case tsip_dialog_event_type_e.I_MSG:
            {
                if (o_message) {
                    if (o_message.is_response()) { //	RESPONSE
                        if (o_message.is_1xx()) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_1XX, o_message, null);
                        }
                        else if (o_message.is_2xx()) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_2XX, o_message, null);
                        }
                        else if (o_message.is_response_xxx(401) || o_message.is_response_xxx(407) || o_message.is_response_xxx(421) || o_message.is_response_xxx(494)) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_401_407_421_494, o_message, null);
                        }
                        else if (o_message.is_response_xxx(423)) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_423, o_message, null);
                        }
                        else if (o_message.is_3456()) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_300_to_699, o_message, null);
                        }
                        else {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.ERROR, o_message, null);
                        }
                    }
                    else { //	REQUEST
                        if (o_message.is_message()) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_MESSAGE, o_message, null);
                        }
                        else if (o_message.is_options()) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_OPTIONS, o_message, null);
                        }
                        else if (o_message.is_notify()) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_NOTIFY, o_message, null);
                        }
                        else if (o_message.is_subscribe()) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_SUBSCRIBE, o_message, null);
                        }
                        else if (o_message.is_info()) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_INFO, o_message, null);
                        }
                        else if (o_message.is_publish()) {
                            i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.I_PUBLISH, o_message, null);
                        }
                    }
                }
                break;
            }

        case tsip_dialog_event_type_e.CANCELED:
            {
                i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.CANCEL, o_message, null);
                break;
            }

        case tsip_dialog_event_type_e.TERMINATED:
        case tsip_dialog_event_type_e.TIMEDOUT:
        case tsip_dialog_event_type_e.ERROR:
        case tsip_dialog_event_type_e.TRANSPORT_ERROR:
            {
                i_ret = o_self.fsm_act(tsip_dialog_generic_actions_e.TRANSPORT_ERROR, o_message, null);
                break;
            }
    }

    return i_ret;
}


/* ======================== conds ======================== */
function __tsip_dialog_generic_cond_is_dialogless(o_dialog, o_message) { // /!\ Not dialogless in SIP meaning but just to say "2xx->Terminated" instead of "2xx->Connected"
    switch(o_dialog.e_type){
        case tsip_dialog_type_e.INFO:
        case tsip_dialog_type_e.MESSAGE:
        case tsip_dialog_type_e.OPTIONS:
            return true;
        default: return false;
    }
}
function __tsip_dialog_generic_cond_is_dialogfull(o_dialog, o_message){
    return !__tsip_dialog_generic_cond_is_dialogless(o_dialog, o_message);
}
function __tsip_dialog_generic_cond_is_resp2message(o_dialog, o_message) {
    return o_message.is_response_to_message();
}
function __tsip_dialog_generic_cond_is_message(o_dialog, o_message) {
    return o_message.is_message();
}
function __tsip_dialog_generic_cond_is_disconnecting(o_dialog, o_message) {
    return o_dialog.b_disconnecting;
}
function __tsip_dialog_generic_cond_is_connecting(o_dialog, o_message) {
    return !__tsip_dialog_generic_cond_is_disconnecting(o_dialog, o_message);
}
function __tsip_dialog_generic_cond_silent_hangup(o_dialog, o_message){
	return o_dialog.o_session.b_silent_hangup;
}
function __tsip_dialog_generic_cond_not_silent_hangup(o_dialog, o_message){
    return !__tsip_dialog_generic_cond_silent_hangup(o_dialog, o_message);
}
function __tsip_dialog_generic_cond_silent_shutdown(o_dialog, o_message) {
    return __tsip_dialog_generic_cond_silent_hangup(o_dialog, o_message);
}
function __tsip_dialog_generic_cond_not_silent_shutdown(o_dialog, o_message) {
    return !__tsip_dialog_generic_cond_silent_shutdown(o_dialog, o_message);
}


//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------


// InProgress -> (1xx) -> InProgress
function tsip_dialog_generic_InProgress_2_InProgress_X_1xx(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

    return o_dialog.signal_ao(o_response.get_response_code(), o_response.get_response_phrase(), o_response);
}

// InProgress -> (2xx) -> Terminated
function tsip_dialog_generic_InProgress_2_Terminated_X_2xx(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

    return o_dialog.signal_ao(o_response.get_response_code(), o_response.get_response_phrase(), o_response);
}

// InProgress -> (2xx) -> Connected
function tsip_dialog_generic_InProgress_2_Connected_X_2xx(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

    var b_first_time_to_connect = (o_dialog.e_state == tsip_dialog_state_e.INITIAL);

    // Update the dialog state
	if((i_ret = o_dialog.update_with_response(o_response)) != 0){
		return i_ret;
	}

    // Etag
    if(o_dialog.e_type == tsip_dialog_type_e.PUBLISH){
        /*	RFC 3903 - 4.1.  Identification of Published Event State
		    For each successful PUBLISH request, the ESC will generate and assign
		    an entity-tag and return it in the SIP-ETag header field of the 2xx
		    response.
	    */
        var o_hdr_etag;
        if ((o_hdr_etag = o_response.get_header(tsip_header_type_e.SIP_ETag))) {
            if(o_hdr_etag.s_value){
                o_dialog.s_etag = o_hdr_etag.s_value;
            }
            else{
                tsk_utils_log_warn("SIP-ETag header without value: Is it a bug?");
            }
        }
    }

    // Reset current action */
	o_dialog.set_action_curr(null);

    // Request timeout for dialog refresh (e.g re-registration)
	o_dialog.i_timerRefresh = o_dialog.get_newdelay(o_response);
	o_dialog.timer_schedule('generic', 'Refresh');

    // alert user
    o_dialog.signal_ao(o_response.get_response_code(), o_response.get_response_phrase(), o_response);
	if (b_first_time_to_connect) {
	    o_dialog.signal(tsip_event_code_e.DIALOG_CONNECTED, "Connected");
	}

    return 0;
}

// InProgress -> (401/407/421/494) -> InProgress
function tsip_dialog_generic_InProgress_2_InProgress_X_401_407_421_494(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];
    var i_ret;

    if ((i_ret = o_dialog.update_with_response(o_response))) {
        // alert user
        o_dialog.signal_ao(o_response.get_response_code(), o_response.get_response_phrase(), o_response);

        // set last error
        o_dialog.set_last_error(o_response.get_response_code(), o_response.get_response_phrase(), o_response);

        return i_ret;
    }

    switch (o_dialog.e_type) {
        case tsip_dialog_type_e.MESSAGE:
            {
                return o_dialog.send_message();
            }
        case tsip_dialog_type_e.PUBLISH:
            {
                return o_dialog.send_publish();
            }
        case tsip_dialog_type_e.SUBSCRIBE:
            {
                return o_dialog.send_subscribe();
            }
    }
    return 0;
}

// InProgress -> (300_to_699) -> Terminated
function tsip_dialog_generic_InProgress_2_Terminated_X_300_to_699(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

    // save last error
	o_dialog.set_last_error(o_response.get_response_code(), o_response.get_response_phrase(), o_response);

    return o_dialog.signal_ao(o_response.get_response_code(), o_response.get_response_phrase(), o_response);
}

// InProgress -> (cancel) -> Terminated
function tsip_dialog_generic_InProgress_2_Terminated_X_cancel(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

// Incoming -> (accept) -> Terminated
function tsip_dialog_generic_Incoming_2_Terminated_X_accept(ao_args) {
    var o_dialog = ao_args[0];
    var o_action = ao_args[2];    
	
	if(!o_dialog.o_last_iMessage){
		tsk_utils_log_error("Invalid state");
		/* Not an error ...but do not update current action */
	}
	else{
		var o_response;
		var i_ret = -1;

		o_dialog.set_action_curr(o_action);
		if ((o_response = o_dialog.response_new(200, "OK", o_dialog.o_last_iMessage))) {
		    if ((i_ret = tsip_dialog.prototype.ApplyAction(o_response, o_action)) == 0) {
		        if ((i_ret = o_dialog.response_send(o_response))) {
		            tsk_utils_log_error("Failed to send SIP response.");
		            return i_ret;
		        }
		    }
		}
		else{
			tsk_utils_log_error("Failed to create SIP response.");
			return -1;
		}
	}

	return 0;
}

// Incoming -> (accept) -> Connected
function tsip_dialog_generic_Incoming_2_Connected_X_accept(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

// Incoming -> (rejected) -> Terminated
function tsip_dialog_generic_Incoming_2_Terminated_X_reject(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

// Any -> (hangup) -> InProgress
function __tsip_dialog_generic_Any_2_InProgress_X_hangup(ao_args){
    var o_dialog = ao_args[0];
	var o_action = ao_args[2];

	// set  current action
    o_dialog.set_action_curr(o_action);

	// alert the user
    o_dialog.signal(tsip_event_code_e.DIALOG_TERMINATING, "Disconnecting...");

    o_dialog.b_disconnecting = true;
    switch (o_dialog.e_type) {
        case tsip_dialog_type_e.PUBLISH:
            {
                return o_dialog.send_publish();
            }
        case tsip_dialog_type_e.SUBSCRIBE:
            {
                return o_dialog.send_subscribe();
            }
    }
	return 0;
}

// Any -> (shutdown) -> InProgress
function __tsip_dialog_generic_Any_2_InProgress_X_shutdown(ao_args) {
    var o_dialog = ao_args[0];
	
	// schedule shutdow timer
    o_dialog.timer_schedule('generic', 'Shutdown');

	// alert user
    o_dialog.signal(tsip_event_code_e.DIALOG_TERMINATING, "Disconnecting...");

	o_dialog.b_disconnecting = true;
	switch (o_dialog.e_type) {
        case tsip_dialog_type_e.PUBLISH:
            {
                return o_dialog.send_publish();
            }
        case tsip_dialog_type_e.SUBSCRIBE:
            {
                return o_dialog.send_subscribe();
            }
    }
    return 0;
}


// Any -> (transport error) -> Terminated
function tsip_dialog_generic_Any_2_Terminated_X_transportError(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

// Any -> (transport error) -> Terminated
function tsip_dialog_generic_Any_2_Terminated_X_Error(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++



function __tsip_dialog_generic_onterm(o_self) {
    tsk_utils_log_info("=== " + o_self.e_type.s_name + " Dialog terminated ===");
    
    o_self.timer_cancel('Refresh');
    o_self.timer_cancel('Shutdown');

    o_self.signal(tsip_event_code_e.DIALOG_TERMINATED,
            o_self.last_error.s_phrase ? o_self.last_error.s_phrase : "Disconnected",
            o_self.last_error.o_message);

    // deinit
    return o_self.deinit();
}


if(!window.__b_release_mode){
    tsip_api_add_js_scripts('head',
        'src/tinySIP/src/dialogs/tsip_dialog_generic__message.js',
        'src/tinySIP/src/dialogs/tsip_dialog_generic__publish.js',
        'src/tinySIP/src/dialogs/tsip_dialog_generic__subscribe.js'
    );
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_dialog_generic.prototype.init_message = function () {
    
    this.o_fsm.set(
        /*=======================
		* === Started === 
		*/
        // Started -> (SEND MESSAGE) -> InProgress
	    tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_generic_states_e.STARTED, tsip_dialog_generic_actions_e.O_MESSAGE, tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_Started_2_InProgress_X_oMessage, "tsip_dialog_generic_Started_2_InProgress_X_oMessage"),
        // Started -> (RECV MESSAGE) -> Incoming
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_generic_states_e.STARTED, tsip_dialog_generic_actions_e.I_MESSAGE, tsip_dialog_generic_states_e.INCOMING, tsip_dialog_generic_Started_2_Incoming_X_iMessage, "tsip_dialog_generic_Started_2_Incoming_X_iMessage")

    );

}

tsip_dialog_generic.prototype.send_message = function () {
    var o_request;
    var i_ret = -1;

    if ((o_request = this.request_new("MESSAGE"))) {
        /* apply action params to the request */
        if (this.get_action_curr()) {
            if ((i_ret = tsip_dialog.prototype.ApplyAction(o_request, this.get_action_curr())) == 0) {
                i_ret = this.request_send(o_request);
            }
        }
    }

    return i_ret;
}


//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

// Started -> (SEND MESSAGE) -> InProgress
function tsip_dialog_generic_Started_2_InProgress_X_oMessage(ao_args) {
    var o_dialog = ao_args[0];
    var o_action = ao_args[2];

    o_dialog.b_running = true;
    o_dialog.set_action_curr(o_action);

    return o_dialog.send_message();
}

// Started -> (RECV MESSAGE) -> Incoming
function tsip_dialog_generic_Started_2_Incoming_X_iMessage(ao_args) {
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];

    o_dialog.signal_i(tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Request", o_request);
	o_dialog.o_last_iMessage = o_request;
    return 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

tsip_dialog_generic.prototype.init_publish = function () {
    this.s_etag = null;
    this.o_fsm.set(
        // Any -> (SEND PUBLISH) -> InProgress
	    tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.O_PUBLISH, tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_Any_2_InProgress_X_oPublish, "tsip_dialog_generic_Any_2_InProgress_X_oPublish")      
    );
}

tsip_dialog_generic.prototype.send_publish = function () {
    var o_request;
    var i_ret = -1;

    if(this.b_disconnecting){
        this.i_expires = 0;
    }

    /*	RFC 3903 - 4.1.  Identification of Published Event State
		The presence of a body and the SIP-If-Match header field determine
		the specific SSESSION that the request is performing, as described in Table 1.
		+-----------+-------+---------------+---------------+
		| SSESSION | Body? | SIP-If-Match? | Expires Value |
		+-----------+-------+---------------+---------------+
		| Initial   | yes   | no            | > 0           |
		| Refresh   | no    | yes           | > 0           |
		| Modify    | yes   | yes           | > 0           |
		| Remove    | no    | yes           | 0             |
		+-----------+-------+---------------+---------------+
		Table 1: Publication sessions
	*/

    if ((o_request = this.request_new("PUBLISH"))) {
        /* apply action params to the request */
        var o_action = this.get_action_curr();
        if(o_action && (i_ret = tsip_dialog.prototype.ApplyAction(o_request, o_action))){
            return i_ret;
        }

        /* Etag. If initial then etag is null or undefined */
		if(this.s_etag){
            o_request.add_header(new tsip_header_SIP_If_Match(this.s_etag));
		}
        i_ret = this.request_send(o_request);        
    }

    return i_ret;
}

//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

// Any -> (SEND PUBLISH) -> InProgress
function tsip_dialog_generic_Any_2_InProgress_X_oPublish(ao_args) {
    var o_dialog = ao_args[0];
    var o_action = ao_args[2];

    if(!o_dialog.b_running){
        o_dialog.b_running = true;
    }
    o_dialog.set_action_curr(o_action);

    // alert user
    if(o_dialog.e_state == tsip_dialog_state_e.INITIAL){
        o_dialog.signal(tsip_event_code_e.DIALOG_CONNECTING, "Connecting...");
    }

    return o_dialog.send_publish();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++


/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

tsip_dialog_generic.prototype.init_subscribe = function () {
    this.s_etag = null;
    this.o_fsm.set(
        // Any -> (SEND SUBSCRIBE) -> InProgress
	    tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.O_SUBSCRIBE, tsip_dialog_generic_states_e.INPROGRESS, tsip_dialog_generic_Any_2_InProgress_X_oSubscribe, "tsip_dialog_generic_Any_2_InProgress_X_oSubscribe"),     
        // Any -> (INCOMING NOTIFY) -> Any
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_actions_e.I_NOTIFY, tsk_fsm.prototype.__i_state_any, tsip_dialog_generic_Any_2_Any_X_iNotify, "tsip_dialog_generic_Any_2_Any_X_iNotify") 
    );
}

tsip_dialog_generic.prototype.send_subscribe = function () {
    var o_request;
    var i_ret = -1;

    if(this.b_disconnecting){
        this.i_expires = 0;
    }

    if ((o_request = this.request_new("SUBSCRIBE"))) {
        /* apply action params to the request */
        var o_action = this.get_action_curr();
        if(o_action && (i_ret = tsip_dialog.prototype.ApplyAction(o_request, o_action))){
            return i_ret;
        }
        i_ret = this.request_send(o_request);
    }

    return i_ret;
}

//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

// Any -> (SEND SUBSCRIBE) -> InProgress
function tsip_dialog_generic_Any_2_InProgress_X_oSubscribe(ao_args) {
    var o_dialog = ao_args[0];
    var o_action = ao_args[2];

    if(!o_dialog.b_running){
        o_dialog.b_running = true;
    }
    o_dialog.set_action_curr(o_action);

    // alert user
    if(o_dialog.e_state == tsip_dialog_state_e.INITIAL){
        o_dialog.signal(tsip_event_code_e.DIALOG_CONNECTING, "Connecting...");
    }

    return o_dialog.send_subscribe();
}


// Any -> (INCOMING NOTIFY) -> Any
function tsip_dialog_generic_Any_2_Any_X_iNotify(ao_args) {
     var o_dialog = ao_args[0];
     var o_request = ao_args[1];

     /* Send 2xx NOTIFY */
     var o_response;
     var i_ret = -1;
     if ((o_response = o_dialog.response_new(200, 'OK', o_request))) {
        i_ret = o_dialog.response_send(o_response);
     }

     // update timeout using expires from subscription state (e.g. 'Subscription-State: pending;expires=200')
     o_dialog.i_timerRefresh = o_dialog.get_newdelay(o_request);
	 o_dialog.timer_schedule('generic', 'Refresh');

     // alert user
     o_dialog.signal_i(tsip_event_code_e.DIALOG_REQUEST_INCOMING, 'Incoming NOTIFY', o_request);

     return i_ret;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++


/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
// http://cdnet.stpi.org.tw/techroom/market/_pdf/2009/eetelecomm_09_009_OneVoiceProfile.pdf
// 3GPP TS 26.114 (MMTel): Media handling and interaction
// 3GPP TS 24.173 (MMTel): Supplementary Services
//
/* ======================== MMTel Supplementary Services ======================== 
3GPP TS 24.607 : Originating Identification Presentation
3GPP TS 24.608 : Terminating Identification Presentation
3GPP TS 24.607 : Originating Identification Restriction
3GPP TS 24.608 : Terminating Identification Restriction

3GPP TS 24.604 : Communication Diversion Unconditional
3GPP TS 24.604 : Communication Diversion on not Logged
3GPP TS 24.604 : Communication Diversion on Busy 
3GPP TS 24.604 : Communication Diversion on not Reachable
3GPP TS 24.604 : Communication Diversion on No Reply
3GPP TS 24.611 : Barring of All Incoming Calls
3GPP TS 24.611 : Barring of All Outgoing Calls
3GPP TS 24.611 : Barring of Outgoing International Calls
3GPP TS 24.611 : Barring of Incoming Calls - When Roaming
3GPP TS 24.610 : Communication Hold 
3GPP TS 24.606 : Message Waiting Indication
3GPP TS 24.615 : Communication Waiting
3GPP TS 24.605 : Ad-Hoc Multi Party Conference
*/
tsip_dialog_invite.prototype = Object.create(tsip_dialog.prototype);
tsip_dialog_invite.prototype.__b_debug_state_machine = true;
tsip_dialog_invite.prototype.__i_lo_sdp_request_timeout = 50000000; //FIXME

var tsip_dialog_invite_next_offer_type_e =
{
    NONE: 0,
    INVITE: 1,
    UPDATE: 2,
    SUCCESS: 3
};

var tsip_dialog_invite_actions_e = 
{
	ACCEPT: tsip_action_type_e.ACCEPT,
	REJECT: tsip_action_type_e.HANGUP,
	DTMF_SEND: tsip_action_type_e.DTMF_SEND,
	MSRP_SEND_MSG: tsip_action_type_e.LARGE_MESSAGE,
	O_INVITE: tsip_action_type_e.INVITE,
	O_CANCEL: tsip_action_type_e.CANCEL,
	O_HOLD: tsip_action_type_e.HOLD,
	O_RESUME: tsip_action_type_e.RESUME,
	O_ECT: tsip_action_type_e.ECT,
	I_ECT_ACCEPT: tsip_action_type_e.ECT_ACCEPT,
	I_ECT_REJECT: tsip_action_type_e.ECT_REJECT,
	I_ECT_LNOTIFY: tsip_action_type_e.ECT_NOTIFY,
	O_INFO: tsip_action_type_e.INFO,
	O_BYE: tsip_action_type_e.HANGUP,
	O_SHUTDOWN: tsip_action_type_e.SHUTDOWN,

	I_INVITE: 10001,
	O_UPDATE: 10002,
	I_UPDATE: 10003,
	I_CANCEL: 10004,
	I_PRACK: 10005,
	O_PRACK: 10006,
	I_ACK: 10007,
	O_ACK: 10008,
	I_OPTIONS: 10009,
	O_OPTIONS: 10010,
	I_BYE: 10011,
	I_REFER: 10012,
	I_INFO: 10013,
	I_NOTIFY: 10014,

	TIMER_100REL: 20001,
	TIMER_REFRESH: 20002,
	TIMER_RSVP: 20003,
    TIMER_LO_SDP_REQUEST: 20004,

	I_1XX: 30001,
	I_2XX: 30002,
	I_300_to_699: 30003,
	I_401_407: 30004,
	i_422: 30005,

	SHUTDOWN_TIMEDOUT: 40001, /* Any -> Terminated */
	TRANSPORT_ERROR: 40002,
	ERROR: 40003
};

var tsip_dialog_invite_states_e =
{
	STARTED: 1,
	OUTGOING: 2,
	INCOMING: 3,
	TRYING: 4,
	RINGING: 5,
	CANCELLING: 6,
	INPROGRESS: 7,

	HOLDING: 20,
	RESUMING: 21,

	O_ECT_INPROGRESS: 40,
	I_ECT_INPROGRESS: 41,
	I_ECT_REQUESTED: 42,

	CONNECTED: 60,
	TERMINATED: 61
};

function tsip_dialog_invite(o_session, s_call_id) {
    tsip_dialog.call(this);

    // default values
    this.o_last_oInvite = null;
    this.o_wait_oMessage = null;

    this.o_last_iOffer = null;
    this.o_last_iRefer = null;
    this.o_ss_transf = null;
    this.e_next_offer_type = tsip_dialog_invite_next_offer_type_e.NONE;

    this.i_rseq = 0;
    this.b_support_update = false;

    this.supported = {};
    this.supported.b_100rel = o_session.media.b_100rel;
    this.supported.b_norefsub = true;
    this.supported.b_refer_sub = true;
    this.supported.b_timer = (o_session.media.timers.i_timeout > 0);

    this.require = {};
    this.require.b_100rel = false;
    this.require.b_norefsub = false;
    this.require.b_timer = false;

    this.hold = {};
    this.hold.b_local = false;
    this.hold.b_remote = false;

    this.init(tsip_dialog_type_e.INVITE, s_call_id, o_session, tsip_dialog_invite_states_e.STARTED, tsip_dialog_invite_states_e.TERMINATED);
    this.set_callback(__tsip_dialog_invite_event_callback);
    this.o_fsm.set_debug_enabled(tsip_dialog_invite.prototype.__b_debug_state_machine);
    this.o_fsm.set_onterm_callback(__tsip_dialog_invite_onterm, this);

    this.o_msession_mgr = null;
    this.b_is_client = false;
    this.b_is_transf = false;

    this.o_timerShutdown = null;
    this.i_timerShutdown = (tsip_dialog.prototype.__i_timer_shutdown >> 1);

    this.stimers = {};
    this.stimers.i_timeout = o_session.media.timers.i_timeout;
    this.stimers.s_refresher = null;
    this.stimers.i_minse = 0;
    this.stimers.b_is_refresher = false;

    this.o_timer100Rel = null;
    this.i_timer100Rel = 0;
    this.o_timerSession = null;
    this.o_timerShutdown = null;
    this.i_timerShutdown = tsip_dialog.prototype.__i_timer_shutdown;
    this.o_timerLoSdpRequest = null;
    this.i_timerLoSdpRequest = tsip_dialog_invite.prototype.__i_lo_sdp_request_timeout;

    // initialize "common" state machine
    this.o_fsm.set(
        /*=======================
        * === Started === 
        */
        // Started -> (Any) -> Started
        tsk_fsm_entry.prototype.CreateAlwaysNothing(tsip_dialog_invite_states_e.STARTED, "tsip_dialog_invite_Started_2_Started_X_any"),

        /*=======================
        * === Connected === 
        */
        // Connected -> (Send DTMF) -> Connected
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.DTMF_SEND, tsip_dialog_invite_states_e.CONNECTED, x0000_Connected_2_Connected_X_oDTMF, "x0000_Connected_2_Connected_X_oDTMF"),
        // Connected -> (Send MSRP message) -> Connected
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.MSRP_SEND_MSG, tsip_dialog_invite_states_e.CONNECTED, x0000_Connected_2_Connected_X_oLMessage, "x0000_Connected_2_Connected_X_oLMessage"),
        // Connected -> (iACK) -> Connected
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.I_ACK, tsip_dialog_invite_states_e.CONNECTED, x0000_Connected_2_Connected_X_iACK, "x0000_Connected_2_Connected_X_iACK"),
        // Connected -> (iINVITE) -> Connected
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.I_INVITE, tsip_dialog_invite_states_e.CONNECTED, x0000_Connected_2_Connected_X_iINVITEorUPDATE, "x0000_Connected_2_Connected_X_iINVITE"),
        // Connected -> (iUPDATE) -> Connected
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.I_UPDATE, tsip_dialog_invite_states_e.CONNECTED, x0000_Connected_2_Connected_X_iINVITEorUPDATE, "x0000_Connected_2_Connected_X_iUPDATE"),
        // Connected -> (send reINVITE) -> Connected
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.O_INVITE, tsip_dialog_invite_states_e.CONNECTED, x0000_Connected_2_Connected_X_oINVITE, "x0000_Connected_2_Connected_X_oINVITE"),

        /*=======================
        * === BYE/SHUTDOWN === 
        */
        // Any -> (oBYE) -> Trying
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.O_BYE, tsip_dialog_invite_states_e.TRYING, x0000_Any_2_Trying_X_oBYE, "x0000_Any_2_Trying_X_oBYE"),
        // Any -> (iBYE) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_BYE, tsip_dialog_invite_states_e.TERMINATED, x0000_Any_2_Terminated_X_iBYE, "x0000_Any_2_Terminated_X_iBYE"),
        // Any -> (i3xx-i6xx BYE) -> Terminated
        tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_300_to_699, __tsip_dialog_invite_cond_is_resp2bye, tsip_dialog_invite_states_e.TERMINATED, null, "x0000_Any_2_Terminated_X_i3xxTOi6xxBYE"),
        // Any -> (i2xxx BYE) -> Terminated
        tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2bye, tsip_dialog_invite_states_e.TERMINATED, null, "x0000_Any_2_Terminated_X_i2xxBYE"),
        // Any -> (Shutdown) -> Trying
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.O_SHUTDOWN, tsip_dialog_invite_states_e.TRYING, x0000_Any_2_Trying_X_shutdown, "x0000_Any_2_Trying_X_shutdown"),
        // Any -> (shutdown timedout) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.SHUTDOWN_TIMEDOUT, tsip_dialog_invite_states_e.TERMINATED, null, "tsip_dialog_invite_shutdown_timedout"),


        /*=======================
        * === Any === 
        */
        // Any -> (i1xx) -> Any
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_1XX, tsk_fsm.prototype.__i_state_any, x0000_Any_2_Any_X_i1xx, "x0000_Any_2_Any_X_i1xx"),
        // Any -> (oINFO) -> Any
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.O_INFO, tsk_fsm.prototype.__i_state_any, x0000_Any_2_Any_X_oINFO, "x0000_Any_2_Any_X_oINFO"),
        // Any -> (iINFO) -> Any
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_INFO, tsk_fsm.prototype.__i_state_any, x0000_Any_2_Any_X_iINFO, "x0000_Any_2_Any_X_iINFO"),
        // Any -> (i401/407)
        //
        // Any -> (iPRACK) -> Any
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_PRACK, tsk_fsm.prototype.__i_state_any, x0000_Any_2_Any_X_iPRACK, "x0000_Any_2_Any_X_iPRACK"),
        // Any -> (iOPTIONS) -> Any
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_OPTIONS, tsk_fsm.prototype.__i_state_any, x0000_Any_2_Any_X_iOPTIONS, "x0000_Any_2_Any_X_iOPTIONS"),
        // Any -> (i2xx INVITE) -> Any
        tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2invite, tsk_fsm.prototype.__i_state_any, x0000_Any_2_Any_X_i2xxINVITEorUPDATE, "x0000_Any_2_Any_X_i2xxINVITE"),
        // Any -> (i2xx UPDATE) -> Any
        tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2update, tsk_fsm.prototype.__i_state_any, x0000_Any_2_Any_X_i2xxINVITEorUPDATE, "x0000_Any_2_Any_X_i2xxUPDATE"),
        // Any -> (i401/407 INVITE) -> Any
        tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_401_407, __tsip_dialog_invite_cond_is_resp2invite, tsk_fsm.prototype.__i_state_any, x0000_Any_2_Any_X_i401_407_INVITEorUPDATE, "x0000_Any_2_Any_X_i401_407_INVITE"),
        // Any -> (i401/407  UPDATE) -> Any
        tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_401_407, __tsip_dialog_invite_cond_is_resp2update, tsk_fsm.prototype.__i_state_any, x0000_Any_2_Any_X_i401_407_INVITEorUPDATE, "x0000_Any_2_Any_X_i401_407_UPDATE"),
        // Any -> (i2xx PRACK) -> Any
        tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2prack, tsk_fsm.prototype.__i_state_any, null, "x0000_Any_2_Any_X_i2xxPRACK"),
        // Any -> (i2xx INFO) -> Any
        tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2info, tsk_fsm.prototype.__i_state_any, null, "x0000_Any_2_Any_X_i2xxINFO"),
        // Any -> (local sdp request timeout) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.TIMER_LO_SDP_REQUEST, tsip_dialog_invite_states_e.TERMINATED, x9997_Any_2_Any_X_LoSdpRequestTimeout, "x9997_Any_2_Any_X_LoSdpRequestTimeout"),
        // Any -> (transport error) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.TRANSPORT_ERROR, tsip_dialog_invite_states_e.TERMINATED, x9998_Any_2_Terminated_X_transportError, "x9998_Any_2_Terminated_X_transportError"),
        // Any -> (error) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.ERROR, tsip_dialog_invite_states_e.TERMINATED, x9999_Any_2_Terminated_X_Error, "x9999_Any_2_Terminated_X_Error")
    );

    // initialize "client" state machine
    this.init_client();
    // initialize "server" state machine
    this.init_server();
    /* 3GPP TS 24.610: Communication Hold  */
    this.init_hold();
    /* 3GPP TS 24.629: Explicit Communication Transfer (ECT) using IP Multimedia (IM) Core Network (CN) subsystem */
    this.init_ect();
}

tsip_dialog_invite.prototype.signal_invite = function (e_invite_type, i_code, s_phrase, o_message) {
    var o_event = new tsip_event_invite(this.get_session(), i_code, s_phrase, o_message, e_invite_type);
    return o_event.signal();
}

tsip_dialog_invite.prototype.send_invite = function (b_force_sdp) {
    return this.send_offer(true, b_force_sdp);
}

tsip_dialog_invite.prototype.send_update = function (b_force_sdp) {
    return this.send_offer(false, b_force_sdp);
}

tsip_dialog_invite.prototype.send_offer = function (b_is_invite, b_force_sdp) {
    var i_ret = -1;
    var o_request = null;
    var b_wait4lo = false;

    if (!b_is_invite && b_force_sdp) {
        tsk_utils_log_warn("ACK is need to ensure the media session");
    }

    if ((o_request = this.request_new(b_is_invite ? "INVITE" : "UPDATE"))) {
        /* apply action params to the request (will add a content if the action contains one) */
        if (this.o_action_curr) {
            tsip_dialog.prototype.ApplyAction(o_request, this.o_action_curr);
        }

        /* add our payload if current action does not have one */
        if ((b_force_sdp || b_is_invite) || ((this.o_msession_mgr && this.o_msession_mgr.b_state_changed) || (this.e_state == tsip_dialog_state_e.INITIAL))) {
            if (!this.o_action_curr || !this.o_action_curr.o_payload) {
                var o_sdp_lo = this.o_msession_mgr.get_lo();
                b_wait4lo = (o_sdp_lo == null);
                if (o_sdp_lo) {
                    var s_sdp_lo = o_sdp_lo.toString();
                    o_request.add_content(new String(s_sdp_lo), "application/sdp");
                }
            }
        }


        /* Session timers */
        if (this.stimers.i_timeout) {
            if (this.require.b_timer) {
                o_request.add_headers(
						new tsip_header_Session_Expires(this.stimers.i_timeout, !this.stimers.b_is_refresher),
						new tsip_header_Require("timer"));
            }
            else if (this.supported.b_timer) {
                o_request.add_headers(
						new tsip_header_Session_Expires(this.stimers.i_timeout, !this.stimers.b_is_refresher),
						new tsip_header_Supported("timer"));
            }

        }

        if (this.stimers.i_minse) {
            o_request.add_headers(new tsip_header_Min_SE(this.stimers.i_minse));
        }

        /* 100rel */
        if (this.require.b_100rel) {
            o_request.add_headers(new tsip_header_Require("100rel"));
        }
        else if (this.supported.b_100rel) {
            o_request.add_headers(new tsip_header_Supported("100rel"));
        }

        /* send the request */
        if (b_wait4lo) {
            i_ret = 0;
            this.o_wait_oMessage = o_request;
            this.timer_schedule('invite', 'LoSdpRequest');
        }
        else {
            i_ret = this.request_send(o_request);
            if (b_is_invite && i_ret == 0) {
                this.o_last_oInvite = o_request;
            }
        }
    }

    return i_ret;
}

tsip_dialog_invite.prototype.send_ack = function (o_response) {
    var i_ret = -1;
    var o_request = null;
    var b_wait4lo = false;

    if ((o_request = this.request_new("ACK"))) {
        /* The initial INVITE sent by us was a bodiless request and we don't support 100rel (We are Alice)
        1. Alice sends initial INVITE without offer
        2. Bob's offer is sent in the 2xx INVITE response
        3. Alice's answer is sent in the ACK request
        */
        if (this.b_is_client && (this.o_last_oInvite && !this.o_last_oInvite.has_content())) {
            var o_sdp_lo = this.o_msession_mgr.get_lo();
            b_wait4lo = (o_sdp_lo == null);
            if (o_sdp_lo) {
                var s_sdp_lo = o_sdp_lo.toString();
                o_request.add_content(new String(s_sdp_lo), "application/sdp");
            }

            // Start media session if not done
            if (!this.o_msession_mgr.is_started() && (this.o_msession_mgr.has_lo() && this.o_msession_mgr.has_ro())) {
                i_ret = this.o_msession_mgr.start();
            }
        }

        /*	RFC 3261 - 13.2.2.4 2xx Responses
        The UAC core MUST generate an ACK request for each 2xx received from
        the transaction layer.  The header fields of the ACK are constructed
        in the same way as for any request sent within a dialog (see Section
        12) with the exception of the CSeq and the header fields related to
        authentication.  The sequence number of the CSeq header field MUST be
        the same as the INVITE being acknowledged, but the CSeq method MUST
        be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
        the 2xx contains an offer (based on the rules above), the ACK MUST
        carry an answer in its body.  If the offer in the 2xx response is not
        acceptable, the UAC core MUST generate a valid answer in the ACK and
        then send a BYE immediately.
        ==> Credentials will be added by tsip_dialog_request_new() because they are
        associated to the dialog itself.
        ==> It's up to us to add/update the CSeq number.
        ==> ACK requests sent here will create new client transactions, which means that
        they will have there own branches. This is not the case for ACK requests sent from
        the transaction layer.
        */
        o_request.o_hdr_CSeq.i_seq = o_response.o_hdr_CSeq.i_seq; /* As the 2xx has the same CSeq than the INVITE */

        /* send the request */
        if (b_wait4lo) {
            this.o_wait_oMessage = o_request;
            this.timer_schedule('invite', 'LoSdpRequest');
            return 0;
        }
        else {
            return this.request_send(o_request);
        }
    }
    return i_ret;
}

// "Require: 100rel\r\n" should be checked by the caller of this function
tsip_dialog_invite.prototype.send_prack = function (o_r1xx) {
    if (!o_r1xx || !o_r1xx.o_hdr_CSeq) {
        tsk_utils_log_error("Invalid parameter");
        return -1;
    }

    var i_ret = -1;
    var o_request = null;
    var o_hdr_RSeq;
    var b_wait4lo = false;


    /*	RFC 3262 - 4 UAC Behavior
    The UAC MUST maintain a sequence number that indicates the most recently
    received in-order reliable provisional response for the initial request.
    */
    if ((o_hdr_RSeq = o_r1xx.get_header(tsip_header_type_e.RSeq))) {

        /*	RFC 3262 - 4 UAC Behavior
        If the UAC receives another reliable provisional
        response to the same request, and its RSeq value is not one higher
        than the value of the sequence number, that response MUST NOT be
        acknowledged with a PRACK, and MUST NOT be processed further by the
        UAC.  An implementation MAY discard the response, or MAY cache the
        response in the hopes of receiving the missing responses.
        */
        if (self.i_rseq && (o_hdr_RSeq.i_value <= this.i_rseq)) {
            tsk_utils_log_warn("1xx.RSeq value is not one higher than lastINVITE.RSeq");
            return 0; /* Not error */
        }
        this.i_rseq = o_hdr_RSeq.i_value;
    }

    /* RFC 3262 - 4 UAC Behavior
    Assuming the response is to be transmitted reliably, the UAC MUST
    create a new request with method PRACK.
    */
    if (!(o_request = this.request_new("PRACK"))) {
        tsk_utils_log_error("Failed to create PRACK request");
        return -2;
    }

    /* RFC 3262 - 7.2 RAck
    The first number is the value from the RSeq header in the provisional
    response that is being acknowledged.  The next number, and the
    method, are copied from the CSeq in the response that is being
    acknowledged.  The method name in the RAck header is case sensitive.
    */
    o_request.add_header(new tsip_header_RAck(this.i_rseq, o_r1xx.o_hdr_CSeq.i_seq, o_r1xx.o_hdr_CSeq.s_method));

    /*	Initial INVITE was a bodiless request and 100rel is supported (I'm Alice)
    1. Alice sends an initial INVITE without offer
    2. Bob's answer is sent in the first reliable provisional response, in this case it's a 1xx INVITE response
    3. Alice's answer is sent in the PRACK response
    */
    if (this.b_is_client && (this.o_last_oInvite && !this.o_last_oInvite.has_content())) {
        var o_sdp_lo = this.o_msession_mgr.get_lo();
        b_wait4lo = (o_sdp_lo == null);
        if (o_sdp_lo) {
            var s_sdp_lo = o_sdp_lo.toString();
            o_request.add_content(new String(s_sdp_lo), "application/sdp");
        }
    }

    /* send the request */
    if (b_wait4lo) {
        this.o_wait_oMessage = o_request;
        this.timer_schedule('invite', 'LoSdpRequest');
        return 0;
    }
    else {
        return this.request_send(o_request);
    }
}


// Send any response
tsip_dialog_invite.prototype.send_response = function (o_request, i_code, s_phrase, b_force_sdp) {
    var o_response;
    var i_ret = -1;
    var b_wait4lo = false;

    if ((o_response = this.response_new(i_code, s_phrase, o_request))) {
        if (o_request.is_invite() || o_request.is_update()) {
            /* Session timers (for 2xx to INVITE or UPDATE) */
            if (this.require.b_timer) {
                o_response.add_headers(
                    new tsip_header_Require("timer"),
                    new tsip_header_Session_Expires(this.stimers.i_timeout, tsk_string_iequals(this.stimers.s_refresher, "uas"))
                );
            }
            else if (this.supported.b_timer) {
                o_response.add_headers(
                    new tsip_header_Supported("timer"),
                    new tsip_header_Session_Expires(this.stimers.i_timeout, tsk_string_iequals(this.stimers.s_refresher, "uas"))
                );
            }
            if (this.stimers.i_minse) {
                o_response.add_headers(
                    new tsip_header_Min_SE(this.stimers.i_minse)
                );
            }
            if (i_code == 422) {
                o_response.add_headers(
                    new tsip_header_Dummy("Reason", "SIP; cause=422; text=\"Session Interval Too Small\"")
                );
            }

            /* 180 Ringing */
            /* 183 Session in Progress */
            if (i_code == 180 || i_code == 183) {
                if (this.require.b_100rel) {
                    if (this.i_rseq == 0) {
                        this.i_rseq = Math.abs((rand() ^ rand()) + 1);
                    }
                    o_response.add_headers(
                        new tsip_header_Require("100rel"),
                        new tsip_header_RSeq(this.i_rseq)
                    );

                    this.o_last_o1xxrel = o_response;

                    /* No-Initial reliable 1xx will use tsip_dialog_response_send() instead of this function
                    * ==> can reseset timeout value and make initial schedule */
                    this.timer_cancel('100Rel');
                    this.i_timer100Rel = this.get_stack().o_timers.getA();
                    this.timer_schedule('invite', '100Rel');
                }
            }


            /* SDP content */
            if (this.o_msession_mgr && b_force_sdp) {
                var o_sdp_lo = this.o_msession_mgr.get_lo();
                b_wait4lo = (o_sdp_lo == null);
                if (o_sdp_lo) {
                    var s_sdp_lo = o_sdp_lo.toString();
                    o_response.add_content(new String(s_sdp_lo), "application/sdp");
                }
            }

            /* Add Allow header */
            o_response.add_headers(new tsip_header_Dummy("Allow", TSIP_HEADER_ALLOW_DEFAULT));
        }
        else if (o_request.is_refer()) {
            if (this.require.b_norefersub) {
                o_response.add_headers(new tsip_header_Require("norefersub"));
                
            }
            if (this.supported.b_norefersub) {
                o_response.add_headers(new tsip_header_Supported("norefersub"));
            }
        }

        /* send the request */
        if (b_wait4lo) {
            this.o_wait_oMessage = o_response;
            this.timer_schedule('invite', 'LoSdpRequest');
            return 0;
        }
        else {
            return this.response_send(o_response);
        }
    }
    return i_ret;
}

tsip_dialog_invite.prototype.send_error = function (o_request, i_code, s_phrase, s_reason) {
    var o_response;

    if ((o_response = this.response_new(i_code, s_phrase, o_request))) {
        o_response.add_headers(new tsip_header_Dummy("Reason", s_reason));

        return this.response_send(o_response);
    }
    else {
        tsk_utils_log_error("Failed to create new message");
        return -1;
    }
}

tsip_dialog_invite.prototype.send_bye = function(){
	var i_ret = -1;
	var o_bye;
	
	/* RFC 3261 - 15.1.1 UAC Behavior
		A BYE request is constructed as would any other request within a
		dialog, as described in Section 12.

		Once the BYE is constructed, the UAC core creates a new non-INVITE
		client transaction, and passes it the BYE request.  The UAC MUST
		consider the session terminated (and therefore stop sending or
		listening for media) as soon as the BYE request is passed to the
		client transaction.  If the response for the BYE is a 481
		(Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no

		response at all is received for the BYE (that is, a timeout is
		returned by the client transaction), the UAC MUST consider the
		session and the dialog terminated.
	*/
	if ((o_bye = this.request_new("BYE"))) {
	    i_ret = this.request_send(o_bye);
	}

	return i_ret;
}

tsip_dialog_invite.prototype.send_info = function(s_content, s_content_type){
    var i_ret = -1;
	var o_info;

    if ((o_info = this.request_new("INFO"))) {
        if (s_content && s_content_type) {
            o_info.add_content(new String(s_content), s_content_type);
        }
	    i_ret = this.request_send(o_info);
	}
    return i_ret;
}

tsip_dialog_invite.prototype.send_cancel = function () {
    /* RFC 3261 - 9 Canceling a Request
    If the request being cancelled contains a Route header field, the
    CANCEL request MUST include that Route header field's values.
    ==> up to tsip_dialog_request_new()
    */

    /*	RFC 3261 - 9 Canceling a Request
    Once the CANCEL is constructed, the client SHOULD check whether it
    has received any response (provisional or final) for the request
    being cancelled (herein referred to as the "original request").

    If no provisional response has been received, the CANCEL request MUST
    NOT be sent; rather, the client MUST wait for the arrival of a
    provisional response before sending the request.
    ==> up to the caller to check that we are not in the initial state and the FSM
    is in Trying state.
    */

    /*	RFC 3261 - 9 Canceling a Request
    The following procedures are used to construct a CANCEL request.  The
    Request-URI, Call-ID, To, the numeric part of CSeq, and From header
    fields in the CANCEL request MUST be identical to those in the
    request being cancelled, including tags.  A CANCEL constructed by a
    client MUST have only a single Via header field value matching the
    top Via value in the request being cancelled.  Using the same values
    for these header fields allows the CANCEL to be matched with the
    request it cancels (Section 9.2 indicates how such matching occurs).
    However, the method part of the CSeq header field MUST have a value
    of CANCEL.  This allows it to be identified and processed as a
    transaction in its own right (See Section 17)
    */
    if (this.o_last_oInvite) {
        /* to avoid concurrent access, take a reference to the request */
        var o_request;
        var i_index;

        if ((o_request = new tsip_request("CANCEL", this.o_last_oInvite.line.request.o_uri, null, null, this.o_last_oInvite.o_hdr_Call_ID.s_value, this.o_last_oInvite.o_hdr_CSeq.i_seq))) {
            o_request.o_hdr_firstVia = this.o_last_oInvite.o_hdr_firstVia;
            o_request.o_hdr_From = this.o_last_oInvite.o_hdr_From;
            o_request.o_hdr_To = this.o_last_oInvite.o_hdr_To;

            // Copy Authorizations, Routes and Proxy-Auth
            for (i_index = 0; i_index < this.o_last_oInvite.ao_headers.length; ++i_index) {
                switch (this.o_last_oInvite.ao_headers[i_index].e_type) {
                    case tsip_header_type_e.Route:
                    case tsip_header_type_e.Proxy_Authorization:
                    case tsip_header_type_e.Authorization:
                        o_request.ao_headers.push(this.o_last_oInvite.ao_headers[i_index]);
                        break;
                }
            }
            /* Add outbound proxy */
            // The outbound proxy is added as Route header only if the transport is WS/WSS to allow webrtc2sip to forward the request
            // For all other protocols (e.g UDP) the request will already be sent to the outbound proxy address
            if (this.get_stack().network.e_proxy_cscf_type == tsip_transport_type_e.WS || this.get_stack().network.e_proxy_cscf_type == tsip_transport_type_e.WSS) {
                var s_proxy_outbound = this.get_stack().__get_proxy_outbound_uri_string();
                if (s_proxy_outbound) {
                    o_request.add_header(new tsip_header_Dummy("Route", s_proxy_outbound), true/*true*/);
                }
            }

            return this.request_send(o_request);
        }
        else {
            tsk_utils_log_error("Failed to create CANCEL request");
            return -2;
        }
    }
    else {
        tsk_utils_log_warn("There is no INVITE request to cancel");
        return 0;
    }
}

tsip_dialog_invite.prototype.notify_parent = function (o_response) {
    var o_dlg_parent = this.get_layer_dialog().find_by_ssid(this.get_session().i_id_parent);
    if (o_dlg_parent) {
        var o_action = new tsip_action(tsip_action_type_e.ECT_NOTIFY);
        if (o_action) {
            return o_dlg_parent.fsm_act(o_action.e_type, o_response, o_action);
        }
    }
    else {
        tsk_utils_log_error("Failed to find parent with id=" + this.get_session().i_id_parent + "");
    }
    return -1;
}

tsip_dialog_invite.prototype.new_msession_mgr = function(e_type, s_addr, b_ipv6, b_offerer){
    var o_msession_mgr = new tmedia_session_mgr(e_type, s_addr, b_ipv6, b_offerer, __tsip_dialog_invite_media_callback, this);
    o_msession_mgr.set(
            tmedia_session_mgr.prototype.SetParamSession(o_msession_mgr.e_type, "ice-servers", this.get_stack().network.ao_ice_servers),
            tmedia_session_mgr.prototype.SetParamSession(o_msession_mgr.e_type, "cache-stream", this.get_stack().media.b_cache_stream),
            tmedia_session_mgr.prototype.SetParamSession(o_msession_mgr.e_type, "bandwidth", this.get_session().media.o_bandwidth),
            tmedia_session_mgr.prototype.SetParamSession(o_msession_mgr.e_type, "video-size", this.get_session().media.o_video_size),
            tmedia_session_mgr.prototype.SetParamSession(o_msession_mgr.e_type, "audio-constraints", this.get_session().media.o_audio_constraints)
			// ... more media parameters to be added later
        );
    return o_msession_mgr;
}

tsip_dialog_invite.prototype.process_ro = function(o_message, b_is_offer){
	var o_sdp_ro = null;
	var e_old_media_type;
	var e_new_media_type;
	var b_media_session_was_null;
	var i_ret = 0;

	if(!o_message){
		tsk_utils_log_error("Invalid parameter");
		return -1;
	}

	/* Parse SDP content */
	if(o_message.has_content()){
		if(tsk_string_iequals("application/sdp", o_message.get_content_type())){
			if(!(o_sdp_ro = tsdp_message.prototype.Parse(o_message.get_content_as_string()))){
				tsk_utils_log_error("Failed to parse remote sdp message");
				return -2;
			}
		}
		else{
		    tsk_utils_log_error("[" + o_message.get_content_type() + "] content-type is not supportted");
			return -3;
		}
	}
	else{
		if(this.e_state == tsip_dialog_state_e.INITIAL && o_message.is_invite()){ /* Bodiless initial INVITE */
			this.get_session().media.e_type = tmedia_defaults_get_media_type(); // Default media for initial INVITE to send with the first reliable answer
		}
		else{
			return 0;
		}
	}
	
	b_media_session_was_null = (this.o_msession_mgr == null);
	e_old_media_type = this.get_session().media.e_type;
	e_new_media_type = o_sdp_ro ? o_sdp_ro.get_media_type() : e_old_media_type;

	/* Create session Manager if not already done */
	if(!this.o_msession_mgr){
		this.get_session().media.e_type = e_new_media_type;
		this.o_msession_mgr = this.new_msession_mgr(e_new_media_type, this.get_stack().network.s_local_ip, false/* ipv6 */, (o_sdp_ro == null));
	}
	
	if(o_sdp_ro){
	    if ((i_ret = this.o_msession_mgr.set_ro(o_sdp_ro, b_is_offer))) {
			tsk_utils_log_error("Failed to set remote offer");
			return i_ret;
		}
	}
	
	// is media update?
	if(!b_media_session_was_null && (e_old_media_type != e_new_media_type) && (this.o_msession_mgr.sdp.o_lo && this.o_msession_mgr.sdp.o_ro)){
		// at this point the media session manager has been succeffuly started and all is ok
		this.get_session().media.e_type = e_new_media_type;
        this.signal_invite(tsip_event_invite_type_e.M_UPDATED, o_message.get_response_code(), o_message.get_response_phrase(), o_message);
	}
	
	/* start session manager */
	if(!this.o_msession_mgr.is_started() && (this.o_msession_mgr.has_lo() && this.o_msession_mgr.has_ro())){
		/* starts */
		i_ret = this.o_msession_mgr.start();
		if(i_ret == 0 && this.e_state == tsip_dialog_state_e.EARLY){
            this.signal_invite(tsip_event_invite_type_e.M_EARLY_MEDIA, o_message.get_response_code(), o_message.get_response_phrase(), o_message);
		}
	}

	return i_ret;
}

function __tsip_dialog_invite_timer_callback(o_self, o_timer) {
    var i_ret = -1;
    if (o_self) {
        if (o_self.o_timerSession == o_timer) {
            i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.TIMER_REFRESH, null, null);
        }
        else if (o_self.o_timer100Rel == o_timer) {
            i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.TIMER_100REL, null, null);
        }
        else if (o_self.o_timerShutdown == o_timer) {
            i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.SHUTDOWN_TIMEDOUT, null, null);
        }
        else if (o_self.o_timerLoSdpRequest == o_timer) {
            i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.TIMER_LO_SDP_REQUEST, null, null);
        }
    }
    return i_ret;
}

function __tsip_dialog_invite_media_callback(o_self, e_event_type, e_media_type) {
    var i_ret;

    switch (e_event_type) {
        case tmedia_session_events_e.GET_LO_SUCCESS:
            {
                o_self.timer_cancel('LoSdpRequest');
                if (o_self.o_wait_oMessage) {
                    var o_sdp_lo = o_self.o_msession_mgr.get_lo();
                    var s_sdp_lo = null;
                    if (o_sdp_lo && (s_sdp_lo = o_sdp_lo.toString())) {
                        o_self.o_wait_oMessage.add_content(new String(s_sdp_lo), "application/sdp");
                        // tsk_utils_log_info("sending=" + o_self.o_wait_oMessage.toString());
                        if (o_self.o_wait_oMessage.is_request()) {
                            if (o_self.o_wait_oMessage.is_ack()) {
                                i_ret = o_self.get_stack().o_layer_transport.send(null, o_self.o_wait_oMessage);
                            }
                            else {
                                i_ret = o_self.request_send(o_self.o_wait_oMessage);
                                if (i_ret == 0 && o_self.o_wait_oMessage.is_invite()) {
                                    o_self.o_last_oInvite = o_self.o_wait_oMessage;
                                }
                            }
                        }
                        else {
                            i_ret = o_self.response_send(o_self.o_wait_oMessage);
                        }
                    }
                    o_self.o_wait_oMessage = null;
                }
                else {
                    // /!\do not send early media (18x with SDP)
                    if (/*o_self.e_state == tsip_dialog_state_e.EARLY ||*/ o_self.e_state == tsip_dialog_state_e.ESTABLISHED) {
                        if (o_self.e_next_offer_type == tsip_dialog_invite_next_offer_type_e.SUCCESS && o_self.o_last_iOffer) {
                            i_ret = o_self.send_response(o_self.o_last_iOffer, 200, "OK", true);
                        }
                        else {
                            i_ret = o_self.send_offer(true, true); // always send INVITE because we use the ACK to ensure the media
                        }
                    }
                }
                if (o_self.o_msession_mgr && !o_self.o_msession_mgr.is_started() && (o_self.o_msession_mgr.has_lo() && o_self.o_msession_mgr.has_ro())) {
                    i_ret = o_self.o_msession_mgr.start();
                }

                o_self.e_next_offer_type = tsip_dialog_invite_next_offer_type_e.NONE;
                break;
            }
        case tmedia_session_events_e.GET_LO_FAILED:
            {
                o_self.timer_cancel('LoSdpRequest');
                o_self.set_last_error(tsip_event_code_e.DIALOG_WEBRTC_ERROR, "Failed to get local SDP offer");
                o_self.e_next_offer_type = tsip_dialog_invite_next_offer_type_e.NONE;

                var o_action = new tsip_action(tsip_action_type_e.HANGUP);
                o_action.set_line_resp(603, "Failed to get local SDP");
                o_self.hangup(o_action);
                break;
            }

        case tmedia_session_events_e.STREAM_LOCAL_REQUESTED:
            {
                o_self.signal_invite(tsip_event_invite_type_e.M_STREAM_LOCAL_REQUESTED, tsip_event_code_e.DIALOG_MEDIA_LOCAL_REQUESTED, "Media Requested", null);
                break;
            }
        case tmedia_session_events_e.STREAM_LOCAL_ACCEPTED:
            {
                o_self.signal_invite(tsip_event_invite_type_e.M_STREAM_LOCAL_ACCEPTED, tsip_event_code_e.DIALOG_MEDIA_LOCAL_ACCEPTED, "Media Accepted", null);
                break;
            }
        case tmedia_session_events_e.STREAM_LOCAL_REFUSED:
            {
                o_self.signal_invite(tsip_event_invite_type_e.M_STREAM_LOCAL_REFUSED, tsip_event_code_e.DIALOG_MEDIA_LOCAL_REFUSED, "Media Refused", null);
                var o_action = new tsip_action(tsip_action_type_e.HANGUP);
                o_action.set_line_resp(603, "Media stream permission denied");
                o_self.hangup(o_action);
                break;
            }
        case tmedia_session_events_e.STREAM_LOCAL_ADDED:
            {
                o_self.get_session().__set_stream_local(o_self.o_msession_mgr.get_stream_local());
                o_self.signal_invite(tsip_event_invite_type_e.M_STREAM_LOCAL_ADDED, tsip_event_code_e.DIALOG_MEDIA_ADDED, "Media Added", null);
                break;
            }
        case tmedia_session_events_e.STREAM_LOCAL_REMOVED:
            {
                o_self.get_session().__set_stream_local(null);
                o_self.signal_invite(tsip_event_invite_type_e.M_STREAM_LOCAL_REMOVED, tsip_event_code_e.DIALOG_MEDIA_REMOVED, "Media Removed", null);
                break;
            }
        case tmedia_session_events_e.STREAM_REMOTE_ADDED:
            {
                o_self.get_session().__set_stream_remote(o_self.o_msession_mgr.get_stream_remote());
                o_self.signal_invite(tsip_event_invite_type_e.M_STREAM_REMOTE_ADDED, tsip_event_code_e.DIALOG_MEDIA_ADDED, "Media Added", null);
                break;
            }
        case tmedia_session_events_e.STREAM_REMOTE_REMOVED:
            {
                o_self.get_session().__set_stream_remote(null);
                o_self.signal_invite(tsip_event_invite_type_e.M_STREAM_REMOTE_REMOVED, tsip_event_code_e.DIALOG_MEDIA_REMOVED, "Media Removed", null);
                break;
            }
        case tmedia_session_events_e.RFC5168_REQUEST_IDR:
            {
                o_self.send_info("<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n" +
				" <media_control>\r\n" +
				"   <vc_primitive>\r\n" +
				"     <to_encoder>\r\n" +
				"       <picture_fast_update>\r\n" +
				"       </picture_fast_update>\r\n" +
				"     </to_encoder>\r\n" +
				"   </vc_primitive>\r\n" +
				" </media_control>\r\n", "application/media_control+xml");
                break;
            }
    }
}

function __tsip_dialog_invite_event_callback(o_self, e_type, o_message){
	var i_ret = -1;

	switch(e_type){
	    case tsip_dialog_event_type_e.I_MSG:
		    {
		        if (o_message) {
		            if (o_message.is_response()) { /* Response */
		                if (o_message.is_1xx()) { // 100-199
		                    i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_1XX, o_message, null);
					    }
						else if (o_message.is_2xx()) { // 200-299
						    i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_2XX, o_message, null);
					    }
						else if (o_message.is_response_xxx(401) || o_message.is_response_xxx(407)) { // 401,407
						    i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_401_407, o_message, null);
					    }
						else if (o_message.is_response_xxx(422)) { // 422
						    i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_422, o_message, null);
					    }
						else if (o_message.is_3456()) { // 300-699
						    i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_300_to_699, o_message, null);
					    }
					    //else; // Ignore
				    }
				    else{ /* Request */
				        if (o_message.is_invite()) { // INVITE
				            i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_INVITE, o_message, null);
					    }
					    else if (o_message.is_update()) { // UPDATE
					        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_UPDATE, o_message, null);
					    }
					    else if (o_message.is_prack()) { // PRACK
					        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_PRACK, o_message, null);
					    }
					    else if (o_message.is_ack()) { // ACK
					        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_ACK, o_message, null);
					    }
					    else if (o_message.is_options()) { // OPTIONS
					        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_OPTIONS, o_message, null);
					    }
					    else if (o_message.is_bye()) { // BYE
					        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_BYE, o_message, null);
					    }
					    else if (o_message.is_cancel()) { // CANCEL
					        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_CANCEL, o_message, null);
					    }
					    else if (o_message.is_info()) { // INFO
					        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_INFO, o_message, null);
					    }
					    else if (o_message.is_notify()) { // NOTIFY
					        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_NOTIFY, o_message, null);
					    }
					    else if (o_message.is_refer()) { // REFER
					        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.I_REFER, o_message, null);
					    }
				    }
			    }
			    break;
		    }

        case tsip_dialog_event_type_e.CANCELED:
		    {
		        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.O_CANCEL, o_message, null);
			    break;
		    }

        case tsip_dialog_event_type_e.TIMEDOUT:
		    {
			    // Do nothing if request type is "INFO"
		        if (!o_message || (!o_message.is_request() || !o_message.is_info())) {
			        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.TRANSPORT_ERROR, o_message, null);
			    }
			    break;
		    }
        case tsip_dialog_event_type_e.TERMINATED:
        case tsip_dialog_event_type_e.ERROR:
        case tsip_dialog_event_type_e.TRANSPORT_ERROR:
		    {
		        i_ret = o_self.fsm_act(tsip_dialog_invite_actions_e.TRANSPORT_ERROR, o_message, null);
			    break;
		    }
	}

    return i_ret;
}

/* ======================== conds ======================== */
function __tsip_dialog_invite_cond_is_resp2invite(o_dialog, o_message){
	return o_message.is_response_to_invite();
}
function __tsip_dialog_invite_cond_is_resp2update(o_dialog, o_message){
    return o_message.is_response_to_update();
}
function __tsip_dialog_invite_cond_is_resp2invite_or_update(o_dialog, o_message) {
    return __tsip_dialog_invite_cond_is_resp2invite(o_dialog, o_message) || __tsip_dialog_invite_cond_is_resp2update(o_dialog, o_message);
}
function __tsip_dialog_invite_cond_is_resp2bye(o_dialog, o_message){
    return o_message.is_response_to_bye();
}
function __tsip_dialog_invite_cond_is_resp2prack(o_dialog, o_message){
    return o_message.is_response_to_prack();
}
function __tsip_dialog_invite_cond_is_resp2info(o_dialog, o_message){
    return o_message.is_response_to_info();
}
function __tsip_dialog_invite_cond_is_resp2cancel(o_dialog, o_message) {
    return o_message.is_response_to_cancel();
}
function __tsip_dialog_invite_cond_is_resp2refer(o_dialog, o_message) {
    return o_message.is_response_to_refer();
}
function __tsip_dialog_invite_cond_is_1xx_notify(o_dialog, o_message){
	var i_code = __tsip_dialog_invite_get_sip_frag_respcode(o_message);
	return (i_code >= 100 && i_code <= 199);
}
function __tsip_dialog_invite_cond_is_23456_notify(o_dialog, o_message){
	var i_code = __tsip_dialog_invite_get_sip_frag_respcode(o_message);
	return (i_code >= 200 && i_code <= 699);
}
function __tsip_dialog_invite_cond_is_f_refer(o_dialog, o_message){
    var o_hdr_Refer_To = o_message.get_header(tsip_header_type_e.Refer_To);
    return (!o_hdr_Refer_To || !o_hdr_Refer_To.o_uri);
}
function __tsip_dialog_invite_cond_is_1xx_f_notify(o_dialog, o_message){
    return o_message.is_1xx();
}
function __tsip_dialog_invite_cond_is_23456_f_notify(o_dialog, o_message){
    return o_message.is_23456();
}


//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

function x0000_Connected_2_Connected_X_oDTMF(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

function x0000_Connected_2_Connected_X_oLMessage(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

function x0000_Connected_2_Connected_X_iACK(ao_args) {
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];
    var i_ret = 0;

    /* Process remote offer (ACK could carry SDP) */
    var b_is_offer = o_dialog.o_msession_mgr && !o_dialog.o_msession_mgr.has_ro();
    if ((i_ret = o_dialog.process_ro(o_request, b_is_offer))) {
        return i_ret;
    }

    /* Ensure media session */
    if (o_dialog.o_msession_mgr) {
        i_ret = o_dialog.o_msession_mgr.acked();
    }

    /* alert the user */
    o_dialog.signal_invite(tsip_event_invite_type_e.DIALOG_REQUEST_INCOMING, tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Request", o_request);

	return i_ret;
}

function x0000_Connected_2_Connected_X_iINVITEorUPDATE(ao_args) {
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];
    var i_ret;
	
	var b_bodiless_invite;
	var e_old_media_type = o_dialog.o_msession_mgr ? o_dialog.o_msession_mgr.get_media_type() : tmedia_type_e.NONE;
    var b_is_roap = o_dialog.o_msession_mgr ? o_dialog.o_msession_mgr.is_roap() : false;
	var e_new_media_type;
	var b_force_sdp;

    o_dialog.o_last_iOffer = o_request;

     // swictch before calling process_ro()
    if(b_is_roap){
        o_dialog.e_next_offer_type = tsip_dialog_invite_next_offer_type_e.SUCCESS;
    }

	/* process remote offer */
	if ((i_ret = o_dialog.process_ro(o_request, true))) {
        return i_ret;
    }

	// force SDP in 200 OK even if the request has the same SDP version
	b_force_sdp = o_request.has_content();
	
	// get new media_type after processing the remote offer
	e_new_media_type = o_dialog.o_msession_mgr ? o_dialog.o_msession_mgr.get_media_type() : tmedia_type_e.NONE;
	
	/** response to bodiless iINVITE always contains SDP as explained below
		RFC3261 - 14.1 UAC Behavior 
		   The same offer-answer model that applies to session descriptions in 
		   INVITEs (Section 13.2.1) applies to re-INVITEs.  As a result, a UAC 
		   that wants to add a media stream, for example, will create a new 
		   offer that contains this media stream, and send that in an INVITE 
		   request to its peer.  It is important to note that the full 
		   description of the session, not just the change, is sent.  This 
		   supports stateless session processing in various elements, and 
		   supports failover and recovery capabilities.  Of course, a UAC MAY 
		   send a re-INVITE with no session description, in which case the first 
		   reliable non-failure response to the re-INVITE will contain the offer 
		   (in this specification, that is a 2xx response).
	*/
	b_bodiless_invite = !o_request.has_content() && o_request.is_invite();

	/* session timers (must be before sending response) */
    // FIXME: session-timers
	//if(self->stimers.timer.timeout){
	//	tsip_dialog_invite_stimers_handle(self, rINVITEorUPDATE);
	//}

	/* hold/resume */
    i_ret = o_dialog.hold_handle (o_request);

	// send the response
    if(!b_is_roap){
	    i_ret = o_dialog.send_response(o_request, 200, "OK",
		    (o_dialog.o_msession_mgr && (b_force_sdp || b_bodiless_invite || o_dialog.o_msession_mgr.has_ro_changed() || o_dialog.o_msession_mgr.has_state_changed() || (e_old_media_type != e_new_media_type))));
    }

	/* alert the user */
	o_dialog.signal_invite(tsip_event_invite_type_e.DIALOG_REQUEST_INCOMING, tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Request", o_request);
	

	return i_ret;
}

function x0000_Connected_2_Connected_X_oINVITE(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

function x0000_Any_2_Any_X_i1xx(ao_args) {
    var o_dialog = ao_args[0];
    var o_r1xx = ao_args[1];
    var i_ret = 0;

    /* Update the dialog state */
    if ((i_ret = o_dialog.update_with_response(o_r1xx))) {
        return i_ret;
    }

    /* RFC 3262 - 4 UAC Behavior
    If a provisional response is received for an initial request, and
    that response contains a Require header field containing the option
    tag 100rel, the response is to be sent reliably.  If the response is
    a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be
    ignored, and the procedures below MUST NOT be used.

    Assuming the response is to be transmitted reliably, the UAC MUST
    create a new request with method PRACK.  This request is sent within
    the dialog associated with the provisional response (indeed, the
    provisional response may have created the dialog).  PRACK requests
    MAY contain bodies, which are interpreted according to their type and
    disposition.

    Note that the PRACK is like any other non-INVITE request within a
    dialog.  In particular, a UAC SHOULD NOT retransmit the PRACK request
    when it receives a retransmission of the provisional response being
    acknowledged, although doing so does not create a protocol error.
	 
    Additional information: We should only process the SDP from reliable responses (require:100rel)
    but there was many problem with some clients sending SDP with this tag: tiscali, DTAG, samsung, ...
    */
    
    if ((o_r1xx.get_response_code() >= 101 && o_r1xx.get_response_code() <= 199)) {
        /* Process Remote offer */
        var b_is_offer = o_dialog.o_msession_mgr && !o_dialog.o_msession_mgr.has_lo();
        if (o_r1xx.has_content() && (i_ret = o_dialog.process_ro(o_r1xx, b_is_offer))) {
            /* FIXME: Send Error */
            return i_ret;
        }
        // don't send PRACK if 100rel is only inside "supported" header
        if (o_r1xx.is_required("100rel") && (i_ret = o_dialog.send_prack(o_r1xx))) {
            return i_ret;
        }
    }

    // alert user
    i_ret = o_dialog.signal_invite(tsip_event_invite_type_e.I_AO_REQUEST, o_r1xx.get_response_code(), o_r1xx.get_response_phrase(), o_r1xx);

    if (o_dialog.b_is_transf) {
        i_ret = o_dialog.notify_parent(o_r1xx);
    }

    return i_ret;
}

function x0000_Any_2_Any_X_oINFO(ao_args) {
    var o_dialog = ao_args[0];
    var o_action = ao_args[2];
    var o_request;

    o_dialog.b_running = true;
    o_dialog.set_action_curr(o_action);

    if ((o_request = o_dialog.request_new("INFO"))) {
        var i_ret;
        if ((i_ret = tsip_dialog.prototype.ApplyAction(o_request, o_action)) == 0) {
            i_ret = o_dialog.request_send(o_request);
        }
        return i_ret;
	}
	else{
		tsk_utils_log_error("Failed to create new INFO request");
		return -1;
	}
}

function x0000_Any_2_Any_X_iINFO(ao_args) {
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];

    var i_ret = o_dialog.send_response(o_request, 200, "OK");
    /*i_ret =*/ o_dialog.signal_invite(tsip_event_invite_type_e.DIALOG_REQUEST_INCOMING, tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Request", o_request);

    // Forward the content to the media stack (e.g. rfc5168("picture_fast_update") to request IDR)
    if (o_dialog.o_msession_mgr && o_request.has_content()) {
        var s_content_as_string = o_request.get_content_as_string();
        if (!tsk_string_is_null_or_empty(s_content_as_string)) {
            o_dialog.o_msession_mgr.processContent("INFO", o_request.get_content_type(), s_content_as_string, s_content_as_string.length);
        }
    }

    return i_ret;
}

function x0000_Any_2_Any_X_i401_407_INVITEorUPDATE(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];
    var i_ret = 0;

    if ((i_ret = o_dialog.update_with_response(o_response))) {
        // alert user
        o_dialog.signal_invite(tsip_event_invite_type_e.I_AO_REQUEST, o_response.get_response_code(), o_response.get_response_phrase(), o_response);		
		return i_ret;
	}

    return o_dialog.send_offer(o_response.is_response_to_invite(), false);
}

function x0000_Any_2_Any_X_i2xxINVITEorUPDATE(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];
    var i_ret = 0;

    // ICT will always retransmit the 2xx (draft-sparks-sip-invfix-03 - 7.2. UAC Impacts)
    if (this.o_last_oInvite && this.o_last_oInvite.o_hdr_CSeq.i_seq == o_response.o_hdr_CSeq.i_seq) {
        if (o_response.is_response_to_invite()) {
            return o_dialog.send_ack(o_response);
        }
    }

	/* Update the dialog state */
	if((i_ret = o_dialog.update_with_response(o_response))){
		return i_ret;
	}

    /* session timers */
    // FIXME
	//if(self->stimers.timer.timeout){
	//	tsip_dialog_invite_stimers_handle(self, r2xx);
	//}

    /* Process remote offer */
    var b_is_offer = o_dialog.o_msession_mgr && !o_dialog.o_msession_mgr.has_lo();
    if ((i_ret = o_dialog.process_ro(o_response, b_is_offer))) {
        return i_ret;
    }

	/* send ACK */
    if (o_response.is_response_to_invite()) {
        i_ret = o_dialog.send_ack(o_response);
    }
	
	return i_ret;
}

function x0000_Any_2_Any_X_iPRACK(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

function x0000_Any_2_Any_X_iOPTIONS(ao_args) {
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];

    /* Alert user */
    o_dialog.signal_invite(tsip_event_invite_type_e.DIALOG_REQUEST_INCOMING, tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Request", o_request);

	/* Send 2xx */
    return o_dialog.send_response(o_request, 200, "OK", false);
}

// If not Connected => Cancel will be called instead. See tsip_dialog_hangup()
function x0000_Any_2_Trying_X_oBYE(ao_args) {
    var o_dialog = ao_args[0];
    var i_ret;

	/* Alert the user */
    o_dialog.signal(tsip_event_code_e.DIALOG_TERMINATING, "Call terminating...");

	/* send BYE */
	if((i_ret = o_dialog.send_bye()) == 0){
		// stop session manager
		if(o_dialog.o_msession_mgr && o_dialog.o_msession_mgr.is_started()){
			i_ret = o_dialog.o_msession_mgr.stop();
		}
	}
	return i_ret;
}

function x0000_Any_2_Terminated_X_iBYE(ao_args) {
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];

    /* set last error (or info) */
    o_dialog.set_last_error(tsip_event_code_e.DIALOG_TERMINATED, "Call terminated");

	/* send 200 OK */
	return o_dialog.send_response(o_request, 200, "OK", false);
}

function x0000_Any_2_Trying_X_shutdown(ao_args) {
    var o_dialog = ao_args[0];

    // schedule shutdow timer
    o_dialog.timer_schedule('invite', 'Shutdown');

    // alert user
    o_dialog.signal(tsip_event_code_e.DIALOG_TERMINATING, "Call terminating...");

    if (o_dialog.e_state == tsip_dialog_state_e.ESTABLISHED) {
        return o_dialog.send_bye();
	}
    else if (o_dialog.e_state == tsip_dialog_state_e.EARLY) {
        return o_dialog.send_cancel();
	}
}

function x9997_Any_2_Any_X_LoSdpRequestTimeout(ao_args) {
    tsk_utils_log_error("Not implemented");
    return 0;
}

function x9998_Any_2_Terminated_X_transportError(ao_args) {
    var o_dialog = ao_args[0];
    o_dialog.set_last_error(tsip_event_code_e.DIALOG_TRANSPORT_ERROR, "Transport error");
    return 0;
}

function x9999_Any_2_Terminated_X_Error(ao_args) {
    var o_dialog = ao_args[0];
    
    return 0;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++


function __tsip_dialog_invite_onterm(o_self) {
    tsk_utils_log_info("=== INVITE Dialog terminated ===");

    o_self.timer_cancel('100Rel');
    o_self.timer_cancel('Session');
    o_self.timer_cancel('Shutdown');
    o_self.timer_cancel('LoSdpRequest');

    // stops session if not already done
    // do not check if manager is started because peerconnection state must be closed in all cases
    if (o_self.o_msession_mgr) {
        i_ret = o_self.o_msession_mgr.stop();
    }
    
    // signal to the user must be done after the media session is stopped to be sure that all events (e.g. media_removed) will be notified
    o_self.signal(tsip_event_code_e.DIALOG_TERMINATED,
            o_self.last_error.s_phrase ? o_self.last_error.s_phrase : "Call terminated",
            o_self.last_error.o_message);

    // deinit
    return o_self.deinit();
}


if(!window.__b_release_mode){
    tsip_api_add_js_scripts('head',
    'src/tinySIP/src/dialogs/tsip_dialog_invite__client.js',
    'src/tinySIP/src/dialogs/tsip_dialog_invite__ect.js',
    'src/tinySIP/src/dialogs/tsip_dialog_invite__hold.js',
    'src/tinySIP/src/dialogs/tsip_dialog_invite__server.js',
    'src/tinySIP/src/dialogs/tsip_dialog_invite__timers.js'
    );
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_dialog_invite.prototype.init_client = function(){
    this.o_fsm.set(
			/*=======================
			* === Started === 
			*/
			// Started -> (send INVITE) -> Outgoing
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.STARTED, tsip_dialog_invite_actions_e.O_INVITE, tsip_dialog_invite_states_e.OUTGOING, c0000_Started_2_Outgoing_X_oINVITE, "c0000_Started_2_Outgoing_X_oINVITE"),
			
			/*=======================
			* === Outgoing === 
			*/
			// Outgoing -> (i2xx INVITE) -> Connected
			tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.OUTGOING, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2invite, tsip_dialog_invite_states_e.CONNECTED, c0000_Outgoing_2_Connected_X_i2xxINVITE, "c0000_Outgoing_2_Connected_X_i2xxINVITE"),
			// Outgoing -> (iINVITE ) -> Outgoing
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.OUTGOING, tsip_dialog_invite_actions_e.I_INVITE, tsip_dialog_invite_states_e.OUTGOING, c0000_Outgoing_2_Outgoing_X_iINVITEorUPDATE, "c0000_Outgoing_2_Outgoing_X_iINVITEorUPDATE"),
			// Outgoing -> (iUPDATE) -> Outgoing
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.OUTGOING, tsip_dialog_invite_actions_e.I_UPDATE, tsip_dialog_invite_states_e.OUTGOING, c0000_Outgoing_2_Outgoing_X_iINVITEorUPDATE, "c0000_Outgoing_2_Outgoing_X_iINVITEorUPDATE"),
			// Outgoing -> (oCANCEL) -> Cancelling
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.OUTGOING, tsip_dialog_invite_actions_e.O_CANCEL, tsip_dialog_invite_states_e.CANCELLING, c0000_Outgoing_2_Cancelling_X_oCANCEL, "c0000_Outgoing_2_Cancelling_X_oCANCEL"),
			// Cancelling -> (any response to cancel CANCEL) -> Cancelling
			tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.CANCELLING, tsip_dialog_invite_actions_e.I_300_to_699, __tsip_dialog_invite_cond_is_resp2cancel, tsip_dialog_invite_states_e.TERMINATED, null, "c0000_Cancelling_2_Terminated_X_i300_to_699"),
			tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.CANCELLING, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2cancel, tsip_dialog_invite_states_e.CANCELLING, null, "c0000_Cancelling_2_Cancelling_X_i2xx"),			
			// Cancelling -> (i300-699 INVITE) -> Terminated
			tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.CANCELLING, tsip_dialog_invite_actions_e.I_300_to_699, __tsip_dialog_invite_cond_is_resp2invite, tsip_dialog_invite_states_e.TERMINATED, c0000_Cancelling_2_Terminated_X_i300_to_699, "c0000_Cancelling_2_Terminated_X_i300_to_699"),
			// Outgoing -> (300-699 INVITE) -> Terminated
			tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.OUTGOING, tsip_dialog_invite_actions_e.I_300_to_699, __tsip_dialog_invite_cond_is_resp2invite, tsip_dialog_invite_states_e.TERMINATED, c0000_Outgoing_2_Terminated_X_i300_to_i699INVITE, "c0000_Outgoing_2_Terminated_X_i300_to_i699INVITE")

    );
}


//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

function c0000_Started_2_Outgoing_X_oINVITE(ao_args){
    var i_ret;
	var o_dialog = ao_args[0];
    var o_action = ao_args[2];
	
	/* This is the first FSM transaction when you try to make an audio/video/msrp call */
	if(!o_dialog.o_msession_mgr){
	    o_dialog.o_msession_mgr = o_dialog.new_msession_mgr(o_action ? o_action.media.e_type : tmedia_type_e.AUDIO_VIDEO, o_dialog.get_stack().network.s_local_ip, false/* ipv6 */, true);
	}

	/* We are the client */
	o_dialog.b_is_client = true;
	/* Whether it's a client dialog for call transfer */
	o_dialog.b_is_transf = (o_dialog.get_session().i_id_parent != tsip_session.prototype.__i_session_id_invalid);

	/* Update current action */
    o_dialog.set_action_curr(o_action);

	/* Get Media type from the action */
	o_dialog.get_session().media.e_type = o_action.media.e_type;
	/* Appy media params received from the user */
	if(o_action.media.ao_params.length > 0){
        tsk_utils_log_error("Not implemented");
        return -1;
		// tmedia_session_mgr_set_3(o_dialog.msession_mgr, action->media.params);
	}

	/*  RFC 4028 - 7.1. Generating an Initial Session Refresh Request

		A UAC MAY include a Session-Expires header field in an initial
		session refresh request if it wants a session timer applied to the
		session.  The value of this header field indicates the session
		interval desired by the UAC.  If a Min-SE header is included in the
		initial session refresh request, the value of the Session-Expires
		MUST be greater than or equal to the value in Min-SE.

		The UAC MAY include the refresher parameter with value 'uac' if it
		wants to perform the refreshes.  However, it is RECOMMENDED that the
		parameter be omitted so that it can be selected by the negotiation
		mechanisms described below.
	*/
	if(o_dialog.get_session().media.timers.i_timeout){
		o_dialog.stimers.i_timeout = o_dialog.get_session().media.timers.i_timeout;
		o_dialog.stimers.s_refresher = o_dialog.get_session().media.timers.s_refresher;
		o_dialog.stimers.is_refresher = tsk_stri,g_iequals(o_dialog.stimers.s_refresher, "uac");
		o_dialog.supported.b_timer = true;
	}

	/* send the request */
	i_ret = o_dialog.send_invite(false);

	// alert the user
	o_dialog.signal(tsip_event_code_e.DIALOG_CONNECTING, "Call in progress...");

	return i_ret;
}

function c0000_Outgoing_2_Outgoing_X_iINVITEorUPDATE(ao_args){
    tsk_utils_log_error("Not implemented");
    return 0;
}

function c0000_Outgoing_2_Connected_X_i2xxINVITE(ao_args) {
    var o_dialog = ao_args[0];
    var o_r2xx = ao_args[1];
    var i_ret = 0;

    /* Update the dialog state */
    if ((i_ret = o_dialog.update_with_response(o_r2xx))) {
        return ret;
    }

    /* Process remote offer */
    var b_is_offer = o_dialog.o_msession_mgr && !o_dialog.o_msession_mgr.has_lo();
    if ((i_ret = o_dialog.process_ro(o_r2xx, b_is_offer))) {
        return i_ret;
    }
    else {
        /* send ACK */
        i_ret = o_dialog.send_ack(o_r2xx);
    }

    /* Determine whether the remote party support UPDATE */
    o_dialog.b_support_update = o_r2xx.is_allowed("UPDATE");

    /* Session Timers */
    if (o_dialog.stimers.i_timeout) {
        o_dialog.stimers_handle(o_r2xx);
    }

    // alert user
    o_dialog.signal_invite(tsip_event_invite_type_e.M_EARLY_MEDIA, o_r2xx.get_response_code(), o_r2xx.get_response_phrase(), o_r2xx);
    o_dialog.signal(tsip_event_code_e.DIALOG_CONNECTED, "In Call");

    if (o_dialog.b_is_transf) {
        i_ret = o_dialog.notify_parent(o_r2xx);
        o_dialog.b_is_transf = false; //final response -> no longer need to notify the parent
    }

    return i_ret;
}

function c0000_Outgoing_2_Terminated_X_i300_to_i699INVITE(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];
    var i_ret = 0;

    // save last error
    o_dialog.set_last_error(o_response.get_response_code(), o_response.get_response_phrase(), o_response);

    // alert user
    i_ret = o_dialog.signal_invite(tsip_event_invite_type_e.I_AO_REQUEST, o_response.get_response_code(), o_response.get_response_phrase(), o_response);

    if (o_dialog.b_is_transf) {
        i_ret = o_dialog.notify_parent(o_response);
        o_dialog.b_is_transf = false; // final response -> no longer need to notify the parent
    }

    return i_ret;
}

function c0000_Outgoing_2_Cancelling_X_oCANCEL(ao_args) {
    var o_dialog = ao_args[0];

    // close PeerConnection
    if (o_dialog.o_msession_mgr) {
        i_ret = o_dialog.o_msession_mgr.stop();
    }

	/* Alert the user */
    o_dialog.signal(tsip_event_code_e.DIALOG_TERMINATING, "Call terminating...");

    return o_dialog.send_cancel();
}

/* 487 INVITE (To have more chances, any 300-699) */
function c0000_Cancelling_2_Terminated_X_i300_to_699(ao_args){
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

    /* set last error (or info) */
    o_dialog.set_last_error(o_response.get_response_code(), o_response.get_response_phrase(), o_response);

	return 0;
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/**
* Explicit Communication Transfer (ECT) using IP Multimedia (IM) Core Network (CN) subsystem (3GPP TS 24.629)
* The Explicit Communication transfer (ECT) service provides a party involved in a communication to transfer that
* communication to a third party.
* This code implements Consultative transfer mode (A.2).
*/

var x0400_Connected_2_Connected_X_fREFER = null;

tsip_dialog_invite.prototype.init_ect = function () {
    this.o_fsm.set(
        /*=======================
        * === Outgoing Transfer === 
        */
        // Connected -> (oREFER) -> oECTing
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.O_ECT, tsip_dialog_invite_states_e.O_ECT_INPROGRESS, x0400_Connected_2_oECTing_X_oECT, "x0400_Connected_2_oECTing_X_oECT"),
        // oECTing -> (i2xx REFER) -> oECTing
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.O_ECT_INPROGRESS, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2refer, tsip_dialog_invite_states_e.O_ECT_INPROGRESS, x0400_oECTing_2_oECTing_X_i2xx, "x0400_oECTing_2_oECTing_X_i2xx"),
        // oECTing -> (i300-699 REFER) -> Connected
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.O_ECT_INPROGRESS, tsip_dialog_invite_actions_e.I_300_to_699, __tsip_dialog_invite_cond_is_resp2refer, tsip_dialog_invite_states_e.CONNECTED, x0400_oECTing_2_Connected_X_i3456, "x0400_ECTing_2_Connected_X_i36"),
        // oECTing -> (iNotify 1xx sipfrag) -> oECTing
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.O_ECT_INPROGRESS, tsip_dialog_invite_actions_e.I_NOTIFY, __tsip_dialog_invite_cond_is_1xx_notify, tsip_dialog_invite_states_e.O_ECT_INPROGRESS, x0400_oECTing_2_oECTing_X_iNOTIFY, "x0400_oECTing_2_oECTing_X_iNOTIFY"),
        // oECTing -> (iNotify 23456 sipfrag) -> Connected
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.O_ECT_INPROGRESS, tsip_dialog_invite_actions_e.I_NOTIFY, __tsip_dialog_invite_cond_is_23456_notify, tsip_dialog_invite_states_e.CONNECTED, x0400_oECTing_2_Connected_X_iNOTIFY, "x0400_oECTing_2_Connected_X_iNOTIFY"),

        /*=======================
        * === Incoming Transfer === 
        */
        // Connected -> (iREFER invalid) -> Connected
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.I_REFER, __tsip_dialog_invite_cond_is_f_refer, tsip_dialog_invite_states_e.CONNECTED, x0400_Connected_2_Connected_X_fREFER, "x0400_Connected_2_Connected_X_fREFER"),
        // Connected -> (iREFER) -> iECTreq
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.I_REFER, tsip_dialog_invite_states_e.I_ECT_REQUESTED, x0400_Connected_2_iECTreq_X_iREFER, "x0400_Connected_2_iECTreq_X_iREFER"),
        // iECTreq -> (reject) -> Connected
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.I_ECT_REQUESTED, tsip_dialog_invite_actions_e.I_ECT_REJECT, tsip_dialog_invite_states_e.CONNECTED, x0400_iECTreq_2_Connected_X_reject, "x0400_iECTreq_2_Connected_X_reject"),
        // iECTreq -> (accept) -> iECTing
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.I_ECT_REQUESTED, tsip_dialog_invite_actions_e.I_ECT_ACCEPT, tsip_dialog_invite_states_e.I_ECT_INPROGRESS, x0400_iECTreq_2_iECTing_X_accept, "x0400_iECTreq_2_iECTing_X_accept"),
        // iECTing -> (1xx lnotify) -> iECTing
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.I_ECT_INPROGRESS, tsip_dialog_invite_actions_e.I_ECT_LNOTIFY, __tsip_dialog_invite_cond_is_1xx_f_notify, tsip_dialog_invite_states_e.I_ECT_INPROGRESS, x0400_iECTing_2_iECTing_X_1xxfNOTIFY, "x0400_iECTing_2_iECTing_X_1xxfNOTIFY"),
        // iECTing -> (23456 lnotify) -> Connected
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.I_ECT_INPROGRESS, tsip_dialog_invite_actions_e.I_ECT_LNOTIFY, __tsip_dialog_invite_cond_is_23456_f_notify, tsip_dialog_invite_states_e.CONNECTED, x0400_iECTing_2_Connected_X_23456fNOTIFY, "x0400_iECTing_2_Connected_X_23456fNOTIFY")

    );
};

tsip_dialog_invite.prototype.ect_send_notify = function(i_code, s_phrase){
	var o_notify;
	var i_ret = -1;

	if((o_notify = this.request_new("NOTIFY"))){
		var s_sipfrag = tsk_string_format("{0} {1} {2}\r\n", tsip_message.prototype.__s_version_default, i_code, s_phrase);
        o_notify.add_content(s_sipfrag, "message/sipfrag");
		i_ret = this.request_send(o_notify);
		if(i_ret == 0){
            this.signal_invite(tsip_event_invite_type_e.O_ECT_NOTIFY, i_code, s_phrase, o_notify);
		}
	}
	else{
		tsk_utils_log_error("Failed to create request");
	}
	return i_ret;
}

tsip_dialog_invite.prototype.ect_send_refer = function(s_to){
	var i_ret = 0;
	var o_refer;
	var o_toUri;

	if(!s_to){
		tsk_utils_log_error("Invalid parameter");
		return -1;
	}

	if(!(o_toUri = tsip_uri.prototype.Parse(s_to))){
		tsk_utils_log_error("Failed to parse " + s_to);
		return -1;
	}

	if((o_refer = this.request_new("REFER"))){
	    var o_hdr_Referred_By = new tsip_header_Referred_By(this.get_stack().identity.o_uri_impu);
        o_hdr_Referred_By.add_param("cid", tsk_string_random(11));
                
        o_refer.add_headers(
            new tsip_header_Refer_To(o_toUri),
            o_hdr_Referred_By,
            new tsip_header_Refer_Sub(this.supported.b_refer_sub)
        );
		if(this.supported.b_norefsub){
            o_refer.add_headers(new tsip_header_Supported("norefersub"));
		}
        i_ret = this.request_send(o_refer);
	}
	
	return i_ret;
}


//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

// Connected -> (oREFER) -> oECTing
function x0400_Connected_2_oECTing_X_oECT(ao_args){
	var i_ret;
	var o_dialog = ao_args[0];
    var o_action = ao_args[2];

	i_ret = o_dialog.ect_send_refer(o_action.ect.s_to);
	if(i_ret == 0){
        o_dialog.signal_invite(tsip_event_invite_type_e.O_ECT_TRYING, tsip_event_code_e.DIALOG_REQUEST_SENT, "Call Transfer Initiated", null);
	}
	//else; //Must never happen

	return i_ret;
}

// ECTing -> (i2xx REFER) -> oECTing
function x0400_oECTing_2_oECTing_X_i2xx(ao_args){
	var o_dialog = ao_args[0];
    var o_response = ao_args[1];
	var o_hdr_Refer_Sub;

	
	o_hdr_Refer_Sub = o_response.get_header(tsip_header_type_e.Refer_Sub);
	if(o_hdr_Refer_Sub){
		this.supported.b_refer_sub = o_hdr_Refer_Sub.b_sub;
	}
	if(o_response.is_required("norefersub")){
		this.require.b_norefsub = true;
	}

    o_dialog.signal_invite(tsip_event_invite_type_e.O_ECT_ACCEPTED, o_response.get_response_code(), o_response.get_response_phrase(), o_response);
    return 0;
}

// oECTing -> (i300-699 REFER) -> Connected
function x0400_oECTing_2_Connected_X_i3456(ao_args){
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

    o_dialog.signal_invite(tsip_event_invite_type_e.O_ECT_FAILED, o_response.get_response_code(), o_response.get_response_phrase(), o_response);
    return 0;
}

// oECTing -> (iNotify 1xx sipfrag) -> oECTing
function x0400_oECTing_2_oECTing_X_iNOTIFY(ao_args){
    var o_dialog = ao_args[0];
    var o_notify = ao_args[1];
    var o_sipfrag;

    if ((o_sipfrag = __tsip_dialog_invite_get_sip_frag_msg(o_notify))) {
        var i_ret = o_dialog.send_response(o_notify, 200, "OK", false);
        o_dialog.signal_invite(tsip_event_invite_type_e.O_ECT_NOTIFY, o_sipfrag.get_response_code(), o_sipfrag.get_response_phrase(), o_sipfrag);
        return i_ret;
    }
    return 0;
}

// oECTing -> (iNotify 23456 sipfrag) -> Connected
var x0400_oECTing_2_Connected_X_iNOTIFY = x0400_oECTing_2_oECTing_X_iNOTIFY;


// Connected -> (iREFER) -> iECTreq
function x0400_Connected_2_iECTreq_X_iREFER(ao_args){
    var o_dialog = ao_args[0];
    o_dialog.o_last_iRefer = ao_args[1];

    o_dialog.send_response(o_dialog.o_last_iRefer, 100, "Asking for Transfer", false);
    o_dialog.signal_invite(tsip_event_invite_type_e.I_ECT_REQUESTED, tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Request", o_dialog.o_last_iRefer);
    return 0;
}

// iECTreq -> (reject) -> Connected
function x0400_iECTreq_2_Connected_X_reject(ao_args){
    var o_dialog = ao_args[0];
    var o_action = ao_args[2];


    /* Send Reject */
    var i_code = o_action.line_resp.i_code >= 300 ? o_action.line_resp.i_code : 603;
    var s_phrase = o_action.line_resp.s_phrase ? o_action.line_resp.s_phrase : "Decline";
    var s_reason = tsk_string_format("SIP; cause={0}; text=\"{1}\"", i_code, s_phrase);
    return o_dialog.send_error(o_dialog.o_last_iRefer, i_code, s_phrase, s_reason);
}

// iECTreq -> (accept) -> iECTing
function x0400_iECTreq_2_iECTing_X_accept(ao_args) {
    var i_ret;
    var o_dialog = ao_args[0];
    var o_action = ao_args[2];

    i_ret = o_dialog.send_response(o_dialog.o_last_iRefer, 202, "Transfering...", false);
    var o_hdr_Refer_To = o_dialog.o_last_iRefer.get_header(tsip_header_type_e.Refer_To); // Not null: already checked
    // Make call to the referToUri
    this.o_ss_transf = new tsip_session_invite(o_dialog.get_stack(),
                                tsip_session.prototype.SetToStr(o_hdr_Refer_To.o_uri.tostring(false, false)),
                                tsip_session.prototype.SetCaps("+sip.ice")
                            );
    this.o_ss_transf.media.e_type = o_dialog.get_session().media.e_type;
    this.o_ss_transf.i_id_parent = o_dialog.get_session().get_id();

    tsip_event.prototype.Signal(tsip_event_invite_type_e.I_ECT_NEW_CALL, this.o_ss_transf, tsip_event_code_e.DIALOG_REQUEST_OUTGOING, "ECTing", o_dialog.o_last_iRefer);
    return this.o_ss_transf.call(this.o_ss_transf.media.e_type);
}


// iECTing -> (1xx lnotify) -> iECTing
function x0400_iECTing_2_iECTing_X_1xxfNOTIFY(ao_args){
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

    return o_dialog.ect_send_notify(o_response.get_response_code(), o_response.get_response_phrase());
}

// iECTing -> (23456 lnotify) -> Connected
function x0400_iECTing_2_Connected_X_23456fNOTIFY(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];
    var i_code = o_response.get_response_code();

    o_dialog.ect_send_notify(i_code, o_response.get_response_phrase());
    if (i_code >= 200 && i_code <= 299) {
        o_dialog.signal_invite(tsip_event_invite_type_e.I_ECT_COMPLETED, o_response.get_response_code(), o_response.get_response_phrase(), o_dialog.o_last_iRefer);
        return o_dialog.send_bye();
    }
    else {
        o_dialog.signal_invite(tsip_event_invite_type_e.I_ECT_FAILED, o_response.get_response_code(), o_response.get_response_phrase(), o_dialog.o_last_iRefer);
        return 0;
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function __tsip_dialog_invite_get_sip_frag_respcode(o_notify) {
    var o_sipfrag = __tsip_dialog_invite_get_sip_frag_msg(o_notify);
    return o_sipfrag ? o_sipfrag.get_response_code() : 0;
}

// returns 'tsip_response_t' contained in the NOTIFY body
function __tsip_dialog_invite_get_sip_frag_msg(o_notify){
    if(!o_notify){
        tsk_utils_log_error('Invalid parameter');
        return null;
    }
	var o_sipfrag;
    if(o_notify.has_content() && tsk_string_iequals(o_notify.get_content_type(), "message/sipfrag")){
		// sipfrag is a "tsip_message_t" with an extra \r\n
        var s_content = o_notify.get_content_as_string();
        if (s_content) {
            if (s_content.lastIndexOf('\r\n') != (s_content.length - 2)) {//Hack for XXX buggy client
                s_content += "\r\n";
            }
            s_content += "\r\n";

            var o_ragel_state = tsk_ragel_state_create();
            tsk_ragel_state_init_str(o_ragel_state, s_content);
            o_sipfrag = tsip_message.prototype.Parse(o_ragel_state, false);
            if (o_sipfrag && !o_sipfrag.is_response()) {
                tsk_utils_log_error("SipFrag doesn't contain response");
                return null;
            }
        }
	}
    return o_sipfrag;
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/*
* Communication Hold (3GPP TS 24.610)
* The Communication Hold supplementary service enables a user to suspend the reception of media stream(s) of an established IP multimedia session, 
* and resume the media stream(s) at a later time.
*/

tsip_dialog_invite.prototype.init_hold = function(){
    this.o_fsm.set(
        /*=======================
		* === Hold === 
		*/
		// Connected -> (send HOLD) -> Holding 
		tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.O_HOLD, tsip_dialog_invite_states_e.HOLDING, x0100_Connected_2_Holding_X_oHold, "x0100_Connected_2_Holding_X_oHold"),
		// Holding -> (i2xx) -> Connected
		tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.HOLDING, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2invite_or_update, tsip_dialog_invite_states_e.CONNECTED, x0101_Holding_2_Connected_X_ixxx, "x0101_Holding_2_Connected_X_ixxx"),
		// Holding -> (i300-699) -> Connected
		tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.HOLDING, tsip_dialog_invite_actions_e.I_300_to_699, __tsip_dialog_invite_cond_is_resp2invite_or_update, tsip_dialog_invite_states_e.CONNECTED, x0101_Holding_2_Connected_X_ixxx, "x0101_Holding_2_Connected_X_ixxx"),

		/*=======================
		* === Resume === 
		*/
		// Connected -> (send RESUME) -> Resuming
		tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.CONNECTED, tsip_dialog_invite_actions_e.O_RESUME, tsip_dialog_invite_states_e.RESUMING, x0102_Connected_2_Resuming_X_oResume, "x0102_Connected_2_Resuming_X_oResume"),
		// Resuming -> (i2xx) -> Connected
		tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.RESUMING, tsip_dialog_invite_actions_e.I_2XX, __tsip_dialog_invite_cond_is_resp2invite_or_update, tsip_dialog_invite_states_e.CONNECTED, x0103_Resuming_2_Connected_X_ixxx, "x0103_Resuming_2_Connected_X_ixxx"),
		// Resuming -> (i300-699) -> Connected
		tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.RESUMING, tsip_dialog_invite_actions_e.I_300_to_699, __tsip_dialog_invite_cond_is_resp2invite_or_update, tsip_dialog_invite_states_e.CONNECTED, x0103_Resuming_2_Connected_X_ixxx, "x0103_Resuming_2_Connected_X_ixxx")

    );

}

/* handle requests/responses (MUST be called after set_ro()) */
tsip_dialog_invite.prototype.hold_handle = function(o_request){
    if (!o_request || !this.o_msession_mgr || (!o_request.is_invite() && !o_request.is_update())) {
		tsk_utils_log_error("Invalid parameter");
		return -1;
	}

    var b_remote_hold;
    var b_bodiless_invite;
	var i_ret = 0;

	b_remote_hold = this.o_msession_mgr.is_held(this.o_msession_mgr.e_type, false);

	// resume the call if we receive bodiless INVITE
	b_bodiless_invite = !o_request.has_content() && o_request.is_invite();
	if(b_bodiless_invite && b_remote_hold){
		// resume remote
		if((i_ret = this.o_msession_mgr.resume(this.o_msession_mgr.e_type, false)) == 0){
			b_remote_hold = false;
		}
	}

	if(i_ret == 0 && (b_remote_hold != this.hold.b_remote)){
		this.hold.b_remote = b_remote_hold;
		this.signal_invite(this.hold.b_remote ? tsip_event_invite_type_e.M_REMOTE_HOLD : tsip_event_invite_type_e.M_REMOTE_RESUME, 
                tsip_event_invite_type_e.DIALOG_REQUEST_INCOMING, "Hold/Resume state changed", o_request);
	}

	return i_ret;
}

//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

// Connected -> (send HOLD) -> Holding
function x0100_Connected_2_Holding_X_oHold(ao_args){
	var i_ret;
	var o_dialog = ao_args[0];
    var o_action = ao_args[2];

	if(!o_dialog.o_msession_mgr){
		tsk_utils_log_warn("Media Session manager is Null");
		return 0;
	}

	/* put on hold */
    i_ret = o_dialog.o_msession_mgr.hold(o_action.media.e_type);

	/* Update current action */
    o_dialog.set_action_curr(o_action);

	/* send the request */
	if((iret = o_dialog.send_invite(false))){
		// signal error without breaking the state machine
	}

	return 0;
}

// Holding -> (ixxx) -> Connected
function x0101_Holding_2_Connected_X_ixxx(ao_args){
	var i_ret;
	var o_dialog = ao_args[0];
    var o_response = ao_args[1];

	/* reset current action */
	o_dialog.set_action_curr(null);

	/* Process remote offer */
	if((i_ret = o_dialog.process_ro(o_response))){
		return i_ret;
	}
	else if(o_response.is_response_to_invite()){
		i_ret = o_dialog.send_ack(o_response);
	}

	/* alert the user */
	if(o_response.is_2xx()){
        o_dialog.signal_invite(tsip_event_invite_type_e.M_LOCAL_HOLD_OK, o_response.get_response_code(), o_response.get_response_phrase(), o_response);
        o_dialog.hold.b_local = true;
	}
	else{
        o_dialog.signal_invite(tsip_event_invite_type_e.M_LOCAL_HOLD_NOK, o_response.get_response_code(), o_response.get_response_phrase(), o_response);
        o_dialog.hold.b_local = false;
	}
	
	return i_ret;
}

// Connected -> (send RESUME) -> Resuming
function x0102_Connected_2_Resuming_X_oResume(ao_args){
	var i_ret;
	var o_dialog = ao_args[0];
    var o_action = ao_args[2];

    if(!o_dialog.hold.b_local){
        tsk_utils_log_warn("Not on hold state");
		return 0;
    }

	if(!o_dialog.o_msession_mgr){
		tsk_utils_log_warn("Media Session manager is Null");
		return 0;
	}

	/* Resume both */
	i_ret = o_dialog.o_msession_mgr.resume(o_action.media.e_type, true);
	i_ret = o_dialog.o_msession_mgr.resume(o_action.media.e_type, false);

	/* update current action */
    o_dialog.set_action_curr(o_action);

	/* send the request */
	if((i_ret = o_dialog.send_invite(false))){
		// signal error without breaking the state machine
	}

	return 0;
}

// Resuming -> (ixxx) -> Connected
function x0103_Resuming_2_Connected_X_ixxx(ao_args){
	var i_ret;
	var o_dialog = ao_args[0];
    var o_response = ao_args[1];

	/* reset current action */
	o_dialog.set_action_curr(null);

	/* Process remote offer */
	if((i_ret = o_dialog.process_ro(o_response))){
		return i_ret;
	}
	else if(o_response.is_response_to_invite()){
		i_ret = o_dialog.send_ack(o_response);
	}

	/* alert the user */
    if(o_response.is_2xx()){
        o_dialog.signal_invite(tsip_event_invite_type_e.M_LOCAL_RESUME_OK, o_response.get_response_code(), o_response.get_response_phrase(), o_response);
        o_dialog.hold.b_local = false;
	}
	else{
        o_dialog.signal_invite(tsip_event_invite_type_e.M_LOCAL_RESUME_NOK, o_response.get_response_code(), o_response.get_response_phrase(), o_response);
        o_dialog.hold.b_local = true;
	}
	
	return i_ret;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_dialog_invite.prototype.__ao_supported_options = ["100rel", "timer"];

tsip_dialog_invite.prototype.init_server = function () {
    this.o_fsm.set(
        /*=======================
        * === Started === 
        */
        // Started -> (Bad Extendion) -> Terminated 
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.STARTED, tsip_dialog_invite_actions_e.I_INVITE, __tsip_dialog_invite_cond_is_bad_extension, tsip_dialog_invite_states_e.TERMINATED, s0000_Started_2_Terminated_X_iINVITE, "s0000_Started_2_Terminated_X_iINVITE"),
        // Started -> (Bad content) -> Terminated
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.STARTED, tsip_dialog_invite_actions_e.I_INVITE, __tsip_dialog_invite_cond_is_bad_content, tsip_dialog_invite_states_e.TERMINATED, s0000_Started_2_Terminated_X_iINVITE, "s0000_Started_2_Terminated_X_iINVITE"),
        // Started -> (Session Interval Too Small) -> Started
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.STARTED, tsip_dialog_invite_actions_e.I_INVITE, __tsip_dialog_invite_cond_is_toosmall, tsip_dialog_invite_states_e.STARTED, s0000_Started_2_Started_X_iINVITE, "s0000_Started_2_Started_X_iINVITE"),
        // Started -> (100rel) -> InProgress
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.STARTED, tsip_dialog_invite_actions_e.I_INVITE, __tsip_dialog_invite_cond_enable_100rel, tsip_dialog_invite_states_e.INPROGRESS, s0000_Started_2_InProgress_X_iINVITE, "s0000_Started_2_InProgress_X_iINVITE"),
        // Started -> (non-100rel and non-QoS, referred to as "basic") -> Ringing
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.STARTED, tsip_dialog_invite_actions_e.I_INVITE, tsip_dialog_invite_states_e.RINGING, s0000_Started_2_Ringing_X_iINVITE, "s0000_Started_2_Ringing_X_iINVITE"),
        

        /*=======================
        * === InProgress === 
        */
        // InProgress ->(iPRACK) -> Ringing
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.INPROGRESS, tsip_dialog_invite_actions_e.I_PRACK, __tsip_dialog_invite_cond_prack_matched, tsip_dialog_invite_states_e.RINGING, s0000_InProgress_2_Ringing_X_iPRACK, "s0000_InProgress_2_Ringing_X_iPRACK"),
        // InProgress ->(iUPDATE) -> InProgress
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.INPROGRESS, tsip_dialog_invite_actions_e.I_UPDATE, tsip_dialog_invite_states_e.INPROGRESS, s0000_InProgress_2_InProgress_X_iUPDATE, "s0000_InProgress_2_InProgress_X_iUPDATE"),
        // InProgress ->(iCANCEL) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.INPROGRESS, tsip_dialog_invite_actions_e.I_CANCEL, tsip_dialog_invite_states_e.TERMINATED, s0000_Inprogress_2_Terminated_X_iCANCEL, "s0000_Inprogress_2_Terminated_X_iCANCEL"),


        /*=======================
        * === Ringing === 
        */
        // Ringing -> (iPRACK) -> Ringing
        tsk_fsm_entry.prototype.Create(tsip_dialog_invite_states_e.RINGING, tsip_dialog_invite_actions_e.I_PRACK, __tsip_dialog_invite_cond_prack_matched, tsip_dialog_invite_states_e.RINGING, s0000_Ringing_2_Ringing_X_iPRACK, "s0000_Ringing_2_Ringing_X_iPRACK"),
        // Ringing -> (oAccept) -> Connected
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.RINGING, tsip_dialog_invite_actions_e.ACCEPT, tsip_dialog_invite_states_e.CONNECTED, s0000_Ringing_2_Connected_X_Accept, "s0000_Ringing_2_Connected_X_Accept"),
        // Ringing -> (oReject) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.RINGING, tsip_dialog_invite_actions_e.REJECT, tsip_dialog_invite_states_e.TERMINATED, s0000_Ringing_2_Terminated_X_Reject, "s0000_Ringing_2_Terminated_X_Reject"),
        // Ringing ->(iCANCEL) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_invite_states_e.RINGING, tsip_dialog_invite_actions_e.I_CANCEL, tsip_dialog_invite_states_e.TERMINATED, s0000_Ringing_2_Terminated_X_iCANCEL, "s0000_Ringing_2_Terminated_X_iCANCEL"),

        /*=======================
        * === ANY === 
        */
        // Any ->(timer100rel) -> Any
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_invite_actions_e.TIMER_100REL, tsk_fsm.prototype.__i_state_any, s0000_Any_2_Any_X_timer100rel, "s0000_Any_2_Any_X_timer100rel")
    );


}

/* ======================== conds ======================== */
function __tsip_dialog_invite_cond_is_bad_extension(o_dialog, o_message) {
    var o_hdr_require;
	var i, j, k;

	/* Check if we support all extensions */
	for(i = 0; (o_hdr_require = o_message.get_header_at(tsip_header_type_e.Require, i)); ++i){
		var b_bad_extension = false;
		var s_option = null;
		for(k = 0; k < o_hdr_require.as_options.length; ++k){
			b_bad_extension = true;
            s_option = o_hdr_require.as_options[k];
			for(j = 0; s_option && j < tsip_dialog_invite.prototype.__ao_supported_options.length; ++j){
				if(tsk_string_iequals(s_option, tsip_dialog_invite.prototype.__ao_supported_options[j])){
					b_bad_extension = false;
					break;
				}
			}
			if(b_bad_extension){
				break;
			}
		}
		if(b_bad_extension && s_option){
		    o_dialog.send_unsupported(o_message, s_option);
			return true;
		}
	}

	return false;
}

function __tsip_dialog_invite_cond_is_bad_content(o_dialog, o_message) {
    var i_ret;
    var o_sdp_lo;
    var b_bodiless_INVITE = (o_dialog.e_state == tsip_dialog_state_e.initial && !o_message.has_content()); // Initial Bodiless INVITE

    // Check remote offer
    var b_is_offer = o_dialog.o_msession_mgr && !o_dialog.o_msession_mgr.has_ro();
    if ((i_ret = o_dialog.process_ro(o_message, b_is_offer))) {
        i_ret = o_dialog.send_error(o_message, 488, "Not Acceptable", "SIP; cause=488; text=\"Bad content\"");
        return true;
    }
    // generate local offer and check it's validity
    /*if (false) { // FIXME: get_lo() is asynchronous
        if (o_dialog.o_msession_mgr && (o_sdp_lo = o_dialog.o_msession_mgr.get_lo())) {
            // check that we have at least one valid session (Only if no bodiless initial INVITE)
            if (!b_bodiless_INVITE && !o_dialog.o_msession_mgr.has_active_session()) {
                i_ret = o_dialog.send_error(o_message, 488, "Not Acceptable", "SIP; cause=488; text=\"No common codecs\"");
                return true;
            }
        }
        else {
            i_ret = o_dialog.send_error(o_message, 488, "Not Acceptable", "SIP; cause=488; text=\"Bad content\"");
            return true;
        }
    }*/

    return false;
}

function __tsip_dialog_invite_cond_is_toosmall(o_dialog, o_message){
	if(o_dialog.get_session().media.timers.i_timeout && (o_message.is_supported("timer") || o_message.is_required("timer"))){
		var o_hdr_Session_Expires;
		if((o_hdr_Session_Expires = o_message.get_header(tsip_header_type_e.Session_Expires))){
			if(o_hdr_Session_Expires.i_delta_seconds < TSIP_SESSION_EXPIRES_MIN_VALUE){
				o_dialog.stimers.i_minse = TSIP_SESSION_EXPIRES_MIN_VALUE;
				o_dialog.send_response(o_message, 422, "Session Interval Too Small", false);
				return true;
			}
			else{
				var o_hdr_Min_SE;
				o_dialog.stimers.i_timeout = o_hdr_Session_Expires.i_delta_seconds;
				o_dialog.stimers.s_refresher = o_hdr_Session_Expires.b_refresher_uas ? "uas" : "uac";
				o_dialog.stimers.b_is_refresher = tsk_string_iequals(o_dialog.stimers.s_refresher, "uas");
				if((o_hdr_Min_SE = o_message.get_header(tsip_header_type_e.Min_SE))){
					o_dialog.stimers.i_minse = o_hdr_Min_SE.i_value;
				}
			}
		}
	}
	return false;
}

function __tsip_dialog_invite_cond_enable_100rel(o_dialog, o_message){
	return ((o_message.is_supported("100rel") && o_dialog.supported.b_100rel) || o_message.is_required("100rel"))
}

function __tsip_dialog_invite_cond_prack_matched(o_dialog, o_message){
	var o_hdr_RAck;

	if(!o_dialog.o_last_o1xxrel){
		return false;
	}

	if((o_hdr_RAck = o_message.get_header(tsip_header_type_e.RAck))){
	    if ((o_hdr_RAck.i_seq == o_dialog.i_rseq) &&
			(tsk_string_iequals(o_hdr_RAck.s_method, o_dialog.o_last_o1xxrel.o_hdr_CSeq.s_method)) &&
			(o_hdr_RAck.i_cseq == o_dialog.o_last_o1xxrel.o_hdr_CSeq.i_seq)) {
				o_dialog.i_rseq++;
				return true;
		}
		else{
			tsk_utils_log_warn("Failed to match PRACK request");
		}
	}
	
	return false;
}

//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------


 // Failure
function s0000_Started_2_Terminated_X_iINVITE(ao_args){
	return 0;
}

// Session Interval Too Small
function s0000_Started_2_Started_X_iINVITE(ao_args){
    var o_dialog = ao_args[0];
    o_dialog.b_is_client = false;
    return 0;
}

// 100rel supported
function s0000_Started_2_InProgress_X_iINVITE(ao_args){
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];
	
	o_dialog.b_is_client = false;
	o_dialog.o_last_iInvite = o_request;
	o_dialog.b_support_update = o_request.is_allowed("UPDATE");

	/* Update state */
	o_dialog.update_with_invite(o_request);

	/* Send In Progress 
		RFC 3262 - 3 UAS Behavior
		
		The provisional response to be sent reliably is constructed by the
		UAS core according to the procedures of Section 8.2.6 of RFC 3261.
		In addition, it MUST contain a Require header field containing the
		option tag 100rel, and MUST include an RSeq header field.  The value
		of the header field for the first reliable provisional response in a
		transaction MUST be between 1 and 2**31 - 1.
	*/
	o_dialog.i_rseq = Math.floor((Math.random() * 0x0000FFFF));
	o_dialog.require.b_100rel = true;
	return o_dialog.send_response(o_request, 183, "Session in Progress", true);
}

// Neither 100rel nor QoS
function s0000_Started_2_Ringing_X_iINVITE(ao_args){
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];
	var o_hdr_SessionExpires;
	
	o_dialog.b_is_client = false;
	o_dialog.o_last_iInvite = o_request;
	o_dialog.b_support_update = o_request.is_allowed("UPDATE");

	// add "require:100rel" tag if the incoming INVITE contains "100rel" tag in "supported" header
	if(o_dialog.o_last_iInvite && (o_dialog.o_last_iInvite.is_supported("100rel") || o_dialog.o_last_iInvite.is_required("100rel")) && o_dialog.supported.b_100rel){
		o_dialog.require.b_100rel = true;
	}

	// add "require:timer" tag if incoming INVITE contains "timer" tag in "supported" header and session timers is enabled
	if(o_dialog.get_session().media.timers.i_timeout){
		if((o_hdr_SessionExpires = o_request.get_header(tsip_header_type_e.Session_Expires))){
			// "hdr_SessionExpires->delta_seconds" smallnest already checked
			o_dialog.stimers.timer.i_timeout = o_hdr_SessionExpires.i_delta_seconds;
			o_dialog.stimers.s_refresher = o_hdr_SessionExpires.s_refresher_uas ? "uas" : "uac";
			o_dialog.stimers.b_is_refresher = o_hdr_SessionExpires.s_refresher_uas;
			o_dialog.require.b_timer = true;
		}
	}

    /* update state */
	o_dialog.update_with_invite(o_request);

	/* send Ringing */
	o_dialog.send_response(o_request, 180, "Ringing", false);

	/* alert the user */
	o_dialog.signal_invite(tsip_event_invite_type_e.I_NEW_CALL, tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Call", o_request);

	return 0;
}

// PRACK for our 18x response (without QoS)
function s0000_InProgress_2_Ringing_X_iPRACK(ao_args){
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];
    var i_ret;

	/* Cancel 100rel timer */
    o_dialog.timer_cancel('100Rel');

	/* In all cases: Send 2xx PRACK */
	if((i_ret = o_dialog.send_response(o_request, 200, "OK", false)) == 0){
		++o_dialog.i_rseq;
	}

	/*
		1. Alice sends an initial INVITE without offer
		2. Bob's answer is sent in the first reliable provisional response, in this case it's a 1xx INVITE response
		3. Alice's answer is sent in the PRACK response
	*/
	if(o_dialog.o_msession_mgr && !o_dialog.o_msession_mgr.sdp.o_ro){
	    if (o_request.has_content()) {
	        var b_is_offer = o_dialog.o_msession_mgr && !o_dialog.o_msession_mgr.has_ro();
		    if ((i_ret = o_dialog.process_ro(o_request, b_is_offer))) {
				/* Send Error and break the FSM */
		        i_ret = o_dialog.send_error(o_dialog.o_last_iInvite, 488, "Not Acceptable", "SIP; cause=488; text=\"Bad content\"");
				return -4;
			}
		}
		else{
			/* 488 INVITE */
		    i_ret = o_dialog.send_error(o_dialog.o_last_iInvite, 488, "Not Acceptable", "SIP; cause=488; text=\"Offer expected in the PRACK\"");
			return -3;
		}
	}

	/* Send Ringing */
    i_ret = o_dialog.send_response(o_dialog.o_last_iInvite, 180, "Ringing", false);

    /* Alert the user (session) */
    o_dialog.signal_invite(tsip_event_invite_type_e.I_NEW_CALL, tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Call", o_request);

    return i_ret;
}

function s0000_InProgress_2_InProgress_X_iUPDATE(ao_args){
    tsk_utils_log_error("Not implemented");
    return 0;
}

function s0000_Inprogress_2_Terminated_X_iCANCEL(ao_args){
    tsk_utils_log_error("Not implemented");
    return 0;
}

function s0000_Ringing_2_Ringing_X_iPRACK(ao_args){
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];
    var i_ret;

	if(!o_dialog.o_last_iInvite){
		/* silently ignore */
		return 0;
	}

	/* Cancel 100rel timer */
    o_dialog.timer_cancel('100Rel');

	/* Send 2xx PRACK */
    i_ret = o_dialog.send_response(o_request, 200, "OK", false);

    /* alert the user */
    o_dialog.signal_invite(tsip_event_invite_type_e.I_REQUEST, tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Request", o_request);

	return i_ret;
}

function s0000_Ringing_2_Connected_X_Accept(ao_args) {
    var o_dialog = ao_args[0];
    var o_action = ao_args[2];
    var i_ret;

    // hack: not part of Doubango ANSI-C
    o_dialog.e_state = tsip_dialog_state_e.ESTABLISHED;

    /* Update current action */
    o_dialog.set_action_curr(o_action);

    /* FIXME: Appy media params received from the user */
    //if(!TSK_LIST_IS_EMPTY(action->media.params)){
    //	tmedia_session_mgr_set_3(o_dialog.msession_mgr, action->media.params);
    //}

    /* start session manager */
    if (o_dialog.o_msession_mgr && !o_dialog.o_msession_mgr.is_started() && (o_dialog.o_msession_mgr.has_lo() && o_dialog.o_msession_mgr.has_ro())) {
        /* Set MSRP Callback */
        //if((o_dialog.msession_mgr->type & tmedia_msrp) == tmedia_msrp){
        //	tmedia_session_mgr_set_msrp_cb(o_dialog.msession_mgr, TSIP_DIALOG_GET_SS(self)->userdata, TSIP_DIALOG_GET_SS(self)->media.msrp.callback);
        //}
        i_ret = o_dialog.o_msession_mgr.start();
    }    

    /* Cancel 100rel timer */
    o_dialog.timer_cancel('100Rel');

    /* send 2xx OK */
    i_ret = o_dialog.send_response(o_dialog.o_last_iInvite, 200, "OK", true);

    /* Session Timers */
    if (o_dialog.stimers.i_timeout) {
        if (o_dialog.stimers.b_is_refresher) {
            /* RFC 4028 - 9. UAS Behavior
            It is RECOMMENDED that this refresh be sent oncehalf the session interval has elapsed. 
            Additional procedures for this refresh are described in Section 10.
            */
            // tsip_dialog_invite_stimers_schedule(self, (o_dialog.stimers.timer.timeout*1000)/2);
            tsk_utils_log_error("Not implemented");
        }
        else {
            // tsip_dialog_invite_stimers_schedule(self, (o_dialog.stimers.timer.timeout*1000));
            tsk_utils_log_error("Not implemented");
        }
    }

    /* alert the user (dialog) */
    o_dialog.signal(tsip_event_code_e.DIALOG_CONNECTED, "In call");

    if (!o_dialog.o_msession_mgr.has_lo()) {
        // M_STREAM_CONNECTING
    }

    return i_ret;
}

function s0000_Ringing_2_Terminated_X_Reject(ao_args){
    var i_ret;
	var i_code;
	var s_phrase;
	var s_reason;

    var o_dialog = ao_args[0];
    var o_action = ao_args[2];

	/* Update current action */
    o_dialog.set_action_curr(o_action);

	/* Cancel 100rel timer */
	o_dialog.timer_cancel('100Rel');

	/* Send Reject */
	i_code = (o_action && o_action.line_resp.i_code >= 300) ? o_action.line_resp.i_code : 603;
	s_phrase = (o_action && o_action.line_resp.s_phrase) ? o_action.line_resp.s_phrase : "Decline";
	s_reason = tsk_string_format("SIP; cause={0}; text=\"{1}\"", i_code, s_phrase);
	i_ret = o_dialog.send_error(o_dialog.o_last_iInvite, i_code, s_phrase, s_reason);

	/* set last error (or info) */
	o_dialog.set_last_error(i_code, "Call Rejected");

	return i_ret;
}

function s0000_Ringing_2_Terminated_X_iCANCEL(ao_args){
    var o_dialog = ao_args[0];
    var o_request = ao_args[1];
    var o_response;
    var i_ret;

	/* Send 2xx for the CANCEL (Direct to Transport layer beacause CANCEL is a special case) */
	if((o_response = o_dialog.response_new(200, "OK", o_request))){
        i_ret = o_dialog.get_stack().o_layer_transport.send(null, o_response);
	}

	/* Send Request Cancelled */
    i_ret = o_dialog.send_error(o_dialog.o_last_iInvite, 487, "Request Cancelled", "SIP; cause=487; text=\"Request Cancelled\"");

	/* set last error (or info) */
	o_dialog.set_last_error(487, "Request Cancelled");

	/* alert the user */
	o_dialog.signal_invite(tsip_event_invite_type_e.I_REQUEST, tsip_event_code_e.DIALOG_REQUEST_INCOMING, "Incoming Request", o_request);

	return i_ret;
}

function s0000_Any_2_Any_X_timer100rel(ao_args) {
    var o_dialog = ao_args[0];
	var i_ret;

	if(!o_dialog.o_last_o1xxrel){
		/* silently ignore */
		return 0;
	}

	/* resync timer */
	if((o_dialog.i_timer100Rel <<= 1) >= (o_dialog.get_stack().o_timers.getA() << 6)){
		tsk_utils_log_error("Sending reliable 1xx failed");
		return -2;
	}

	/* resend reliable 1xx */
	if((i_ret = o_dialog.response_send(o_dialog.o_last_o1xxrel))){
		return i_ret;
	}
	else{
		/* schedule timer */
	    o_dialog.timer_schedule('invite', '100Rel');
	}

	return i_ret;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_dialog_register.prototype = Object.create(tsip_dialog.prototype);
tsip_dialog_register.prototype.__b_debug_state_machine = true;

var tsip_dialog_register_actions_e =
{
    ACCEPT: tsip_action_type_e.ACCEPT,
    REJECT: tsip_action_type_e.REJECT,
    HANGUP: tsip_action_type_e.HANGUP,
    O_REGISTER: tsip_action_type_e.REGISTER,
    CANCEL: tsip_action_type_e.CANCEL,
    SHUTDOWN: tsip_action_type_e.SHUTDOWN,

    I_1XX: 10001,
    I_2XX: 10002,
    I_401_407_421_494: 10003,
    I_423: 10004,
    I_300_to_699: 10005,

    I_REGISTER: 20000,

    SHUTDOWN_TIMEDOUT: 30000,
    TRANSPORT_ERROR: 30001,
    ERROR: 30002
};

var tsip_dialog_register_states_e =
{
    STARTED: 0,
    INPROGRESS: 1, // outgoing(client)
    INCOMING: 2, // incoming (server)
    CONNECTED: 3,
    TERMINATED: 4
};

function tsip_dialog_register(o_session, s_call_id) {
    tsip_dialog.call(this);
    this.o_last_iRegister = null;
    this.b_unregistering = false;
    this.b_is_server = false;

    this.o_timerRefresh = null;
    this.o_timerShutdown = null;
    this.i_timerShutdown = (tsip_dialog.prototype.__i_timer_shutdown << 1) / 3;

    this.init(tsip_dialog_type_e.REGISTER, s_call_id, o_session, tsip_dialog_register_states_e.STARTED, tsip_dialog_register_states_e.TERMINATED);
    this.set_callback(__tsip_dialog_register_event_callback);
    this.o_fsm.set_debug_enabled(tsip_dialog_register.prototype.__b_debug_state_machine);
    this.o_fsm.set_onterm_callback(__tsip_dialog_register_onterm, this);

    // initialize state machine
    this.o_fsm.set(
            /*=======================
			* === Started === 
			*/
			// Started -> (REGISTER) -> InProgress
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_register_states_e.STARTED, tsip_dialog_register_actions_e.O_REGISTER, tsip_dialog_register_states_e.INPROGRESS, __tsip_dialog_register_Started_2_InProgress_X_oRegister, "tsip_dialog_register_Started_2_InProgress_X_oRegister"),

			/*=======================
			* === InProgress === 
			*/
			// InProgress -> (1xx) -> InProgress
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_register_states_e.INPROGRESS, tsip_dialog_register_actions_e.I_1XX, tsip_dialog_register_states_e.INPROGRESS, __tsip_dialog_register_InProgress_2_InProgress_X_1xx, "tsip_dialog_register_InProgress_2_InProgress_X_1xx"),
			// InProgress -> (2xx) -> Terminated
			tsk_fsm_entry.prototype.Create(tsip_dialog_register_states_e.INPROGRESS, tsip_dialog_register_actions_e.I_2XX, __tsip_dialog_register_cond_client_unregistering, tsip_dialog_register_states_e.TERMINATED, __tsip_dialog_register_InProgress_2_Terminated_X_2xx, "tsip_dialog_register_InProgress_2_Terminated_X_2xx"),
            // InProgress -> (2xx) -> Connected
			tsk_fsm_entry.prototype.Create(tsip_dialog_register_states_e.INPROGRESS, tsip_dialog_register_actions_e.I_2XX, __tsip_dialog_register_cond_client_registering, tsip_dialog_register_states_e.CONNECTED, __tsip_dialog_register_InProgress_2_Connected_X_2xx, "tsip_dialog_register_InProgress_2_Connected_X_2xx"),
			// InProgress -> (401/407/421/494) -> InProgress
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_register_states_e.INPROGRESS, tsip_dialog_register_actions_e.I_401_407_421_494, tsip_dialog_register_states_e.INPROGRESS, __tsip_dialog_register_InProgress_2_InProgress_X_401_407_421_494, "tsip_dialog_register_InProgress_2_InProgress_X_401_407_421_494"),
			// InProgress -> (423) -> InProgress
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_register_states_e.INPROGRESS, tsip_dialog_register_actions_e.I_423, tsip_dialog_register_states_e.INPROGRESS, __tsip_dialog_register_InProgress_2_InProgress_X_423, "tsip_dialog_register_InProgress_2_InProgress_X_423"),
			// InProgress -> (300_to_699) -> Terminated
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_register_states_e.INPROGRESS, tsip_dialog_register_actions_e.I_300_to_699, tsip_dialog_register_states_e.TERMINATED, __tsip_dialog_register_InProgress_2_Terminated_X_300_to_699, "tsip_dialog_register_InProgress_2_Terminated_X_300_to_699"),
			// InProgress -> (cancel) -> Terminated
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_register_states_e.INPROGRESS, tsip_dialog_register_actions_e.CANCEL, tsip_dialog_register_states_e.TERMINATED, __tsip_dialog_register_InProgress_2_Terminated_X_cancel, "tsip_dialog_register_InProgress_2_Terminated_X_cancel"),
			// InProgress -> (hangup) -> Terminated
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_register_states_e.INPROGRESS, tsip_dialog_register_actions_e.HANGUP, tsip_dialog_register_states_e.TERMINATED, null, "tsip_dialog_register_InProgress_2_Terminated_X_hangup"),
			// InProgress -> (shutdown) -> Terminated
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_register_states_e.INPROGRESS, tsip_dialog_register_actions_e.SHUTDOWN, tsip_dialog_register_states_e.TERMINATED, null, "tsip_dialog_register_InProgress_2_Terminated_X_shutdown"),

            
			/*=======================
			* === Connected === 
			*/
			// Connected -> (register) -> InProgress [refresh case]
			tsk_fsm_entry.prototype.CreateAlways(tsip_dialog_register_states_e.CONNECTED, tsip_dialog_register_actions_e.O_REGISTER, tsip_dialog_register_states_e.INPROGRESS, __tsip_dialog_register_Connected_2_InProgress_X_oRegister, "tsip_dialog_register_Connected_2_InProgress_X_oRegister"),

            /*=======================
			* === Any === 
			*/
			// Any -> (hangup) -> InProgress
			tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_register_actions_e.HANGUP, __tsip_dialog_register_cond_not_silent_hangup, tsip_dialog_register_states_e.INPROGRESS, __tsip_dialog_register_Any_2_InProgress_X_hangup, "tsip_dialog_register_Any_2_InProgress_X_hangup"),
			// Any -> (silenthangup) -> Terminated
			tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_register_actions_e.HANGUP, __tsip_dialog_register_cond_silent_hangup, tsip_dialog_register_states_e.TERMINATED, null, "tsip_dialog_register_Any_2_InProgress_X_silenthangup"),
			// Any -> (shutdown) -> InProgress
			tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_register_actions_e.SHUTDOWN, __tsip_dialog_register_cond_not_silent_shutdown, tsip_dialog_register_states_e.INPROGRESS, __tsip_dialog_register_Any_2_InProgress_X_shutdown, "tsip_dialog_register_Any_2_InProgress_X_shutdown"),
			// Any -> (silentshutdown) -> Terminated
			tsk_fsm_entry.prototype.Create(tsk_fsm.prototype.__i_state_any, tsip_dialog_register_actions_e.SHUTDOWN, __tsip_dialog_register_cond_silent_shutdown, tsip_dialog_register_states_e.TERMINATED, null, "tsip_dialog_register_Any_2_InProgress_X_silentshutdown"),
			// Any -> (shutdown timedout) -> Terminated
			tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_register_actions_e.SHUTDOWN_TIMEDOUT, tsip_dialog_register_states_e.TERMINATED, null, "tsip_dialog_register_shutdown_timedout"),			
			// Any -> (transport error) -> Terminated
			tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_register_actions_e.TRANSPORT_ERROR, tsip_dialog_register_states_e.TERMINATED, __tsip_dialog_register_Any_2_Terminated_X_transportError, "tsip_dialog_register_Any_2_Terminated_X_transportError"),
			// Any -> (error) -> Terminated
			tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_dialog_register_actions_e.ERROR, tsip_dialog_register_states_e.TERMINATED, __tsip_dialog_register_Any_2_Terminated_X_Error, "tsip_dialog_register_Any_2_Terminated_X_Error")
    );
}

tsip_dialog_register.prototype.signal_register = function (e_register_type, i_code, s_phrase, o_message) {
    var o_event = new tsip_event_register(this.get_session(), i_code, s_phrase, o_message, e_register_type);
    return o_event.signal();
}

tsip_dialog_register.prototype.send_register = function(b_initial) {
    var o_request = null;
    var i_ret = -1;

    /* whether we are unregistering */
    if (this.b_unregistering) {
        this.i_expires = 0;
    }

    /* creates REGISTER request */
    if ((o_request = this.request_new("REGISTER"))) {
        /* 3GPP TS 24.229 - 5.1.1.2 Initial registration */
        if (this.e_state == tsip_dialog_state_e.INITIAL) {
            /*
            g) the Supported header field containing the option-tag "path", and
            1) if GRUU is supported, the option-tag "gruu"; and
            2) if multiple registrations is supported, the option-tag "outbound".
            */
            o_request.add_header(new tsip_header_Supported("path"));
        }

        /* action parameters and payload */
        if (this.o_action_curr) {
            tsip_dialog.prototype.ApplyAction(o_request, this.o_action_curr);
        }

        if ((i_ret = this.request_send(o_request)) == 0) {
            this.signal(tsip_event_code_e.DIALOG_REQUEST_SENT, tsk_string_format("{0}REGISTER request successfully sent", this.b_unregistering ? "un" : ""));
        }
        else {
            this.signal(tsip_event_code_e.DIALOG_TRANSPORT_ERROR, "Transport error");
        }
    }

    return i_ret;
};

function __tsip_dialog_register_timer_callback(o_self, o_timer) {
    var i_ret = -1;
    if (o_self) {
        if (o_self.o_timerRefresh == o_timer) {
            i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.O_REGISTER, null, null);
        }
        else if (o_self.o_timerShutdown == o_timer) {
            i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.SHUTDOWN, null, null);
        }
    }
    return i_ret;
}

function __tsip_dialog_register_event_callback(o_self, e_type, o_message){
	var i_ret = -1;

	switch(e_type){
	    case tsip_dialog_event_type_e.I_MSG:
			{
			    if (o_message) {
			        if (o_message.is_response()) {
						//	RESPONSE
						if(o_message.is_1xx()){
						    i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.I_1XX, o_message, null);
						}
			            else if (o_message.is_2xx()) {
			                i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.I_2XX, o_message, null);
						}
			            else if (o_message.is_response_xxx(401) || o_message.is_response_xxx(407) || o_message.is_response_xxx(421) || o_message.is_response_xxx(494)) {
			                i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.I_401_407_421_494, o_message, null);
						}
						else if (o_message.is_response_xxx(423)) {
						    i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.I_423, o_message, null);
						}
						else{
						    i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.ERROR, o_message, null);
						}
					}
					else{
						//	REQUEST
					    if (o_message.is_register()) {
						    i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.I_REGISTER, o_message, null);
						}
					}
				}
				break;
			}

        case tsip_dialog_event_type_e.CANCELED:
			{
			    i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.CANCEL, o_message, null);
				break;
			}

        case tsip_dialog_event_type_e.TERMINATED:
        case tsip_dialog_event_type_e.TIMEDOUT:
        case tsip_dialog_event_type_e.ERROR:
        case tsip_dialog_event_type_e.TRANSPORT_ERROR:
			{
			    i_ret = o_self.fsm_act(tsip_dialog_register_actions_e.TRANSPORT_ERROR, o_message, null);
				break;
			}
	}

	return i_ret;
}

/* ======================== conds ======================== */
function __tsip_dialog_register_cond_client_unregistering(o_dialog, o_message) {
    return !o_dialog.b_is_server && o_dialog.b_unregistering;
}
function __tsip_dialog_register_cond_client_registering(o_dialog, o_message) {
    return !__tsip_dialog_register_cond_client_unregistering(o_dialog, o_message);
}
function __tsip_dialog_register_cond_silent_hangup(o_dialog, o_message){
	return o_dialog.o_session.b_silent_hangup;
}
function __tsip_dialog_register_cond_not_silent_hangup(o_dialog, o_message){
    return !__tsip_dialog_register_cond_silent_hangup(o_dialog, o_message);
}
function __tsip_dialog_register_cond_silent_shutdown(o_dialog, o_message) {
    return __tsip_dialog_register_cond_silent_hangup(o_dialog, o_message);
}
function __tsip_dialog_register_cond_not_silent_shutdown(o_dialog, o_message) {
    return !__tsip_dialog_register_cond_silent_shutdown(o_dialog, o_message);
}

//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

function __tsip_dialog_register_Started_2_InProgress_X_oRegister(ao_args) {
    var o_dialog = ao_args[0];
    var o_action = ao_args[2];

    o_dialog.b_running = true;
    o_dialog.set_action_curr(o_action);

    // alert user
    o_dialog.signal(tsip_event_code_e.DIALOG_CONNECTING, "Connecting...");

    // send register
    return o_dialog.send_register(true);
}

function __tsip_dialog_register_InProgress_2_InProgress_X_1xx(ao_args) {
    var o_dialog = ao_args[0];
    var o_message1xx = ao_args[1];

    // alert user
    o_dialog.signal_register(tsip_event_register_type_e.AO_REGISTER, o_message1xx.get_response_code(), o_message1xx.get_response_phrase(), o_message1xx);

    return o_dialog.update_with_response(o_message1xx);
}

function __tsip_dialog_register_InProgress_2_Terminated_X_2xx(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

	// save last error
    o_dialog.set_last_error(o_response.get_response_code(), o_response.get_response_phrase(), o_response);

    // alert user
    o_dialog.signal_register(tsip_event_register_type_e.AO_UNREGISTER, o_response.get_response_code(), o_response.get_response_phrase(), o_response);

	return 0;
}

function __tsip_dialog_register_InProgress_2_Connected_X_2xx(ao_args) {
	var o_dialog = ao_args[0];
    var o_response = ao_args[1];

    var i_ret;
	var b_first_time_to_connect = (o_dialog.e_state == tsip_dialog_state_e.INITIAL);
    var o_stack = o_dialog.get_stack();

	/*	- Set P-associated-uriS
	*	- Update service-routes
	*	- Update Pats
	*/
	{
		var i_index;
		var o_hdr_Path;
		var o_hdr_Service_Route;
		var o_hdr_P_Associated_URI;
		
        o_stack.ao_uri_associated_uris.splice(0, o_stack.ao_uri_associated_uris.length);
        o_stack.ao_uri_service_routes.splice(0, o_stack.ao_uri_service_routes.length);
        o_stack.ao_uri_paths.splice(0, o_stack.ao_uri_paths.length);

		/* Associated URIs */
		for(i_index = 0; (o_hdr_P_Associated_URI = o_response.get_header_at(tsip_header_type_e.P_Associated_URI, i_index)); ++i_index){
            if(o_hdr_P_Associated_URI.o_uri){
                o_stack.ao_uri_associated_uris.push(o_hdr_P_Associated_URI.o_uri);
            }
		}

		/*	Service-Route (3GPP TS 24.229)
			store the list of service route values contained in the Service-Route header field and bind the list to the contact
			address used in registration, in order to build a proper preloaded Route header field value for new dialogs and
			standalone transactions when using the respective contact address.
		*/
		for(i_index = 0; (o_hdr_Service_Route = o_response.get_header_at(tsip_header_type_e.Service_Route, i_index)); ++i_index){
            if(o_hdr_Service_Route.o_uri){
                o_stack.ao_uri_service_routes.push(o_hdr_Service_Route.o_uri);
            }
		}

		/* Paths */
		for(i_index = 0; (o_hdr_Path = o_response.get_header_at(tsip_header_type_e.Path, i_index)); ++i_index){
			if(o_hdr_Path.o_uri){
                o_stack.ao_uri_paths.push(o_hdr_Path.o_uri);
            }
		}
	}

	/* 3GPP TS 24.229 - 5.1.1.2 Initial registration */
	if(b_first_time_to_connect){
		var b_barred = true;
		var o_uri;
		var o_uri_first = null;

	/*	
		b) store as the default public user identity the first URI on the list of URIs present in the P-Associated-URI header
		field and bind it to the respective contact address of the UE and the associated set of security associations or TLS
		session;
		NOTE 4: When using the respective contact address and associated set of security associations or TLS session, the
		UE can utilize additional URIs contained in the P-Associated-URI header field and bound it to the
		respective contact address of the UE and the associated set of security associations or TLS session, e.g. for
		application purposes.
		c) treat the identity under registration as a barred public user identity, if it is not included in the P-Associated-URI
		header field;
	*/
		for(i_index = 0; i_index < o_stack.ao_uri_associated_uris.length; ++i_index){
            if(!(o_uri = o_stack.ao_uri_associated_uris[i_index].o_uri)){
                continue;
            }
			if(i_index == 0){
				o_uri_first = o_stack.ao_uri_associated_uris[i_index].o_uri;
			}
            if (o_stack.identity.o_uri_pref.compare(o_uri) == 0) {
				b_barred = false;
				break;
			}
		}

		if(b_barred && o_uri_first){
            o_stack.identity.o_uri_pref = o_uri_first;
		}
	}
	
	// Update the dialog state
	if((i_ret = o_dialog.update_with_response(o_response)) != 0){
		return i_ret;
	}
	
	// Reset current action */
	o_dialog.set_action_curr(null);
	
	// Request timeout for dialog refresh (re-registration)
	o_dialog.i_timerRefresh = o_dialog.get_newdelay(o_response);
	o_dialog.timer_schedule('register', 'Refresh');

	// alert user
	o_dialog.signal_register(tsip_event_register_type_e.AO_REGISTER, o_response.get_response_code(), o_response.get_response_phrase(), o_response);
	if (b_first_time_to_connect) {
	    o_dialog.signal(tsip_event_code_e.DIALOG_CONNECTED, "Connected");
	}
	
	return i_ret;
}

function __tsip_dialog_register_InProgress_2_InProgress_X_401_407_421_494(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];
	var i_ret;

	if((i_ret = o_dialog.update_with_response(o_response))){
		// alert user
		o_dialog.signal_register(tsip_event_register_type_e.AO_REGISTER, o_response.get_response_code(), o_response.get_response_phrase(), o_response);
		
		// set last error
		o_dialog.set_last_error(o_response.get_response_code(), o_response.get_response_phrase(), o_response);
		
		return i_ret;
	}

    return o_dialog.send_register(false);
}

function __tsip_dialog_register_InProgress_2_InProgress_X_423(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

	var o_hdr_Min_Expires;
	var i_ret = 0;

	/*
	RFC 3261 - 10.2.8 Error Responses

	If a UA receives a 423 (Interval Too Brief) response, it MAY retry
	the registration after making the expiration interval of all contact
	addresses in the REGISTER request equal to or greater than the
	expiration interval within the Min-Expires header field of the 423
	(Interval Too Brief) response.
	*/
	o_hdr_Min_Expires = o_response.get_header(tsip_header_type_e.Min_Expires);
	if(o_hdr_Min_Expires){
	    o_dialog.i_expires = (o_hdr_Min_Expires.i_value * 1000); // to milliseconds
		i_ret = o_dialog.send_register(false);
	}
    else {
        tsk_utils_log_error("Missing header: Min_Expires");
		i_ret = -1;
	}

	return i_ret;
}

function __tsip_dialog_register_InProgress_2_Terminated_X_300_to_699(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

	// save last error
	o_dialog.set_last_error(o_response.get_response_code(), o_response.get_response_phrase(), o_response);
	
	// alert user
    o_dialog.signal_register(o_dialog.b_unregistering ? tsip_event_register_type_e.AO_UNREGISTER : tsip_event_register_type_e.AO_REGISTER, 
                o_response.get_response_code(), o_response.get_response_phrase(), o_response);
	
	return 0;
}

function __tsip_dialog_register_InProgress_2_Terminated_X_cancel(ao_args) {
    var o_dialog = ao_args[0];
	var o_action = ao_args[3];
    var i_ret;

    // set  current action
	o_dialog.set_action_curr(o_action);

	// Cancel all transactions associated to this dialog (will also be done when the dialog is destroyed (worth nothing))
	i_ret = o_dialog.get_layer_transac().cancel_by_dialog(o_dialog);

	/* RFC 3261 - 9.1 Client Behavior
	   A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.
	*/

	// alert the user
    o_dialog.signal(tsip_event_code_e.DIALOG_CANCELLED, "Registration cancelled");

	return i_ret;
}

function __tsip_dialog_register_Connected_2_InProgress_X_oRegister(ao_args) {
    var o_dialog = ao_args[0];
	var o_action = ao_args[3];

	// set  current action
	o_dialog.set_action_curr(o_action);

	return o_dialog.send_register(true);
}

function __tsip_dialog_register_Any_2_InProgress_X_hangup(ao_args) {
    var o_dialog = ao_args[0];
	var o_action = ao_args[3];

	// set  current action
    o_dialog.set_action_curr(o_action);

	// alert the user
    o_dialog.signal(tsip_event_code_e.DIALOG_TERMINATING, "Disconnecting...");

    o_dialog.b_unregistering = true;
	return o_dialog.send_register(true);
}

function __tsip_dialog_register_Any_2_InProgress_X_shutdown(ao_args) {
    var o_dialog = ao_args[0];
	
	// schedule shutdow timer
    o_dialog.timer_schedule('register', 'Shutdown');

	// alert user
    o_dialog.signal(tsip_event_code_e.DIALOG_TERMINATING, "Disconnecting...");

	o_dialog.b_unregistering = true;
	return o_dialog.send_register(true);
}

function __tsip_dialog_register_Any_2_Terminated_X_transportError(ao_args) {
    var o_dialog = ao_args[0];
    o_dialog.signal(tsip_event_code_e.DIALOG_TRANSPORT_ERROR, "Transport error");
    return 0;
}

function __tsip_dialog_register_Any_2_Terminated_X_Error(ao_args) {
    var o_dialog = ao_args[0];
    var o_response = ao_args[1];

	// save last error
    if(o_response){
	    o_dialog.set_last_error(o_response.get_response_code(), o_response.get_response_phrase(), o_response);
        o_dialog.signal_register(o_dialog.b_unregistering ? tsip_event_register_type_e.AO_UNREGISTER : tsip_event_register_type_e.AO_REGISTER, 
                o_response.get_response_code(), o_response.get_response_phrase(), o_response);
    }
    else{
        o_dialog.signal(tsip_event_code_e.DIALOG_GLOBAL_ERROR, "Global error");
    }

	return 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function __tsip_dialog_register_onterm(o_self) {
    tsk_utils_log_info("=== REGISTER Dialog terminated ===");

    o_self.timer_cancel('Refresh');
    o_self.timer_cancel('Shutdown');

    o_self.signal(tsip_event_code_e.DIALOG_TERMINATED,
            o_self.last_error.s_phrase ? o_self.last_error.s_phrase : "Disconnected",
            o_self.last_error.o_message);

    // deinit
    return o_self.deinit();
}


/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
function tsip_dialog_layer(o_stack) {
    if (!o_stack) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    
    this.o_stack = o_stack;
    this.ao_dialogs = new Array();

    this.shutdown = {};
    this.shutdown.b_inprogress = false;
    this.shutdown.b_phase2 = false;

    this.b_locked = false;
}

// only used for find()
function tsip_dialog_layer_find_result(o_dialog, b_cid_matched){
    this.o_dialog = o_dialog;
    this.b_cid_matched = b_cid_matched;
}

tsip_dialog_layer.prototype.find_by_ss = function (o_session) {
    if (!o_session) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    return this.find_by_ssid(o_session.i_id);
}

tsip_dialog_layer.prototype.find_by_ssid = function (i_sid) {   
    var o_dialog = null;

    while (this.b_locked){}

    this.b_locked = true;
    for (var i = 0; i < this.ao_dialogs.length; ++i) {
        if (this.ao_dialogs[i].o_session && this.ao_dialogs[i].o_session.i_id == i_sid) {
            o_dialog = this.ao_dialogs[i];
            break;
        }
    }
    this.b_locked = false;

    return o_dialog;
}

tsip_dialog_layer.prototype.find = function(s_callid, s_to_tag, s_from_tag, e_request_type){
	var o_ret = null;
	var o_dialog;
	var b_cid_matched = false;
	
	while (this.b_locked){}
    this.b_locked = true;

	for(var i = 0; i< this.ao_dialogs.length; ++i){
		o_dialog = this.ao_dialogs[i];
		if(tsk_string_equals(o_dialog.s_callid, s_callid)){
			var b_is_cancel = (e_request_type == tsip_request_type_e.CANCEL); // Incoming CANCEL
			var b_is_register = (e_request_type == tsip_request_type_e.REGISTER); // Incoming REGISTER
			var b_is_notify = (e_request_type == tsip_request_type_e.NOTIFY); // Incoming NOTIFY
			b_cid_matched = true;
			/* CANCEL Request will have the same local tag than the INVITE request -> do not compare tags */
			if((b_is_cancel || tsk_string_equals(o_dialog.s_tag_local, s_from_tag)) && (!o_dialog.s_tag_remote || tsk_string_equals(o_dialog.s_tag_remote, s_to_tag))){
				o_ret = o_dialog;
				break;
			}
			/* REGISTER is dialogless which means that each reREGISTER or unREGISTER will have empty to tag  */
			if(b_is_register /* Do not check tags */){
				o_ret = o_dialog;
				break;
			}
			/*	NOTIFY could arrive before the 200 SUBSCRIBE => This is why we don't try to match both tags
			 
				RFC 3265 - 3.1.4.4. Confirmation of Subscription Creation
				Due to the potential for both out-of-order messages and forking, the
				subscriber MUST be prepared to receive NOTIFY messages before the
				SUBSCRIBE transaction has completed.
			 */
			if(b_is_notify /* Do not check tags */){
				o_ret = o_dialog;
				break;
			}
		}
	}

	this.b_locked = false;

	return new tsip_dialog_layer_find_result(o_ret, b_cid_matched);
}

tsip_dialog_layer.prototype.dialog_new = function (e_dialog_type, o_session) {
    var o_dialog = null;

    while (this.b_locked){}

    this.b_locked = true;

    switch (e_dialog_type) {
        case tsip_dialog_type_e.REGISTER:
            {
                if ((o_dialog = new tsip_dialog_register(o_session, null))) {
                    this.ao_dialogs.push(o_dialog);
                }
                break;
            }
        case tsip_dialog_type_e.INVITE:
            {
                if ((o_dialog = new tsip_dialog_invite(o_session, null))) {
                    this.ao_dialogs.push(o_dialog);
                }
                break;
            }
        case tsip_dialog_type_e.MESSAGE:
        case tsip_dialog_type_e.INFO:
        case tsip_dialog_type_e.OPTIONS:
        case tsip_dialog_type_e.PUBLISH:
        case tsip_dialog_type_e.SUBSCRIBE:
        default:
            {
                if ((o_dialog = new tsip_dialog_generic(e_dialog_type, o_session, null))) {
                    this.ao_dialogs.push(o_dialog);
                }
                break;
            }
    }

    this.b_locked = false;

    return o_dialog;
}

tsip_dialog_layer.prototype.dialog_remove = function (o_dialog) {
    if (o_dialog) {
        while (this.b_locked){}

        this.b_locked = true;
        for (var i = 0; i < this.ao_dialogs.length; ++i) {
            if (this.ao_dialogs[i] == o_dialog) {
                this.ao_dialogs.splice(i, 1);
                break;
            }
        }
        this.b_locked = false;
    }
}

// this function is only called if no transaction match
// for responses, the transaction will always match
tsip_dialog_layer.prototype.handle_incoming_message = function (o_message) {
    var i_ret = -1;
    var o_transac = null;
    var o_layer_transac = this.o_stack.o_layer_transac;

    var o_ret = this.find(o_message.o_hdr_Call_ID.s_value,
		o_message.is_response() ? o_message.o_hdr_To.s_tag : o_message.o_hdr_From.s_tag,
		o_message.is_response() ? o_message.o_hdr_From.s_tag : o_message.o_hdr_To.s_tag,
		o_message.is_request() ? o_message.line.request.e_type : tsip_request_type_e.NONE);

    var b_cid_matched = o_ret.b_cid_matched;
    var o_dialog = o_ret.o_dialog;

    if (o_dialog) {
        if (o_message.is_cancel() || o_message.is_ack()) {
            return o_dialog.callback(tsip_dialog_event_type_e.I_MSG, o_message);
        }
        else {
            o_transac = o_layer_transac.transac_new(false, o_message, o_dialog);
        }
    }
    else {
        if (o_message.is_request()) {
            var o_session = null;
            var o_newdialog = null;

            switch (o_message.line.request.e_type) {
                case tsip_request_type_e.MESSAGE:
                    {	/* Server incoming MESSAGE */
                        if ((o_session = new tsip_session_message(this.o_stack, tsip_session.prototype.SetInitialMessage(o_message)))) {
                            o_newdialog = new tsip_dialog_generic(tsip_dialog_type_e.MESSAGE, o_session, o_message.o_hdr_Call_ID ? o_message.o_hdr_Call_ID.s_value : null);
                        }
                        break;
                    }
                case tsip_request_type_e.INFO:
                    {	/* Server incoming INFO */
                        //if((ss = tsip_ssession_create_2(self->stack, message))){
                        //	newdialog = (tsip_dialog_t*)tsip_dialog_info_create(ss);
                        //}
                        tsk_utils_log_warn("Not implemented");
                        break;
                    }
                case tsip_request_type_e.OPTIONS:
                    {	/* Server incoming OPTIONS */
                        //if((ss = tsip_ssession_create_2(self->stack, message))){
                        //	newdialog = (tsip_dialog_t*)tsip_dialog_options_create(ss);
                        //}
                        //tsk_utils_log_error("Not implemented"); //SKOROZVON just send OK
                        break;
                    }

                case tsip_request_type_e.REGISTER:
                    {	/* incoming REGISTER */
                        //if((ss = tsip_ssession_create_2(self->stack, message))){
                        //	newdialog = (tsip_dialog_t*)tsip_dialog_register_create(ss, message->Call_ID ? message->Call_ID->value : tsk_null);
                        //}
                        tsk_utils_log_error("Not implemented");
                        break;
                    }

                case tsip_request_type_e.INVITE:
                    {	/* incoming INVITE */
                        if ((o_session = new tsip_session_invite(this.o_stack, tsip_session.prototype.SetInitialMessage(o_message)))) {
                            o_newdialog = new tsip_dialog_invite(o_session, o_message.o_hdr_Call_ID ? o_message.o_hdr_Call_ID.s_value : null);
                        }
                        break;
                    }

                default:
                    {
                        break;
                    }
            } //switch

            // for new dialog, create a new transac and start it later
            if (o_newdialog) {
                o_transac = o_layer_transac.transac_new(false, o_message, o_newdialog);
                this.ao_dialogs.push(o_newdialog); /* add new dialog to the layer */
            }
        }
    }

    if (o_transac) {
        i_ret = o_transac.start(o_message);
    }
    else if (o_message.is_request()) { /* No transaction match for the SIP request */
        var o_layer_transport = this.o_stack.o_layer_transport;
        var o_response = null;

        if (o_layer_transport) {
            if (b_cid_matched) { /* We are receiving our own message. */
                o_response = new tsip_response(482, "Loop Detected (Check your iFCs)", o_message);
                if (o_response && !o_response.o_hdr_To.s_tag) {/* Early dialog? */
                    o_response.o_hdr_To.s_tag = "tag_doubango";
                }
            }
            else {
                switch (o_message.line.request.e_type) {
                    case tsip_request_type_e.OPTIONS: // Hacked to work on Tiscali IMS networks
			o_response = new tsip_response(200, "OK", o_message);
			break;
                    case tsip_request_type_e.INFO:
                        o_response = new tsip_response(405, "Method Not Allowed", o_message);
                        break;
                    default:
                        o_response = new tsip_response(481, "Dialog/Transaction Does Not Exist", o_message);
                        break;
                }
            }
            if (o_response) {
                i_ret = o_layer_transport.send(o_response.o_hdr_firstVia ? o_response.o_hdr_firstVia.s_branch : "no-branch", o_response);
            }
        }
    }

    return i_ret;
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var tsip_header_type_e =
{
    Accept: { i_id: 0, s_name: "Accept" },
    Accept_Contact: { i_id: 1, s_name: "Accept-Contact" },
    Accept_Encoding: { i_id: 2, s_name: "Accept-Encoding" },
    Accept_Language: { i_id: 3, s_name: "Accept-Language" },
    Accept_Resource_Priority: { i_id: 4, s_name: "Accept-Resource-Priority" },
    Alert_Info: { i_id: 5, s_name: "Alert-Info" },
    Allow: { i_id: 6, s_name: "Allow" },
    Allow_Events: { i_id: 7, s_name: "Allow-Events" },
    Authentication_Info: { i_id: 8, s_name: "Authentication-Info" },
    Authorization: { i_id: 9, s_name: "Authorization" },
    Call_ID: { i_id: 10, s_name: "Call-ID" },
    Call_Info: { i_id: 11, s_name: "Call-Info" },
    Contact: { i_id: 12, s_name: "Contact" },
    Content_Disposition: { i_id: 13, s_name: "Content-Disposition" },
    Content_Encoding: { i_id: 14, s_name: "Content-Encoding" },
    Content_Language: { i_id: 15, s_name: "Content-Language" },
    Content_Length: { i_id: 16, s_name: "Content-Length" },
    Content_Type: { i_id: 17, s_name: "Content-Type" },
    CSeq: { i_id: 18, s_name: "CSeq" },
    Date: { i_id: 19, s_name: "Date" },
    Dummy: { i_id: 20, s_name: null },
    Error_Info: { i_id: 21, s_name: "Error-Info" },
    Event: { i_id: 22, s_name: "Event" },
    Expires: { i_id: 23, s_name: "Expires" },
    From: { i_id: 24, s_name: "From" },
    History_Info: { i_id: 25, s_name: "History-Info" },
    Identity: { i_id: 26, s_name: "Identity" },
    Identity_Info: { i_id: 27, s_name: "Identity-Info" },
    In_Reply_To: { i_id: 28, s_name: "In-Reply-To" },
    Join: { i_id: 29, s_name: "Join" },
    Max_Forwards: { i_id: 30, s_name: "Max-Forwards" },
    MIME_Version: { i_id: 31, s_name: "MIME-Version" },
    Min_Expires: { i_id: 32, s_name: "Min-Expires" },
    Min_SE: { i_id: 33, s_name: "Min-SE" },
    Organization: { i_id: 34, s_name: "Organization" },
    Path: { i_id: 35, s_name: "Path" },
    Priority: { i_id: 36, s_name: "Priority" },
    Privacy: { i_id: 37, s_name: "Privacy" },
    Proxy_Authenticate: { i_id: 38, s_name: "Proxy-Authenticate" },
    Proxy_Authorization: { i_id: 39, s_name: "Proxy-Authorization" },
    Proxy_Require: { i_id: 40, s_name: "Proxy-Require" },
    RAck: { i_id: 41, s_name: "RAck" },
    Reason: { i_id: 42, s_name: "Reason" },
    Record_Route: { i_id: 43, s_name: "Record-Route" },
    Refer_Sub: { i_id: 44, s_name: "Refer-Sub" },
    Refer_To: { i_id: 45, s_name: "Refer-To" },
    Referred_By: { i_id: 46, s_name: "Referred-By" },
    Reject_Contact: { i_id: 47, s_name: "Reject-Contact" },
    Replaces: { i_id: 48, s_name: "Replaces" },
    Reply_To: { i_id: 49, s_name: "Reply-To" },
    Request_Disposition: { i_id: 50, s_name: "Request-Disposition" },
    Require: { i_id: 51, s_name: "Require" },
    Resource_Priority: { i_id: 52, s_name: "Resource-Priority" },
    Retry_After: { i_id: 53, s_name: "Retry-After" },
    Route: { i_id: 54, s_name: "Route" },
    RSeq: { i_id: 55, s_name: "RSeq" },
    Security_Client: { i_id: 56, s_name: "Security-Client" },
    Security_Server: { i_id: 57, s_name: "Security-Server" },
    Security_Verify: { i_id: 58, s_name: "Security-Verify" },
    Server: { i_id: 59, s_name: "Server" },
    Service_Route: { i_id: 60, s_name: "Service-Route" },
    Session_Expires: { i_id: 61, s_name: "Session-Expires" },
    SIP_ETag: { i_id: 62, s_name: "SIP-ETag" },
    SIP_If_Match: { i_id: 63, s_name: "SIP-If-Match" },
    Subject: { i_id: 64, s_name: "Subject" },
    Subscription_State: { i_id: 65, s_name: "Subscription-State" },
    Supported: { i_id: 66, s_name: "Supported" },
    Target_Dialog: { i_id: 67, s_name: "Target-Dialog" },
    Timestamp: { i_id: 68, s_name: "Timestamp" },
    To: { i_id: 69, s_name: "To" },
    Unsupported: { i_id: 70, s_name: "Unsupported" },
    User_Agent: { i_id: 71, s_name: "User-Agent" },
    Via: { i_id: 72, s_name: "Via" },
    Warning: { i_id: 73, s_name: "Warning " },
    WWW_Authenticate: { i_id: 74, s_name: "WWW-Authenticate" },
    P_Access_Network_Info: { i_id: 75, s_name: "P-Access-Network-Info" },
    P_Answer_State: { i_id: 76, s_name: "P-Answer-State" },
    P_Asserted_Identity: { i_id: 77, s_name: "P-Asserted-Identity" },
    P_Associated_URI: { i_id: 78, s_name: "P-Associated-URI" },
    P_Called_Party_ID: { i_id: 79, s_name: "P-Called-Party-ID" },
    P_Charging_Function_Addresses: { i_id: 80, s_name: "P-Charging-Function-Addresses" },
    P_Charging_Vector: { i_id: 81, s_name: "P-Charging-Vector" },
    P_DCS_Billing_Info: { i_id: 82, s_name: "P-DCS-Billing-Info" },
    P_DCS_LAES: { i_id: 83, s_name: "P-DCS-LAES" },
    P_DCS_OSPS: { i_id: 84, s_name: "P-DCS-OSPS" },
    P_DCS_Redirect: { i_id: 85, s_name: "P-DCS-Redirect" },
    P_DCS_Trace_Party_ID: { i_id: 86, s_name: "P-DCS-Trace-Party-ID" },
    P_Early_Media: { i_id: 87, s_name: "P-Early-Media" },
    P_Media_Authorization: { i_id: 88, s_name: "P-Media-Authorization" },
    P_Preferred_Identity: { i_id: 89, s_name: "P-Preferred-Identity" },
    P_Profile_Key: { i_id: 90, s_name: "P-Profile-Key" },
    P_User_Database: { i_id: 91, s_name: "P-User-Database" },
    P_Visited_Network_ID: { i_id: 92, s_name: "P-Visited-Network-ID" }
};

function tsip_header(e_type) {
    this.e_type = e_type;
    this.ao_params = new Array();
}

tsip_header.prototype.get_name = function () {
    if (this.e_type.i_id == tsip_header_type_e.Dummy.i_id) {
        return this.s_name;
    }
    return this.e_type.s_name;
}

tsip_header.prototype.get_param_separator = function() {
    switch (this.e_type) {
        case tsip_header_type_e.Authorization:
        case tsip_header_type_e.Proxy_Authorization:
        case tsip_header_type_e.Proxy_Authenticate:
        case tsip_header_type_e.WWW_Authenticate:
            {
                return ',';
            }

        default:
            {
                return ';';
            }
    }
}

tsip_header.prototype.add_param = function(s_name, s_value){
    tsk_params_add(this.ao_params, s_name, s_value);
}

// name: value;params
tsip_header.prototype.tostring_full = function() {
    var c_separator;

    /* Header name */
    var s_str = tsk_string_format("{0}: ", this.get_name());

    /*  Header value (likes calling tsip_header_value_tostring() ) */
    s_str += this;

    /* Parameters */
    for (var i = 0; i < this.ao_params.length; ++i) {
        c_separator = this.get_param_separator();
        s_str += tsk_string_format("{0}{1}", c_separator, tsk_param_tostring(this.ao_params[i]));
    }

    /* CRLF */
    s_str += "\r\n";

    return s_str;
}

tsip_header.prototype.IndexOfByType = function (ao_headers, e_type) {
    if (ao_headers) {
        for (var i = 0; i < ao_headers.length; ++i) {
            if (ao_headers[i].e_type.i_id == e_type.i_id) {
                return i;
            }
        }
    }
    return -1;
}

tsip_header.prototype.IndexOfByName = function(ao_headers, s_name) {
    if (ao_headers && s_name) {
        var s_name_i = s_name.toLowerCase();
        for (var i = 0; i < ao_headers.length; ++i) {
            var s_name_curr = ao_headers[i].get_name();
            if (s_name_curr && s_name_curr.toLowerCase() == s_name_i) {
                return i;
            }
        }
    }
    return -1;
}

tsip_header.prototype.FindByType = function(ao_headers, e_type) {
    if (ao_headers) {
        for (var i = 0; i < ao_headers.length; ++i) {
            if (ao_headers[i].e_type.i_id == e_type.i_id) {
                return ao_headers[i];
            }
        }
    }
    return null;
}

if(!window.__b_release_mode){
    tsip_api_add_js_scripts('head',
        'src/tinySIP/src/headers/tsip_header_Int.js', // 'Content-Length', 'Expires', 'Max-Forwards', 'Min_Expires', 'Min-SE', 'RSeq'
        'src/tinySIP/src/headers/tsip_header_NameAddr.js', // 'From', 'To', 'Refer-To', 'Referred-By'
        // 'src/tinySIP/src/headers/tsip_header_NameAddrArray.js', #include_in<tsip_header_NameAddr.js> // 'P-Asserted-Identity', 'P-Associated-URI', 'P-Preferred-Identity', 'Path', 'Record-Route', 'Route', 'Service-Route'
        'src/tinySIP/src/headers/tsip_header_Str.js', // Call-ID, 'Date', 'Event', 'P-Access-Network-Info', 'P-Charging-Function-Addresses', 'Server', SIP-ETag, SIP-If-Match, User-Agent, Warning, Dummy
        'src/tinySIP/src/headers/tsip_header_StrArray.js', // 'Allow', 'Allow-Events', 'Privacy', 'Require', 'Supported'

        'src/tinySIP/src/headers/tsip_header_Authorization.js',
        'src/tinySIP/src/headers/tsip_header_Contact.js',
        'src/tinySIP/src/headers/tsip_header_Content_Type.js',
        'src/tinySIP/src/headers/tsip_header_CSeq.js',
        'src/tinySIP/src/headers/tsip_header_RAck.js',
        'src/tinySIP/src/headers/tsip_header_Refer_Sub.js',
        'src/tinySIP/src/headers/tsip_header_Session_Expires.js',
        'src/tinySIP/src/headers/tsip_header_Subscription_State.js',
        'src/tinySIP/src/headers/tsip_header_Via.js',
        'src/tinySIP/src/headers/tsip_header_WWW_Authenticate.js'
    );
}

/* line 1 "./ragel/tsip_parser_header_Int.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

var TSIP_HEADER_MAX_FORWARDS_DEFAULT = 70;

// Parse headers: 'Content-Length', 'Expires', 'Max-Forwards', 'Min-Expires', 'Min-SE', 'RSeq'
tsip_header_Int.prototype = Object.create(tsip_header.prototype);
tsip_header_Content_Length.prototype = Object.create(tsip_header_Int.prototype);
tsip_header_Expires.prototype = Object.create(tsip_header_Int.prototype);
tsip_header_Max_Forwards.prototype = Object.create(tsip_header_Int.prototype);
tsip_header_Min_Expires.prototype = Object.create(tsip_header_Int.prototype);
tsip_header_Min_SE.prototype = Object.create(tsip_header_Int.prototype);
tsip_header_RSeq.prototype = Object.create(tsip_header_Int.prototype);


/* line 62 "./ragel/tsip_parser_header_Int.jrl" */



/* line 26 "./src/headers/tsip_header_Int.js" */
_tsip_machine_parser_header_Int_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 1, 8, 1, 9
];

_tsip_machine_parser_header_Int_key_offsets = [
	0, 0, 10, 12, 14, 16, 18, 20, 
	22, 23, 25, 27, 29, 31, 33, 35, 
	38, 41, 46, 47, 49, 53, 60, 65, 
	66, 68, 72, 89, 90, 92, 108, 126, 
	132, 133, 135, 140, 159, 160, 162, 181, 
	182, 184, 187, 195, 196, 198, 203, 204, 
	210, 227, 234, 242, 250, 258, 260, 267, 
	276, 278, 281, 283, 286, 288, 291, 294, 
	295, 298, 299, 302, 303, 312, 321, 329, 
	337, 345, 353, 355, 361, 370, 379, 388, 
	390, 393, 396, 397, 398, 400, 402, 404, 
	406, 408, 410, 413, 417, 419, 420, 422, 
	424, 426, 428, 430, 432, 434, 436, 439, 
	441, 442, 446, 448, 450, 452, 454, 456, 
	458, 461, 463, 466, 468, 470, 472, 475
];

_tsip_machine_parser_header_Int_trans_keys = [
	67, 69, 76, 77, 82, 99, 101, 108, 
	109, 114, 79, 111, 78, 110, 84, 116, 
	69, 101, 78, 110, 84, 116, 45, 76, 
	108, 69, 101, 78, 110, 71, 103, 84, 
	116, 72, 104, 9, 32, 58, 9, 32, 
	58, 9, 13, 32, 48, 57, 10, 9, 
	32, 9, 32, 48, 57, 9, 13, 32, 
	44, 59, 48, 57, 9, 13, 32, 44, 
	59, 10, 9, 32, 9, 32, 44, 59, 
	9, 13, 32, 33, 37, 39, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 10, 9, 32, 9, 32, 33, 37, 
	39, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 44, 59, 61, 126, 42, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 44, 59, 61, 10, 9, 32, 9, 
	32, 44, 59, 61, 9, 13, 32, 33, 
	34, 37, 39, 91, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 10, 
	9, 32, 9, 13, 32, 33, 34, 37, 
	39, 91, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 10, 9, 32, 
	9, 32, 34, 9, 13, 34, 92, 32, 
	126, 128, 255, 10, 9, 32, 9, 13, 
	32, 44, 59, 10, 0, 9, 11, 12, 
	14, 127, 9, 13, 32, 33, 37, 39, 
	44, 59, 126, 42, 46, 48, 57, 65, 
	90, 95, 122, 58, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 58, 48, 57, 65, 
	70, 97, 102, 46, 58, 93, 48, 57, 
	65, 70, 97, 102, 48, 57, 46, 48, 
	57, 48, 57, 46, 48, 57, 48, 57, 
	93, 48, 57, 93, 48, 57, 93, 46, 
	48, 57, 46, 46, 48, 57, 46, 46, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 46, 58, 93, 48, 57, 65, 70, 
	97, 102, 46, 58, 93, 48, 57, 65, 
	70, 97, 102, 46, 58, 93, 48, 57, 
	65, 70, 97, 102, 48, 57, 46, 48, 
	57, 46, 48, 57, 46, 58, 88, 120, 
	80, 112, 73, 105, 82, 114, 69, 101, 
	83, 115, 9, 32, 58, 65, 73, 97, 
	105, 88, 120, 45, 70, 102, 79, 111, 
	82, 114, 87, 119, 65, 97, 82, 114, 
	68, 100, 83, 115, 9, 32, 58, 78, 
	110, 45, 69, 83, 101, 115, 88, 120, 
	80, 112, 73, 105, 82, 114, 69, 101, 
	83, 115, 9, 32, 58, 69, 101, 9, 
	32, 58, 83, 115, 69, 101, 81, 113, 
	9, 32, 58, 0
];

_tsip_machine_parser_header_Int_single_lengths = [
	0, 10, 2, 2, 2, 2, 2, 2, 
	1, 2, 2, 2, 2, 2, 2, 3, 
	3, 3, 1, 2, 2, 5, 5, 1, 
	2, 4, 7, 1, 2, 6, 10, 6, 
	1, 2, 5, 9, 1, 2, 9, 1, 
	2, 3, 4, 1, 2, 5, 1, 0, 
	9, 1, 2, 2, 2, 2, 1, 3, 
	0, 1, 0, 1, 0, 1, 1, 1, 
	1, 1, 1, 1, 3, 3, 2, 2, 
	2, 2, 2, 0, 3, 3, 3, 0, 
	1, 1, 1, 1, 2, 2, 2, 2, 
	2, 2, 3, 4, 2, 1, 2, 2, 
	2, 2, 2, 2, 2, 2, 3, 2, 
	1, 4, 2, 2, 2, 2, 2, 2, 
	3, 2, 3, 2, 2, 2, 3, 0
];

_tsip_machine_parser_header_Int_range_lengths = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 1, 1, 0, 0, 
	0, 0, 5, 0, 0, 5, 4, 0, 
	0, 0, 0, 5, 0, 0, 5, 0, 
	0, 0, 2, 0, 0, 0, 0, 3, 
	4, 3, 3, 3, 3, 0, 3, 3, 
	1, 1, 1, 1, 1, 1, 1, 0, 
	1, 0, 1, 0, 3, 3, 3, 3, 
	3, 3, 0, 3, 3, 3, 3, 1, 
	1, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0
];

_tsip_machine_parser_header_Int_index_offsets = [
	0, 0, 11, 14, 17, 20, 23, 26, 
	29, 31, 34, 37, 40, 43, 46, 49, 
	53, 57, 62, 64, 67, 71, 78, 84, 
	86, 89, 94, 107, 109, 112, 124, 139, 
	146, 148, 151, 157, 172, 174, 177, 192, 
	194, 197, 201, 208, 210, 213, 219, 221, 
	225, 239, 244, 250, 256, 262, 265, 270, 
	277, 279, 282, 284, 287, 289, 292, 295, 
	297, 300, 302, 305, 307, 314, 321, 327, 
	333, 339, 345, 348, 352, 359, 366, 373, 
	375, 378, 381, 383, 385, 388, 391, 394, 
	397, 400, 403, 407, 412, 415, 417, 420, 
	423, 426, 429, 432, 435, 438, 441, 445, 
	448, 450, 455, 458, 461, 464, 467, 470, 
	473, 477, 480, 484, 487, 490, 493, 497
];

_tsip_machine_parser_header_Int_indicies = [
	0, 2, 3, 4, 5, 0, 2, 3, 
	4, 5, 1, 6, 6, 1, 7, 7, 
	1, 8, 8, 1, 9, 9, 1, 10, 
	10, 1, 11, 11, 1, 12, 1, 13, 
	13, 1, 14, 14, 1, 15, 15, 1, 
	16, 16, 1, 17, 17, 1, 3, 3, 
	1, 18, 18, 19, 1, 20, 20, 21, 
	1, 21, 22, 21, 23, 1, 24, 1, 
	25, 25, 1, 25, 25, 23, 1, 26, 
	27, 26, 28, 28, 29, 1, 30, 31, 
	30, 32, 32, 1, 33, 1, 34, 34, 
	1, 34, 34, 32, 32, 1, 32, 35, 
	32, 36, 36, 36, 36, 36, 36, 36, 
	36, 36, 1, 37, 1, 38, 38, 1, 
	38, 38, 36, 36, 36, 36, 36, 36, 
	36, 36, 36, 1, 39, 40, 39, 41, 
	41, 41, 42, 42, 43, 41, 41, 41, 
	41, 41, 1, 44, 45, 44, 32, 32, 
	43, 1, 46, 1, 47, 47, 1, 47, 
	47, 32, 32, 43, 1, 43, 48, 43, 
	49, 50, 49, 49, 51, 49, 49, 49, 
	49, 49, 49, 1, 52, 1, 53, 53, 
	1, 53, 54, 53, 49, 50, 49, 49, 
	51, 49, 49, 49, 49, 49, 49, 1, 
	55, 1, 56, 56, 1, 56, 56, 50, 
	1, 50, 57, 58, 59, 50, 50, 1, 
	60, 1, 50, 50, 1, 61, 40, 61, 
	42, 42, 1, 62, 1, 50, 50, 50, 
	1, 61, 40, 61, 49, 49, 49, 42, 
	42, 49, 49, 49, 49, 49, 1, 64, 
	63, 63, 63, 1, 66, 58, 65, 65, 
	65, 1, 66, 58, 67, 67, 67, 1, 
	66, 58, 68, 68, 68, 1, 66, 58, 
	1, 70, 69, 63, 63, 1, 71, 66, 
	58, 72, 65, 65, 1, 73, 1, 74, 
	75, 1, 76, 1, 77, 78, 1, 79, 
	1, 58, 80, 1, 58, 81, 1, 58, 
	1, 77, 82, 1, 77, 1, 74, 83, 
	1, 74, 1, 71, 66, 58, 84, 67, 
	67, 1, 71, 66, 58, 68, 68, 68, 
	1, 86, 58, 85, 85, 85, 1, 88, 
	58, 87, 87, 87, 1, 88, 58, 89, 
	89, 89, 1, 88, 58, 90, 90, 90, 
	1, 88, 58, 1, 91, 85, 85, 1, 
	71, 88, 58, 92, 87, 87, 1, 71, 
	88, 58, 93, 89, 89, 1, 71, 88, 
	58, 90, 90, 90, 1, 94, 1, 71, 
	95, 1, 71, 96, 1, 71, 1, 70, 
	1, 97, 97, 1, 98, 98, 1, 99, 
	99, 1, 100, 100, 1, 101, 101, 1, 
	102, 102, 1, 103, 103, 104, 1, 105, 
	106, 105, 106, 1, 107, 107, 1, 108, 
	1, 109, 109, 1, 110, 110, 1, 111, 
	111, 1, 112, 112, 1, 113, 113, 1, 
	114, 114, 1, 115, 115, 1, 116, 116, 
	1, 117, 117, 118, 1, 119, 119, 1, 
	120, 1, 121, 122, 121, 122, 1, 123, 
	123, 1, 124, 124, 1, 125, 125, 1, 
	126, 126, 1, 127, 127, 1, 128, 128, 
	1, 129, 129, 130, 1, 131, 131, 1, 
	132, 132, 133, 1, 134, 134, 1, 135, 
	135, 1, 136, 136, 1, 137, 137, 138, 
	1, 1, 0
];

_tsip_machine_parser_header_Int_trans_targs = [
	2, 0, 84, 15, 91, 115, 3, 4, 
	5, 6, 7, 8, 9, 10, 11, 12, 
	13, 14, 16, 17, 16, 17, 18, 21, 
	19, 20, 22, 46, 26, 21, 22, 23, 
	26, 24, 25, 27, 30, 28, 29, 31, 
	46, 30, 26, 35, 31, 32, 33, 34, 
	36, 48, 42, 49, 37, 38, 39, 40, 
	41, 43, 45, 47, 44, 22, 119, 50, 
	83, 51, 54, 52, 53, 55, 70, 56, 
	68, 57, 58, 66, 59, 60, 64, 61, 
	62, 63, 65, 67, 69, 71, 79, 72, 
	75, 73, 74, 76, 77, 78, 80, 81, 
	82, 85, 86, 87, 88, 89, 90, 16, 
	17, 92, 103, 93, 94, 95, 96, 97, 
	98, 99, 100, 101, 102, 16, 17, 104, 
	105, 106, 113, 107, 108, 109, 110, 111, 
	112, 16, 17, 114, 16, 17, 116, 117, 
	118, 16, 17
];

_tsip_machine_parser_header_Int_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 7, 7, 0, 0, 0, 1, 
	0, 0, 3, 3, 3, 0, 0, 0, 
	0, 0, 0, 0, 1, 0, 0, 5, 
	5, 0, 5, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 5, 19, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 9, 
	9, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 11, 11, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 13, 13, 0, 15, 15, 0, 0, 
	0, 17, 17
];

tsip_machine_parser_header_Int_start = 1;
tsip_machine_parser_header_Int_first_final = 119;
tsip_machine_parser_header_Int_error = 0;

tsip_machine_parser_header_Int_en_main = 1;


/* line 65 "./ragel/tsip_parser_header_Int.jrl" */

function tsip_header_Int(e_type, i_value){
    tsip_header.call(this, e_type);
    this.i_value = i_value;
}

tsip_header_Int.prototype.toString = function(){
    return typeof this.i_value == "undefined" ? null : this.i_value.toString();
};

tsip_header_Int.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var o_hdr = null;
	
	
/* line 304 "./src/headers/tsip_header_Int.js" */
{
	 cs = tsip_machine_parser_header_Int_start;
} /* JSCodeGen::writeInit */

/* line 85 "./ragel/tsip_parser_header_Int.jrl" */
	
/* line 311 "./src/headers/tsip_header_Int.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_Int_key_offsets[cs];
	_trans = _tsip_machine_parser_header_Int_index_offsets[cs];
	_klen = _tsip_machine_parser_header_Int_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_Int_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_Int_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_Int_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_Int_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_Int_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_Int_indicies[_trans];
	cs = _tsip_machine_parser_header_Int_trans_targs[_trans];
	if (_tsip_machine_parser_header_Int_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_Int_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_Int_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_Int_actions[_acts - 1]) {
case 0:
/* line 24 "./ragel/tsip_parser_header_Int.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 28 "./ragel/tsip_parser_header_Int.jrl" */

		if(o_hdr){
			o_hdr.i_value = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
		}
			break;
case 2:
/* line 34 "./ragel/tsip_parser_header_Int.jrl" */

		if(o_hdr){
			tsk_ragel_add_param(s_str, p, i_tag_start, o_hdr.ao_params);
		}
			break;
case 3:
/* line 40 "./ragel/tsip_parser_header_Int.jrl" */
 o_hdr = new tsip_header_Content_Length(); 		break;
case 4:
/* line 41 "./ragel/tsip_parser_header_Int.jrl" */
 o_hdr = new tsip_header_Expires(); 		break;
case 5:
/* line 42 "./ragel/tsip_parser_header_Int.jrl" */
 o_hdr = new tsip_header_Max_Forwards(); 		break;
case 6:
/* line 43 "./ragel/tsip_parser_header_Int.jrl" */
 o_hdr = new tsip_header_Min_Expires(); 		break;
case 7:
/* line 44 "./ragel/tsip_parser_header_Int.jrl" */
 o_hdr = new tsip_header_Min_SE(); 		break;
case 8:
/* line 45 "./ragel/tsip_parser_header_Int.jrl" */
 o_hdr = new tsip_header_RSeq(); 		break;
case 9:
/* line 57 "./ragel/tsip_parser_header_Int.jrl" */
 		break;
/* line 435 "./src/headers/tsip_header_Int.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 86 "./ragel/tsip_parser_header_Int.jrl" */
	
	if( cs < 
/* line 465 "./src/headers/tsip_header_Int.js" */
119
/* line 87 "./ragel/tsip_parser_header_Int.jrl" */
 ){
		tsk_utils_log_error("Failed to parse header: " + s_str);
		return null;
	}
	
	return o_hdr;
}

function tsip_header_Content_Length(i_value){ tsip_header_Int.call(this, tsip_header_type_e.Content_Length, i_value); }
function tsip_header_Expires(i_value){ tsip_header_Int.call(this, tsip_header_type_e.Expires, i_value); }
function tsip_header_Max_Forwards(i_value){ tsip_header_Int.call(this, tsip_header_type_e.Max_Forwards, i_value); }
function tsip_header_Min_Expires(i_value){ tsip_header_Int.call(this, tsip_header_type_e.Min_Expires, i_value); }
function tsip_header_Min_SE(i_value){ tsip_header_Int.call(this, tsip_header_type_e.Min_SE, i_value); }
function tsip_header_RSeq(i_value){ tsip_header_Int.call(this, tsip_header_type_e.RSeq, i_value); }



/* line 1 "./ragel/tsip_parser_header_NameAddr.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

// Parse headers: 'From', 'To', 'Refer-To'
tsip_header_NameAddr.prototype = Object.create(tsip_header.prototype);
tsip_header_NameAddr.prototype.s_display_name = null;
tsip_header_NameAddr.prototype.o_uri = null;
tsip_header_NameAddr.prototype.s_tag = null;

tsip_header_From.prototype = Object.create(tsip_header_NameAddr.prototype);
tsip_header_To.prototype = Object.create(tsip_header_NameAddr.prototype);
tsip_header_Refer_To.prototype = Object.create(tsip_header_NameAddr.prototype);
tsip_header_Referred_By.prototype = Object.create(tsip_header_NameAddr.prototype);


/* line 78 "./ragel/tsip_parser_header_NameAddr.jrl" */




/* line 27 "./src/headers/tsip_header_NameAddr.js" */
_tsip_machine_parser_header_NameAddr_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 1, 8, 1, 9
];

_tsip_machine_parser_header_NameAddr_key_offsets = [
	0, 0, 8, 11, 14, 35, 36, 38, 
	59, 60, 62, 65, 69, 81, 84, 86, 
	89, 93, 97, 98, 100, 103, 122, 123, 
	125, 143, 162, 167, 168, 170, 174, 193, 
	194, 196, 215, 216, 218, 221, 229, 230, 
	232, 236, 237, 243, 261, 268, 276, 284, 
	292, 294, 301, 310, 312, 315, 317, 320, 
	322, 325, 328, 329, 332, 333, 336, 337, 
	346, 355, 363, 371, 379, 387, 389, 395, 
	404, 413, 422, 424, 427, 430, 431, 432, 
	453, 474, 493, 498, 499, 501, 505, 524, 
	525, 527, 546, 564, 581, 599, 603, 604, 
	606, 614, 615, 617, 621, 627, 647, 666, 
	671, 673, 679, 684, 686, 688, 691, 696, 
	698, 700, 702, 705, 707, 709, 712, 714, 
	716, 717, 719, 721, 726, 729
];

_tsip_machine_parser_header_NameAddr_trans_keys = [
	66, 70, 82, 84, 98, 102, 114, 116, 
	9, 32, 58, 9, 32, 58, 9, 13, 
	32, 33, 34, 37, 39, 60, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	96, 97, 122, 10, 9, 32, 9, 13, 
	32, 33, 34, 37, 39, 60, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	96, 97, 122, 10, 9, 32, 9, 32, 
	60, 65, 90, 97, 122, 9, 32, 43, 
	58, 45, 46, 48, 57, 65, 90, 97, 
	122, 9, 32, 58, 0, 65535, 62, 0, 
	65535, 9, 13, 32, 59, 9, 13, 32, 
	59, 10, 9, 32, 9, 32, 59, 9, 
	13, 32, 33, 37, 39, 84, 116, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 10, 9, 32, 9, 32, 33, 
	37, 39, 84, 116, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 59, 61, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 59, 61, 10, 
	9, 32, 9, 32, 59, 61, 9, 13, 
	32, 33, 34, 37, 39, 91, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 10, 9, 32, 9, 13, 32, 33, 
	34, 37, 39, 91, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 10, 
	9, 32, 9, 32, 34, 9, 13, 34, 
	92, 32, 126, 128, 255, 10, 9, 32, 
	9, 13, 32, 59, 10, 0, 9, 11, 
	12, 14, 127, 9, 13, 32, 33, 37, 
	39, 59, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 58, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 58, 48, 
	57, 65, 70, 97, 102, 46, 58, 93, 
	48, 57, 65, 70, 97, 102, 48, 57, 
	46, 48, 57, 48, 57, 46, 48, 57, 
	48, 57, 93, 48, 57, 93, 48, 57, 
	93, 46, 48, 57, 46, 46, 48, 57, 
	46, 46, 58, 93, 48, 57, 65, 70, 
	97, 102, 46, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 46, 58, 93, 48, 57, 
	65, 70, 97, 102, 46, 58, 93, 48, 
	57, 65, 70, 97, 102, 46, 58, 93, 
	48, 57, 65, 70, 97, 102, 48, 57, 
	46, 48, 57, 46, 48, 57, 46, 58, 
	9, 13, 32, 33, 37, 39, 59, 61, 
	65, 97, 126, 42, 43, 45, 46, 48, 
	57, 66, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 59, 61, 71, 103, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	59, 61, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	59, 61, 10, 9, 32, 9, 32, 59, 
	61, 9, 13, 32, 33, 34, 37, 39, 
	91, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 10, 9, 32, 9, 
	13, 32, 33, 34, 37, 39, 91, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	59, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 60, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 60, 10, 9, 32, 9, 13, 
	34, 92, 32, 126, 128, 255, 10, 9, 
	32, 9, 13, 32, 60, 0, 9, 11, 
	12, 14, 127, 9, 13, 32, 33, 37, 
	39, 42, 43, 58, 126, 45, 46, 48, 
	57, 65, 90, 95, 96, 97, 122, 9, 
	13, 32, 33, 37, 39, 58, 60, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 58, 60, 0, 
	65535, 9, 13, 32, 59, 0, 65535, 9, 
	32, 58, 82, 114, 79, 111, 77, 109, 
	9, 32, 58, 9, 32, 58, 69, 101, 
	70, 102, 69, 101, 82, 114, 45, 82, 
	114, 84, 116, 79, 111, 9, 32, 58, 
	69, 101, 68, 100, 45, 66, 98, 89, 
	121, 9, 32, 58, 79, 111, 9, 32, 
	58, 0
];

_tsip_machine_parser_header_NameAddr_single_lengths = [
	0, 8, 3, 3, 9, 1, 2, 9, 
	1, 2, 3, 0, 4, 3, 0, 1, 
	4, 4, 1, 2, 3, 9, 1, 2, 
	8, 9, 5, 1, 2, 4, 9, 1, 
	2, 9, 1, 2, 3, 4, 1, 2, 
	4, 1, 0, 8, 1, 2, 2, 2, 
	2, 1, 3, 0, 1, 0, 1, 0, 
	1, 1, 1, 1, 1, 1, 1, 3, 
	3, 2, 2, 2, 2, 2, 0, 3, 
	3, 3, 0, 1, 1, 1, 1, 11, 
	11, 9, 5, 1, 2, 4, 9, 1, 
	2, 9, 8, 7, 8, 4, 1, 2, 
	4, 1, 2, 4, 0, 10, 9, 5, 
	0, 4, 5, 2, 2, 3, 5, 2, 
	2, 2, 3, 2, 2, 3, 2, 2, 
	1, 2, 2, 5, 3, 0
];

_tsip_machine_parser_header_NameAddr_range_lengths = [
	0, 0, 0, 0, 6, 0, 0, 6, 
	0, 0, 0, 2, 4, 0, 1, 1, 
	0, 0, 0, 0, 0, 5, 0, 0, 
	5, 5, 0, 0, 0, 0, 5, 0, 
	0, 5, 0, 0, 0, 2, 0, 0, 
	0, 0, 3, 5, 3, 3, 3, 3, 
	0, 3, 3, 1, 1, 1, 1, 1, 
	1, 1, 0, 1, 0, 1, 0, 3, 
	3, 3, 3, 3, 3, 0, 3, 3, 
	3, 3, 1, 1, 1, 0, 0, 5, 
	5, 5, 0, 0, 0, 0, 5, 0, 
	0, 5, 5, 5, 5, 0, 0, 0, 
	2, 0, 0, 0, 3, 5, 5, 0, 
	1, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0
];

_tsip_machine_parser_header_NameAddr_index_offsets = [
	0, 0, 9, 13, 17, 33, 35, 38, 
	54, 56, 59, 63, 66, 75, 79, 81, 
	84, 89, 94, 96, 99, 103, 118, 120, 
	123, 137, 152, 158, 160, 163, 168, 183, 
	185, 188, 203, 205, 208, 212, 219, 221, 
	224, 229, 231, 235, 249, 254, 260, 266, 
	272, 275, 280, 287, 289, 292, 294, 297, 
	299, 302, 305, 307, 310, 312, 315, 317, 
	324, 331, 337, 343, 349, 355, 358, 362, 
	369, 376, 383, 385, 388, 391, 393, 395, 
	412, 429, 444, 450, 452, 455, 460, 475, 
	477, 480, 495, 509, 522, 536, 541, 543, 
	546, 553, 555, 558, 563, 567, 583, 598, 
	604, 606, 612, 618, 621, 624, 628, 634, 
	637, 640, 643, 647, 650, 653, 657, 660, 
	663, 665, 668, 671, 677, 681
];

_tsip_machine_parser_header_NameAddr_indicies = [
	0, 2, 3, 4, 0, 2, 3, 4, 
	1, 5, 5, 6, 1, 7, 7, 8, 
	1, 8, 9, 8, 10, 11, 10, 10, 
	12, 10, 10, 10, 10, 13, 10, 13, 
	1, 14, 1, 15, 15, 1, 15, 16, 
	15, 10, 11, 10, 10, 12, 10, 10, 
	10, 10, 13, 10, 13, 1, 17, 1, 
	18, 18, 1, 18, 18, 12, 1, 19, 
	19, 1, 20, 20, 21, 22, 21, 21, 
	21, 21, 1, 20, 20, 22, 1, 23, 
	1, 24, 23, 1, 25, 26, 25, 27, 
	1, 25, 28, 25, 27, 1, 29, 1, 
	30, 30, 1, 30, 30, 27, 1, 27, 
	31, 27, 32, 32, 32, 33, 33, 32, 
	32, 32, 32, 32, 32, 1, 34, 1, 
	35, 35, 1, 35, 35, 32, 32, 32, 
	33, 33, 32, 32, 32, 32, 32, 32, 
	1, 36, 37, 36, 38, 38, 38, 39, 
	40, 38, 38, 38, 38, 38, 38, 1, 
	41, 42, 41, 27, 40, 1, 43, 1, 
	44, 44, 1, 44, 44, 27, 40, 1, 
	40, 45, 40, 46, 47, 46, 46, 48, 
	46, 46, 46, 46, 46, 46, 1, 49, 
	1, 50, 50, 1, 50, 51, 50, 46, 
	47, 46, 46, 48, 46, 46, 46, 46, 
	46, 46, 1, 52, 1, 53, 53, 1, 
	53, 53, 47, 1, 47, 54, 55, 56, 
	47, 47, 1, 57, 1, 47, 47, 1, 
	58, 37, 58, 39, 1, 59, 1, 47, 
	47, 47, 1, 58, 37, 58, 46, 46, 
	46, 39, 46, 46, 46, 46, 46, 46, 
	1, 61, 60, 60, 60, 1, 63, 55, 
	62, 62, 62, 1, 63, 55, 64, 64, 
	64, 1, 63, 55, 65, 65, 65, 1, 
	63, 55, 1, 67, 66, 60, 60, 1, 
	68, 63, 55, 69, 62, 62, 1, 70, 
	1, 71, 72, 1, 73, 1, 74, 75, 
	1, 76, 1, 55, 77, 1, 55, 78, 
	1, 55, 1, 74, 79, 1, 74, 1, 
	71, 80, 1, 71, 1, 68, 63, 55, 
	81, 64, 64, 1, 68, 63, 55, 65, 
	65, 65, 1, 83, 55, 82, 82, 82, 
	1, 85, 55, 84, 84, 84, 1, 85, 
	55, 86, 86, 86, 1, 85, 55, 87, 
	87, 87, 1, 85, 55, 1, 88, 82, 
	82, 1, 68, 85, 55, 89, 84, 84, 
	1, 68, 85, 55, 90, 86, 86, 1, 
	68, 85, 55, 87, 87, 87, 1, 91, 
	1, 68, 92, 1, 68, 93, 1, 68, 
	1, 67, 1, 36, 37, 36, 38, 38, 
	38, 39, 40, 94, 94, 38, 38, 38, 
	38, 38, 38, 1, 36, 37, 36, 38, 
	38, 38, 39, 40, 95, 95, 38, 38, 
	38, 38, 38, 38, 1, 96, 37, 96, 
	38, 38, 38, 39, 97, 38, 38, 38, 
	38, 38, 38, 1, 98, 99, 98, 27, 
	97, 1, 100, 1, 101, 101, 1, 101, 
	101, 27, 97, 1, 97, 102, 97, 103, 
	47, 103, 103, 48, 103, 103, 103, 103, 
	103, 103, 1, 104, 1, 105, 105, 1, 
	105, 51, 105, 103, 47, 103, 103, 48, 
	103, 103, 103, 103, 103, 103, 1, 106, 
	107, 106, 108, 108, 108, 109, 108, 108, 
	108, 108, 108, 108, 1, 110, 111, 110, 
	112, 112, 112, 112, 112, 112, 112, 112, 
	112, 1, 113, 114, 113, 112, 112, 112, 
	115, 112, 112, 112, 112, 112, 112, 1, 
	116, 16, 116, 12, 1, 117, 1, 110, 
	110, 1, 118, 119, 120, 121, 118, 118, 
	1, 122, 1, 118, 118, 1, 113, 114, 
	113, 115, 1, 118, 118, 118, 1, 123, 
	111, 123, 112, 112, 112, 112, 124, 125, 
	112, 124, 124, 124, 112, 124, 1, 126, 
	114, 126, 112, 112, 112, 125, 115, 112, 
	112, 112, 112, 112, 112, 1, 127, 16, 
	127, 125, 12, 1, 128, 1, 129, 130, 
	129, 131, 128, 1, 132, 132, 133, 134, 
	134, 1, 135, 135, 1, 136, 136, 1, 
	132, 132, 133, 1, 137, 137, 138, 139, 
	139, 1, 140, 140, 1, 141, 141, 1, 
	142, 142, 1, 143, 144, 144, 1, 145, 
	145, 1, 146, 146, 1, 137, 137, 138, 
	1, 147, 147, 1, 148, 148, 1, 149, 
	1, 150, 150, 1, 0, 0, 1, 151, 
	151, 152, 153, 153, 1, 151, 151, 152, 
	1, 1, 0
];

_tsip_machine_parser_header_NameAddr_trans_targs = [
	2, 0, 106, 110, 123, 3, 4, 3, 
	4, 5, 91, 96, 11, 101, 6, 7, 
	8, 9, 10, 12, 13, 12, 14, 15, 
	16, 17, 41, 21, 18, 19, 20, 22, 
	25, 79, 23, 24, 26, 41, 25, 21, 
	30, 26, 27, 28, 29, 31, 43, 37, 
	44, 32, 33, 34, 35, 36, 38, 40, 
	42, 39, 17, 125, 45, 78, 46, 49, 
	47, 48, 50, 65, 51, 63, 52, 53, 
	61, 54, 55, 59, 56, 57, 58, 60, 
	62, 64, 66, 74, 67, 70, 68, 69, 
	71, 72, 73, 75, 76, 77, 80, 81, 
	82, 86, 82, 83, 84, 85, 87, 90, 
	88, 89, 17, 41, 90, 21, 92, 94, 
	91, 93, 8, 11, 93, 95, 96, 97, 
	99, 100, 98, 102, 101, 104, 103, 103, 
	105, 17, 41, 21, 3, 4, 107, 108, 
	109, 3, 4, 111, 112, 113, 114, 115, 
	118, 116, 117, 119, 120, 121, 122, 3, 
	4, 124
];

_tsip_machine_parser_header_NameAddr_trans_actions = [
	0, 0, 0, 0, 0, 17, 17, 0, 
	0, 0, 1, 1, 0, 1, 0, 0, 
	0, 0, 0, 1, 0, 0, 0, 0, 
	3, 0, 0, 0, 0, 0, 0, 0, 
	1, 1, 0, 0, 9, 9, 0, 9, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 9, 19, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	9, 0, 0, 0, 0, 0, 0, 1, 
	0, 0, 7, 7, 0, 7, 0, 0, 
	0, 5, 5, 5, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 5, 0, 
	0, 3, 3, 3, 11, 11, 0, 0, 
	0, 15, 15, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 13, 
	13, 0
];

tsip_machine_parser_header_NameAddr_start = 1;
tsip_machine_parser_header_NameAddr_first_final = 125;
tsip_machine_parser_header_NameAddr_error = 0;

tsip_machine_parser_header_NameAddr_en_main = 1;


/* line 82 "./ragel/tsip_parser_header_NameAddr.jrl" */

function tsip_header_NameAddr(e_type, o_uri, s_tag){
	tsip_header.call(this, e_type);
    this.s_display_name = o_uri ? o_uri.s_display_name : null;
	this.o_uri = o_uri;
	this.s_tag = s_tag;
}

tsip_header_NameAddr.prototype.toString = function(){
    var s_str = tsip_uri_tostring(this.o_uri, true, true);
    if(s_str && this.s_tag){
        s_str += tsk_string_format(";tag={0}", this.s_tag);
    }
    return s_str;
}

tsip_header_NameAddr.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var o_hdr;
	
	
/* line 374 "./src/headers/tsip_header_NameAddr.js" */
{
	 cs = tsip_machine_parser_header_NameAddr_start;
} /* JSCodeGen::writeInit */

/* line 108 "./ragel/tsip_parser_header_NameAddr.jrl" */
	
/* line 381 "./src/headers/tsip_header_NameAddr.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_NameAddr_key_offsets[cs];
	_trans = _tsip_machine_parser_header_NameAddr_index_offsets[cs];
	_klen = _tsip_machine_parser_header_NameAddr_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_NameAddr_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_NameAddr_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_NameAddr_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_NameAddr_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_NameAddr_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_NameAddr_indicies[_trans];
	cs = _tsip_machine_parser_header_NameAddr_trans_targs[_trans];
	if (_tsip_machine_parser_header_NameAddr_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_NameAddr_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_NameAddr_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_NameAddr_actions[_acts - 1]) {
case 0:
/* line 24 "./ragel/tsip_parser_header_NameAddr.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 28 "./ragel/tsip_parser_header_NameAddr.jrl" */

	    if(o_hdr && !o_hdr.o_uri){
		    var s_uri = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			if((o_hdr.o_uri = tsip_uri.prototype.Parse(s_uri)) && o_hdr.s_display_name){
				o_hdr.o_uri.s_display_name = tsk_strdup(o_hdr.s_display_name);
			}
		}
			break;
case 2:
/* line 37 "./ragel/tsip_parser_header_NameAddr.jrl" */

		if(o_hdr){
			o_hdr.s_display_name = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			o_hdr.s_display_name = tsk_string_unquote_2(o_hdr.s_display_name);
		}
			break;
case 3:
/* line 44 "./ragel/tsip_parser_header_NameAddr.jrl" */

		if(o_hdr){
			o_hdr.s_tag = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
		}
			break;
case 4:
/* line 50 "./ragel/tsip_parser_header_NameAddr.jrl" */

	    tsk_ragel_add_param(s_str, p, i_tag_start, o_hdr.ao_params);
			break;
case 5:
/* line 54 "./ragel/tsip_parser_header_NameAddr.jrl" */
 o_hdr = new tsip_header_From(); 		break;
case 6:
/* line 55 "./ragel/tsip_parser_header_NameAddr.jrl" */
 o_hdr = new tsip_header_To(); 		break;
case 7:
/* line 56 "./ragel/tsip_parser_header_NameAddr.jrl" */
 o_hdr = new tsip_header_Refer_To(); 		break;
case 8:
/* line 57 "./ragel/tsip_parser_header_NameAddr.jrl" */
 o_hdr = new tsip_header_Referred_By(); 		break;
case 9:
/* line 59 "./ragel/tsip_parser_header_NameAddr.jrl" */
 		break;
/* line 515 "./src/headers/tsip_header_NameAddr.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 109 "./ragel/tsip_parser_header_NameAddr.jrl" */
	
	if( cs < 
/* line 545 "./src/headers/tsip_header_NameAddr.js" */
125
/* line 110 "./ragel/tsip_parser_header_NameAddr.jrl" */
 ){
		tsk_utils_log_error("Failed to parse header: " + s_str);
		return null;
	}
	
	return o_hdr;
}

function tsip_header_From(o_uri, s_tag){ tsip_header_NameAddr.call(this, tsip_header_type_e.From, o_uri, s_tag); }
function tsip_header_To(o_uri, s_tag){ tsip_header_NameAddr.call(this, tsip_header_type_e.To, o_uri, s_tag); }
function tsip_header_Refer_To(o_uri){ tsip_header_NameAddr.call(this, tsip_header_type_e.Refer_To, o_uri); }
function tsip_header_Referred_By(o_uri){ tsip_header_NameAddr.call(this, tsip_header_type_e.Referred_By, o_uri); }

if(!window.__b_release_mode){
	tsip_api_add_js_scripts('head',
		'src/tinySIP/src/headers/tsip_header_NameAddrArray.js' // 'P-Asserted-Identity', 'P-Associated-URI', 'Path', 'Record-Route', 'Route', 'Service-Route'
	);
}



/* line 1 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

// Parse headers: 'P-Asserted-Identity', 'P-Associated-URI', 'P-Preferred-Identity', 'Path', 'Record-Route', 'Route', 'Service-Route'

tsip_header_P_Asserted_Identity.prototype = Object.create(tsip_header_NameAddr.prototype);
tsip_header_P_Associated_URI.prototype = Object.create(tsip_header_NameAddr.prototype);
tsip_header_P_Preferred_Identity.prototype = Object.create(tsip_header_NameAddr.prototype);
tsip_header_Path.prototype = Object.create(tsip_header_NameAddr.prototype);
tsip_header_Record_Route.prototype = Object.create(tsip_header_NameAddr.prototype);
tsip_header_Route.prototype = Object.create(tsip_header_NameAddr.prototype);
tsip_header_Service_Route.prototype = Object.create(tsip_header_NameAddr.prototype);

function tsip_header_P_Asserted_Identity(o_uri){ tsip_header_NameAddr.call(this, tsip_header_type_e.P_Asserted_Identity, o_uri); }
function tsip_header_P_Associated_URI(o_uri){ tsip_header_NameAddr.call(this, tsip_header_type_e.P_Associated_URI, o_uri); }
function tsip_header_P_Preferred_Identity(o_uri){ tsip_header_NameAddr.call(this, tsip_header_type_e.P_Preferred_Identity, o_uri); }
function tsip_header_Path(o_uri){ tsip_header_NameAddr.call(this, tsip_header_type_e.Path, o_uri); }
function tsip_header_Record_Route(o_uri){ tsip_header_NameAddr.call(this, tsip_header_type_e.Record_Route, o_uri); }
function tsip_header_Route(o_uri){ tsip_header_NameAddr.call(this, tsip_header_type_e.Route, o_uri); }
function tsip_header_Service_Route(o_uri){ tsip_header_NameAddr.call(this, tsip_header_type_e.Service_Route, o_uri); }


/* line 100 "./ragel/tsip_parser_header_NameAddrArray.jrl" */



/* line 33 "./src/headers/tsip_header_NameAddrArray.js" */
_tsip_machine_parser_header_NameAddrArray_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 1, 8, 1, 9, 1, 10, 1, 
	11, 1, 12, 1, 13, 2, 1, 0, 
	2, 3, 5
];

_tsip_machine_parser_header_NameAddrArray_key_offsets = [
	0, 0, 6, 9, 13, 15, 17, 21, 
	23, 25, 27, 29, 30, 32, 34, 36, 
	38, 40, 42, 44, 46, 49, 52, 73, 
	74, 76, 97, 98, 100, 103, 107, 119, 
	122, 124, 127, 132, 137, 138, 140, 144, 
	161, 162, 164, 180, 198, 204, 205, 207, 
	212, 231, 232, 234, 253, 254, 256, 259, 
	267, 268, 270, 275, 276, 282, 299, 306, 
	314, 322, 330, 332, 339, 348, 350, 353, 
	355, 358, 360, 363, 366, 367, 370, 371, 
	374, 375, 384, 393, 401, 409, 417, 425, 
	427, 433, 442, 451, 460, 462, 465, 468, 
	469, 470, 487, 505, 509, 510, 512, 520, 
	521, 523, 527, 533, 553, 572, 577, 579, 
	586, 588, 590, 592, 594, 596, 598, 599, 
	601, 603, 605, 608, 610, 612, 614, 616, 
	618, 620, 622, 624, 625, 627, 629, 631, 
	633, 635, 637, 639, 641, 644, 646, 648, 
	651, 655, 657, 659, 661, 663, 664, 666, 
	668, 670, 672, 674, 677, 679, 681, 683, 
	686, 688, 690, 692, 694, 696, 698, 699, 
	701, 703, 705, 707, 709, 712
];

_tsip_machine_parser_header_NameAddrArray_trans_keys = [
	80, 82, 83, 112, 114, 115, 45, 65, 
	97, 65, 80, 97, 112, 83, 115, 83, 
	115, 69, 79, 101, 111, 82, 114, 84, 
	116, 69, 101, 68, 100, 45, 73, 105, 
	68, 100, 69, 101, 78, 110, 84, 116, 
	73, 105, 84, 116, 89, 121, 9, 32, 
	58, 9, 32, 58, 9, 13, 32, 33, 
	34, 37, 39, 60, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 96, 97, 
	122, 10, 9, 32, 9, 13, 32, 33, 
	34, 37, 39, 60, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 96, 97, 
	122, 10, 9, 32, 9, 32, 60, 65, 
	90, 97, 122, 9, 32, 43, 58, 45, 
	46, 48, 57, 65, 90, 97, 122, 9, 
	32, 58, 0, 65535, 62, 0, 65535, 9, 
	13, 32, 44, 59, 9, 13, 32, 44, 
	59, 10, 9, 32, 9, 32, 44, 59, 
	9, 13, 32, 33, 37, 39, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 10, 9, 32, 9, 32, 33, 37, 
	39, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 44, 59, 61, 126, 42, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 44, 59, 61, 10, 9, 32, 9, 
	32, 44, 59, 61, 9, 13, 32, 33, 
	34, 37, 39, 91, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 10, 
	9, 32, 9, 13, 32, 33, 34, 37, 
	39, 91, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 10, 9, 32, 
	9, 32, 34, 9, 13, 34, 92, 32, 
	126, 128, 255, 10, 9, 32, 9, 13, 
	32, 44, 59, 10, 0, 9, 11, 12, 
	14, 127, 9, 13, 32, 33, 37, 39, 
	44, 59, 126, 42, 46, 48, 57, 65, 
	90, 95, 122, 58, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 58, 48, 57, 65, 
	70, 97, 102, 46, 58, 93, 48, 57, 
	65, 70, 97, 102, 48, 57, 46, 48, 
	57, 48, 57, 46, 48, 57, 48, 57, 
	93, 48, 57, 93, 48, 57, 93, 46, 
	48, 57, 46, 46, 48, 57, 46, 46, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 58, 93, 48, 57, 65, 70, 97, 
	102, 46, 58, 93, 48, 57, 65, 70, 
	97, 102, 46, 58, 93, 48, 57, 65, 
	70, 97, 102, 46, 58, 93, 48, 57, 
	65, 70, 97, 102, 48, 57, 46, 48, 
	57, 46, 48, 57, 46, 58, 9, 13, 
	32, 33, 37, 39, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 60, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 60, 10, 9, 32, 
	9, 13, 34, 92, 32, 126, 128, 255, 
	10, 9, 32, 9, 13, 32, 60, 0, 
	9, 11, 12, 14, 127, 9, 13, 32, 
	33, 37, 39, 42, 43, 58, 126, 45, 
	46, 48, 57, 65, 90, 95, 96, 97, 
	122, 9, 13, 32, 33, 37, 39, 58, 
	60, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 58, 
	60, 0, 65535, 9, 13, 32, 44, 59, 
	0, 65535, 67, 99, 73, 105, 65, 97, 
	84, 116, 69, 101, 68, 100, 45, 85, 
	117, 82, 114, 73, 105, 9, 32, 58, 
	82, 114, 69, 101, 70, 102, 69, 101, 
	82, 114, 82, 114, 69, 101, 68, 100, 
	45, 73, 105, 68, 100, 69, 101, 78, 
	110, 84, 116, 73, 105, 84, 116, 89, 
	121, 9, 32, 58, 84, 116, 72, 104, 
	9, 32, 58, 69, 79, 101, 111, 67, 
	99, 79, 111, 82, 114, 68, 100, 45, 
	82, 114, 79, 111, 85, 117, 84, 116, 
	69, 101, 9, 32, 58, 85, 117, 84, 
	116, 69, 101, 9, 32, 58, 69, 101, 
	82, 114, 86, 118, 73, 105, 67, 99, 
	69, 101, 45, 82, 114, 79, 111, 85, 
	117, 84, 116, 69, 101, 9, 32, 58, 
	0
];

_tsip_machine_parser_header_NameAddrArray_single_lengths = [
	0, 6, 3, 4, 2, 2, 4, 2, 
	2, 2, 2, 1, 2, 2, 2, 2, 
	2, 2, 2, 2, 3, 3, 9, 1, 
	2, 9, 1, 2, 3, 0, 4, 3, 
	0, 1, 5, 5, 1, 2, 4, 7, 
	1, 2, 6, 10, 6, 1, 2, 5, 
	9, 1, 2, 9, 1, 2, 3, 4, 
	1, 2, 5, 1, 0, 9, 1, 2, 
	2, 2, 2, 1, 3, 0, 1, 0, 
	1, 0, 1, 1, 1, 1, 1, 1, 
	1, 3, 3, 2, 2, 2, 2, 2, 
	0, 3, 3, 3, 0, 1, 1, 1, 
	1, 7, 8, 4, 1, 2, 4, 1, 
	2, 4, 0, 10, 9, 5, 0, 5, 
	2, 2, 2, 2, 2, 2, 1, 2, 
	2, 2, 3, 2, 2, 2, 2, 2, 
	2, 2, 2, 1, 2, 2, 2, 2, 
	2, 2, 2, 2, 3, 2, 2, 3, 
	4, 2, 2, 2, 2, 1, 2, 2, 
	2, 2, 2, 3, 2, 2, 2, 3, 
	2, 2, 2, 2, 2, 2, 1, 2, 
	2, 2, 2, 2, 3, 0
];

_tsip_machine_parser_header_NameAddrArray_range_lengths = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 6, 0, 
	0, 6, 0, 0, 0, 2, 4, 0, 
	1, 1, 0, 0, 0, 0, 0, 5, 
	0, 0, 5, 4, 0, 0, 0, 0, 
	5, 0, 0, 5, 0, 0, 0, 2, 
	0, 0, 0, 0, 3, 4, 3, 3, 
	3, 3, 0, 3, 3, 1, 1, 1, 
	1, 1, 1, 1, 0, 1, 0, 1, 
	0, 3, 3, 3, 3, 3, 3, 0, 
	3, 3, 3, 3, 1, 1, 1, 0, 
	0, 5, 5, 0, 0, 0, 2, 0, 
	0, 0, 3, 5, 5, 0, 1, 1, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0
];

_tsip_machine_parser_header_NameAddrArray_index_offsets = [
	0, 0, 7, 11, 16, 19, 22, 27, 
	30, 33, 36, 39, 41, 44, 47, 50, 
	53, 56, 59, 62, 65, 69, 73, 89, 
	91, 94, 110, 112, 115, 119, 122, 131, 
	135, 137, 140, 146, 152, 154, 157, 162, 
	175, 177, 180, 192, 207, 214, 216, 219, 
	225, 240, 242, 245, 260, 262, 265, 269, 
	276, 278, 281, 287, 289, 293, 307, 312, 
	318, 324, 330, 333, 338, 345, 347, 350, 
	352, 355, 357, 360, 363, 365, 368, 370, 
	373, 375, 382, 389, 395, 401, 407, 413, 
	416, 420, 427, 434, 441, 443, 446, 449, 
	451, 453, 466, 480, 485, 487, 490, 497, 
	499, 502, 507, 511, 527, 542, 548, 550, 
	557, 560, 563, 566, 569, 572, 575, 577, 
	580, 583, 586, 590, 593, 596, 599, 602, 
	605, 608, 611, 614, 616, 619, 622, 625, 
	628, 631, 634, 637, 640, 644, 647, 650, 
	654, 659, 662, 665, 668, 671, 673, 676, 
	679, 682, 685, 688, 692, 695, 698, 701, 
	705, 708, 711, 714, 717, 720, 723, 725, 
	728, 731, 734, 737, 740, 744
];

_tsip_machine_parser_header_NameAddrArray_indicies = [
	0, 2, 3, 0, 2, 3, 1, 4, 
	5, 5, 1, 6, 7, 6, 7, 1, 
	8, 8, 1, 9, 9, 1, 10, 11, 
	10, 11, 1, 12, 12, 1, 13, 13, 
	1, 14, 14, 1, 15, 15, 1, 16, 
	1, 17, 17, 1, 18, 18, 1, 19, 
	19, 1, 20, 20, 1, 21, 21, 1, 
	22, 22, 1, 23, 23, 1, 24, 24, 
	1, 25, 25, 26, 1, 27, 27, 28, 
	1, 29, 30, 29, 31, 32, 31, 31, 
	33, 31, 31, 31, 31, 34, 31, 34, 
	1, 35, 1, 36, 36, 1, 37, 38, 
	37, 31, 32, 31, 31, 33, 31, 31, 
	31, 31, 34, 31, 34, 1, 39, 1, 
	40, 40, 1, 40, 40, 41, 1, 42, 
	42, 1, 43, 43, 44, 45, 44, 44, 
	44, 44, 1, 43, 43, 45, 1, 46, 
	1, 47, 46, 1, 48, 49, 48, 50, 
	51, 1, 52, 53, 52, 28, 54, 1, 
	55, 1, 56, 56, 1, 56, 56, 28, 
	54, 1, 54, 57, 54, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 1, 59, 
	1, 60, 60, 1, 60, 60, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 1, 
	61, 62, 61, 63, 63, 63, 64, 65, 
	66, 63, 63, 63, 63, 63, 1, 67, 
	68, 67, 28, 54, 66, 1, 69, 1, 
	70, 70, 1, 70, 70, 28, 54, 66, 
	1, 66, 71, 66, 72, 73, 72, 72, 
	74, 72, 72, 72, 72, 72, 72, 1, 
	75, 1, 76, 76, 1, 76, 77, 76, 
	72, 73, 72, 72, 74, 72, 72, 72, 
	72, 72, 72, 1, 78, 1, 79, 79, 
	1, 79, 79, 73, 1, 73, 80, 81, 
	82, 73, 73, 1, 83, 1, 73, 73, 
	1, 84, 62, 84, 64, 65, 1, 85, 
	1, 73, 73, 73, 1, 84, 62, 84, 
	72, 72, 72, 64, 65, 72, 72, 72, 
	72, 72, 1, 87, 86, 86, 86, 1, 
	89, 81, 88, 88, 88, 1, 89, 81, 
	90, 90, 90, 1, 89, 81, 91, 91, 
	91, 1, 89, 81, 1, 93, 92, 86, 
	86, 1, 94, 89, 81, 95, 88, 88, 
	1, 96, 1, 97, 98, 1, 99, 1, 
	100, 101, 1, 102, 1, 81, 103, 1, 
	81, 104, 1, 81, 1, 100, 105, 1, 
	100, 1, 97, 106, 1, 97, 1, 94, 
	89, 81, 107, 90, 90, 1, 94, 89, 
	81, 91, 91, 91, 1, 109, 81, 108, 
	108, 108, 1, 111, 81, 110, 110, 110, 
	1, 111, 81, 112, 112, 112, 1, 111, 
	81, 113, 113, 113, 1, 111, 81, 1, 
	114, 108, 108, 1, 94, 111, 81, 115, 
	110, 110, 1, 94, 111, 81, 116, 112, 
	112, 1, 94, 111, 81, 113, 113, 113, 
	1, 117, 1, 94, 118, 1, 94, 119, 
	1, 94, 1, 93, 1, 120, 121, 120, 
	122, 122, 122, 122, 122, 122, 122, 122, 
	122, 1, 123, 124, 123, 122, 122, 122, 
	125, 122, 122, 122, 122, 122, 122, 1, 
	126, 127, 126, 41, 1, 128, 1, 120, 
	120, 1, 129, 130, 131, 132, 129, 129, 
	1, 133, 1, 129, 129, 1, 123, 124, 
	123, 125, 1, 129, 129, 129, 1, 134, 
	121, 134, 122, 122, 122, 122, 135, 136, 
	122, 135, 135, 135, 122, 135, 1, 137, 
	124, 137, 122, 122, 122, 136, 125, 122, 
	122, 122, 122, 122, 122, 1, 138, 127, 
	138, 136, 41, 1, 139, 1, 140, 141, 
	140, 142, 143, 139, 1, 144, 144, 1, 
	145, 145, 1, 146, 146, 1, 147, 147, 
	1, 148, 148, 1, 149, 149, 1, 150, 
	1, 151, 151, 1, 152, 152, 1, 153, 
	153, 1, 154, 154, 155, 1, 156, 156, 
	1, 157, 157, 1, 158, 158, 1, 159, 
	159, 1, 160, 160, 1, 161, 161, 1, 
	162, 162, 1, 163, 163, 1, 164, 1, 
	165, 165, 1, 166, 166, 1, 167, 167, 
	1, 168, 168, 1, 169, 169, 1, 170, 
	170, 1, 171, 171, 1, 172, 172, 1, 
	173, 173, 174, 1, 175, 175, 1, 176, 
	176, 1, 177, 177, 178, 1, 179, 180, 
	179, 180, 1, 181, 181, 1, 182, 182, 
	1, 183, 183, 1, 184, 184, 1, 185, 
	1, 186, 186, 1, 187, 187, 1, 188, 
	188, 1, 189, 189, 1, 190, 190, 1, 
	191, 191, 192, 1, 193, 193, 1, 194, 
	194, 1, 195, 195, 1, 196, 196, 197, 
	1, 198, 198, 1, 199, 199, 1, 200, 
	200, 1, 201, 201, 1, 202, 202, 1, 
	203, 203, 1, 204, 1, 205, 205, 1, 
	206, 206, 1, 207, 207, 1, 208, 208, 
	1, 209, 209, 1, 210, 210, 211, 1, 
	1, 0
];

_tsip_machine_parser_header_NameAddrArray_trans_targs = [
	2, 0, 144, 160, 3, 141, 4, 123, 
	5, 6, 7, 112, 8, 9, 10, 11, 
	12, 13, 14, 15, 16, 17, 18, 19, 
	20, 21, 22, 21, 22, 22, 23, 97, 
	102, 29, 107, 24, 25, 25, 26, 27, 
	28, 29, 30, 31, 30, 32, 33, 34, 
	35, 59, 22, 39, 35, 36, 39, 37, 
	38, 40, 43, 41, 42, 44, 59, 43, 
	22, 39, 48, 44, 45, 46, 47, 49, 
	61, 55, 62, 50, 51, 52, 53, 54, 
	56, 58, 60, 57, 35, 173, 63, 96, 
	64, 67, 65, 66, 68, 83, 69, 81, 
	70, 71, 79, 72, 73, 77, 74, 75, 
	76, 78, 80, 82, 84, 92, 85, 88, 
	86, 87, 89, 90, 91, 93, 94, 95, 
	98, 100, 97, 99, 26, 29, 99, 26, 
	101, 102, 103, 105, 106, 104, 108, 107, 
	110, 109, 109, 111, 35, 59, 22, 39, 
	113, 114, 115, 116, 117, 118, 119, 120, 
	121, 122, 21, 22, 124, 125, 126, 127, 
	128, 129, 130, 131, 132, 133, 134, 135, 
	136, 137, 138, 139, 140, 21, 22, 142, 
	143, 21, 22, 145, 156, 146, 147, 148, 
	149, 150, 151, 152, 153, 154, 155, 21, 
	22, 157, 158, 159, 21, 22, 161, 162, 
	163, 164, 165, 166, 167, 168, 169, 170, 
	171, 172, 21, 22
];

_tsip_machine_parser_header_NameAddrArray_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 13, 13, 0, 0, 3, 3, 29, 
	29, 3, 29, 0, 0, 3, 3, 0, 
	0, 0, 1, 0, 0, 0, 0, 7, 
	11, 11, 11, 11, 0, 0, 0, 0, 
	0, 0, 1, 0, 0, 9, 9, 0, 
	9, 9, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 9, 27, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 5, 5, 5, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 5, 0, 0, 32, 32, 32, 32, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 15, 15, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 17, 17, 0, 
	0, 19, 19, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 21, 
	21, 0, 0, 0, 23, 23, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 25, 25
];

tsip_machine_parser_header_NameAddrArray_start = 1;
tsip_machine_parser_header_NameAddrArray_first_final = 173;
tsip_machine_parser_header_NameAddrArray_error = 0;

tsip_machine_parser_header_NameAddrArray_en_main = 1;


/* line 103 "./ragel/tsip_parser_header_NameAddrArray.jrl" */

tsip_header_P_Asserted_Identity.prototype.Parse =
tsip_header_P_Associated_URI.prototype.Parse =
tsip_header_P_Preferred_Identity.prototype.Parse =
tsip_header_Path.prototype.Parse =
tsip_header_Record_Route.prototype.Parse =
tsip_header_Route.prototype.Parse =
tsip_header_Service_Route.prototype.Parse =
function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;
	var ao_hdrs = new Array();
	var o_curr_hdr = null;
	var t_curr_class = null;
	
	
/* line 420 "./src/headers/tsip_header_NameAddrArray.js" */
{
	 cs = tsip_machine_parser_header_NameAddrArray_start;
} /* JSCodeGen::writeInit */

/* line 123 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
	
/* line 427 "./src/headers/tsip_header_NameAddrArray.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_NameAddrArray_key_offsets[cs];
	_trans = _tsip_machine_parser_header_NameAddrArray_index_offsets[cs];
	_klen = _tsip_machine_parser_header_NameAddrArray_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_NameAddrArray_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_NameAddrArray_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_NameAddrArray_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_NameAddrArray_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_NameAddrArray_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_NameAddrArray_indicies[_trans];
	cs = _tsip_machine_parser_header_NameAddrArray_trans_targs[_trans];
	if (_tsip_machine_parser_header_NameAddrArray_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_NameAddrArray_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_NameAddrArray_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_NameAddrArray_actions[_acts - 1]) {
case 0:
/* line 31 "./ragel/tsip_parser_header_NameAddrArray.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 35 "./ragel/tsip_parser_header_NameAddrArray.jrl" */

		if(!o_curr_hdr){
			o_curr_hdr = new t_curr_class();
		}
			break;
case 2:
/* line 41 "./ragel/tsip_parser_header_NameAddrArray.jrl" */

	    if(o_curr_hdr){			
			o_curr_hdr.s_display_name = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
            o_curr_hdr.s_display_name = tsk_string_unquote_2(o_curr_hdr.s_display_name);
		}
			break;
case 3:
/* line 48 "./ragel/tsip_parser_header_NameAddrArray.jrl" */

		if(o_curr_hdr && !o_curr_hdr.o_uri){
		    var s_uri = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			if((o_curr_hdr.o_uri = tsip_uri.prototype.Parse(s_uri)) && o_curr_hdr.s_display_name){
				o_curr_hdr.o_uri.s_display_name = tsk_strdup(o_curr_hdr.s_display_name);
			}
		}
			break;
case 4:
/* line 57 "./ragel/tsip_parser_header_NameAddrArray.jrl" */

		if(o_curr_hdr){
			tsk_ragel_add_param(s_str, p, i_tag_start, o_curr_hdr.ao_params);
		}
			break;
case 5:
/* line 63 "./ragel/tsip_parser_header_NameAddrArray.jrl" */

		if(o_curr_hdr){
	        ao_hdrs.push(o_curr_hdr);
	        o_curr_hdr = null;
	    }
			break;
case 6:
/* line 70 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
 t_curr_class = tsip_header_P_Asserted_Identity; 		break;
case 7:
/* line 71 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
 t_curr_class = tsip_header_P_Associated_URI; 		break;
case 8:
/* line 72 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
 t_curr_class = tsip_header_P_Preferred_Identity; 		break;
case 9:
/* line 73 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
 t_curr_class = tsip_header_Path; 		break;
case 10:
/* line 74 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
 t_curr_class = tsip_header_Record_Route; 		break;
case 11:
/* line 75 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
 t_curr_class = tsip_header_Route; 		break;
case 12:
/* line 76 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
 t_curr_class = tsip_header_Service_Route; 		break;
case 13:
/* line 78 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
 		break;
/* line 580 "./src/headers/tsip_header_NameAddrArray.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 124 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
	
	if( cs < 
/* line 610 "./src/headers/tsip_header_NameAddrArray.js" */
173
/* line 125 "./ragel/tsip_parser_header_NameAddrArray.jrl" */
 ){
		tsk_utils_log_error("Failed to parse header: " + s_str);
		return null;
	}
	
	return ao_hdrs;
}

/* line 1 "./ragel/tsip_parser_header_Str.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

// Parse headers: 'Call-ID', 'Event', 'P-Access-Network-Info', 'P-Charging-Function-Addresses', 'Server', 'SIP-ETag', 'SIP-If-Match', 'User-Agent'
tsip_header_Str.prototype = Object.create(tsip_header.prototype);
tsip_header_Call_ID.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_Date.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_Event.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_Organization.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_P_Access_Network_Info.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_P_Charging_Function_Addresses.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_Server.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_SIP_ETag.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_SIP_If_Match.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_User_Agent.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_Warning.prototype = Object.create(tsip_header_Str.prototype);
tsip_header_Dummy.prototype = Object.create(tsip_header_Str.prototype);


/* line 86 "./ragel/tsip_parser_header_Str.jrl" */



/* line 30 "./src/headers/tsip_header_Str.js" */
_tsip_machine_parser_header_Str_actions = [
	0, 1, 0, 1, 14, 1, 16, 2, 
	0, 14, 2, 1, 13, 2, 2, 13, 
	2, 3, 13, 2, 4, 13, 2, 5, 
	13, 2, 6, 13, 2, 7, 13, 2, 
	8, 13, 2, 9, 13, 2, 10, 13, 
	2, 11, 13, 2, 12, 13, 2, 14, 
	15, 3, 0, 12, 13
];

_tsip_machine_parser_header_Str_key_offsets = [
	0, 0, 23, 28, 31, 38, 45, 46, 
	70, 95, 103, 129, 153, 167, 174, 205, 
	237, 252, 284, 315, 325, 339, 366, 394, 
	422, 450, 466, 493, 522, 540, 559, 577, 
	596, 614, 633, 652, 667, 686, 701, 720, 
	735, 764, 793, 821, 849, 877, 905, 921, 
	947, 976, 1005, 1034, 1052, 1071, 1090, 1105, 
	1120, 1140, 1161, 1182, 1203, 1212, 1232, 1254, 
	1265, 1277, 1288, 1300, 1311, 1323, 1335, 1343, 
	1355, 1363, 1375, 1383, 1405, 1427, 1448, 1469, 
	1490, 1511, 1520, 1539, 1561, 1583, 1605, 1616, 
	1628, 1640, 1648, 1656, 1657, 1659, 1666, 1673, 
	1680, 1687, 1693, 1700, 1707, 1710, 1717, 1724, 
	1731, 1734, 1741, 1748, 1755, 1762, 1765, 1770, 
	1772, 1774, 1776, 1778, 1780, 1782, 1784, 1786, 
	1788, 1790, 1793, 1799, 1808, 1815, 1822, 1829, 
	1836, 1843, 1849, 1856, 1863, 1870, 1877, 1884, 
	1891, 1898, 1904, 1911, 1918, 1925, 1932, 1935, 
	1942, 1949, 1956, 1963, 1970, 1977, 1984, 1990, 
	1997, 2004, 2011, 2018, 2025, 2032, 2039, 2046, 
	2052, 2059, 2066, 2073, 2080, 2087, 2094, 2101, 
	2108, 2115, 2118, 2127, 2134, 2141, 2148, 2155, 
	2158, 2165, 2171, 2180, 2187, 2194, 2201, 2204, 
	2211, 2217, 2224, 2231, 2238, 2245, 2252, 2255, 
	2262, 2269, 2276, 2282, 2289, 2296, 2303, 2310, 
	2317, 2320, 2327, 2334, 2341, 2348, 2355, 2362, 
	2365
];

_tsip_machine_parser_header_Str_trans_keys = [
	9, 32, 58, 67, 68, 69, 73, 79, 
	80, 83, 85, 87, 99, 100, 101, 105, 
	111, 112, 115, 117, 119, 0, 65535, 9, 
	32, 58, 0, 65535, 9, 32, 58, 9, 
	13, 32, 44, 59, 0, 65535, 9, 13, 
	32, 44, 59, 0, 65535, 10, 9, 13, 
	32, 33, 37, 39, 44, 47, 59, 126, 
	0, 41, 42, 57, 58, 64, 65, 90, 
	91, 94, 95, 122, 123, 65535, 9, 13, 
	32, 33, 37, 39, 44, 47, 59, 61, 
	126, 0, 41, 42, 57, 58, 64, 65, 
	90, 91, 94, 95, 122, 123, 65535, 9, 
	13, 32, 44, 59, 61, 0, 65535, 9, 
	13, 32, 33, 34, 37, 39, 44, 47, 
	59, 91, 126, 0, 41, 42, 57, 58, 
	64, 65, 90, 92, 94, 95, 122, 123, 
	65535, 9, 13, 32, 33, 37, 39, 44, 
	47, 59, 126, 0, 41, 42, 57, 58, 
	64, 65, 90, 91, 94, 95, 122, 123, 
	65535, 9, 13, 32, 34, 44, 59, 92, 
	127, 0, 31, 33, 255, 256, 65535, 9, 
	13, 32, 44, 59, 0, 65535, 9, 13, 
	32, 33, 34, 37, 39, 44, 47, 59, 
	92, 126, 127, 0, 31, 35, 41, 42, 
	57, 58, 64, 65, 90, 91, 94, 95, 
	122, 123, 255, 256, 65535, 9, 13, 32, 
	33, 34, 37, 39, 44, 47, 59, 61, 
	92, 126, 127, 0, 31, 35, 41, 42, 
	57, 58, 64, 65, 90, 91, 94, 95, 
	122, 123, 255, 256, 65535, 9, 13, 32, 
	34, 44, 59, 61, 92, 127, 0, 31, 
	33, 255, 256, 65535, 9, 13, 32, 33, 
	34, 37, 39, 44, 47, 59, 91, 92, 
	126, 127, 0, 31, 35, 41, 42, 57, 
	58, 64, 65, 90, 93, 94, 95, 122, 
	123, 255, 256, 65535, 9, 13, 32, 33, 
	34, 37, 39, 44, 47, 59, 92, 126, 
	127, 0, 31, 35, 41, 42, 57, 58, 
	64, 65, 90, 91, 94, 95, 122, 123, 
	255, 256, 65535, 9, 10, 13, 32, 44, 
	59, 0, 127, 128, 65535, 9, 13, 32, 
	34, 44, 59, 92, 127, 0, 31, 33, 
	255, 256, 65535, 9, 13, 32, 34, 44, 
	58, 59, 92, 127, 0, 31, 33, 47, 
	48, 57, 60, 64, 65, 70, 71, 96, 
	97, 102, 103, 255, 256, 65535, 9, 13, 
	32, 34, 44, 58, 59, 92, 93, 127, 
	0, 31, 33, 47, 48, 57, 60, 64, 
	65, 70, 71, 96, 97, 102, 103, 255, 
	256, 65535, 9, 13, 32, 34, 44, 58, 
	59, 92, 93, 127, 0, 31, 33, 47, 
	48, 57, 60, 64, 65, 70, 71, 96, 
	97, 102, 103, 255, 256, 65535, 9, 13, 
	32, 34, 44, 58, 59, 92, 93, 127, 
	0, 31, 33, 47, 48, 57, 60, 64, 
	65, 70, 71, 96, 97, 102, 103, 255, 
	256, 65535, 9, 13, 32, 34, 44, 58, 
	59, 92, 93, 127, 0, 31, 33, 255, 
	256, 65535, 9, 13, 32, 34, 44, 58, 
	59, 92, 127, 0, 31, 33, 47, 48, 
	57, 60, 64, 65, 70, 71, 96, 97, 
	102, 103, 255, 256, 65535, 9, 13, 32, 
	34, 44, 46, 58, 59, 92, 93, 127, 
	0, 31, 33, 47, 48, 57, 60, 64, 
	65, 70, 71, 96, 97, 102, 103, 255, 
	256, 65535, 9, 13, 32, 34, 44, 59, 
	92, 127, 0, 31, 33, 47, 48, 57, 
	58, 255, 256, 65535, 9, 13, 32, 34, 
	44, 46, 59, 92, 127, 0, 31, 33, 
	47, 48, 57, 58, 255, 256, 65535, 9, 
	13, 32, 34, 44, 59, 92, 127, 0, 
	31, 33, 47, 48, 57, 58, 255, 256, 
	65535, 9, 13, 32, 34, 44, 46, 59, 
	92, 127, 0, 31, 33, 47, 48, 57, 
	58, 255, 256, 65535, 9, 13, 32, 34, 
	44, 59, 92, 127, 0, 31, 33, 47, 
	48, 57, 58, 255, 256, 65535, 9, 13, 
	32, 34, 44, 59, 92, 93, 127, 0, 
	31, 33, 47, 48, 57, 58, 255, 256, 
	65535, 9, 13, 32, 34, 44, 59, 92, 
	93, 127, 0, 31, 33, 47, 48, 57, 
	58, 255, 256, 65535, 9, 13, 32, 34, 
	44, 59, 92, 93, 127, 0, 31, 33, 
	255, 256, 65535, 9, 13, 32, 34, 44, 
	46, 59, 92, 127, 0, 31, 33, 47, 
	48, 57, 58, 255, 256, 65535, 9, 13, 
	32, 34, 44, 46, 59, 92, 127, 0, 
	31, 33, 255, 256, 65535, 9, 13, 32, 
	34, 44, 46, 59, 92, 127, 0, 31, 
	33, 47, 48, 57, 58, 255, 256, 65535, 
	9, 13, 32, 34, 44, 46, 59, 92, 
	127, 0, 31, 33, 255, 256, 65535, 9, 
	13, 32, 34, 44, 46, 58, 59, 92, 
	93, 127, 0, 31, 33, 47, 48, 57, 
	60, 64, 65, 70, 71, 96, 97, 102, 
	103, 255, 256, 65535, 9, 13, 32, 34, 
	44, 46, 58, 59, 92, 93, 127, 0, 
	31, 33, 47, 48, 57, 60, 64, 65, 
	70, 71, 96, 97, 102, 103, 255, 256, 
	65535, 9, 13, 32, 34, 44, 58, 59, 
	92, 93, 127, 0, 31, 33, 47, 48, 
	57, 60, 64, 65, 70, 71, 96, 97, 
	102, 103, 255, 256, 65535, 9, 13, 32, 
	34, 44, 58, 59, 92, 93, 127, 0, 
	31, 33, 47, 48, 57, 60, 64, 65, 
	70, 71, 96, 97, 102, 103, 255, 256, 
	65535, 9, 13, 32, 34, 44, 58, 59, 
	92, 93, 127, 0, 31, 33, 47, 48, 
	57, 60, 64, 65, 70, 71, 96, 97, 
	102, 103, 255, 256, 65535, 9, 13, 32, 
	34, 44, 58, 59, 92, 93, 127, 0, 
	31, 33, 47, 48, 57, 60, 64, 65, 
	70, 71, 96, 97, 102, 103, 255, 256, 
	65535, 9, 13, 32, 34, 44, 58, 59, 
	92, 93, 127, 0, 31, 33, 255, 256, 
	65535, 9, 13, 32, 34, 44, 59, 92, 
	127, 0, 31, 33, 47, 48, 57, 58, 
	64, 65, 70, 71, 96, 97, 102, 103, 
	255, 256, 65535, 9, 13, 32, 34, 44, 
	46, 58, 59, 92, 93, 127, 0, 31, 
	33, 47, 48, 57, 60, 64, 65, 70, 
	71, 96, 97, 102, 103, 255, 256, 65535, 
	9, 13, 32, 34, 44, 46, 58, 59, 
	92, 93, 127, 0, 31, 33, 47, 48, 
	57, 60, 64, 65, 70, 71, 96, 97, 
	102, 103, 255, 256, 65535, 9, 13, 32, 
	34, 44, 46, 58, 59, 92, 93, 127, 
	0, 31, 33, 47, 48, 57, 60, 64, 
	65, 70, 71, 96, 97, 102, 103, 255, 
	256, 65535, 9, 13, 32, 34, 44, 59, 
	92, 127, 0, 31, 33, 47, 48, 57, 
	58, 255, 256, 65535, 9, 13, 32, 34, 
	44, 46, 59, 92, 127, 0, 31, 33, 
	47, 48, 57, 58, 255, 256, 65535, 9, 
	13, 32, 34, 44, 46, 59, 92, 127, 
	0, 31, 33, 47, 48, 57, 58, 255, 
	256, 65535, 9, 13, 32, 34, 44, 46, 
	59, 92, 127, 0, 31, 33, 255, 256, 
	65535, 9, 13, 32, 34, 44, 58, 59, 
	92, 127, 0, 31, 33, 255, 256, 65535, 
	9, 13, 32, 44, 58, 59, 0, 47, 
	48, 57, 60, 64, 65, 70, 71, 96, 
	97, 102, 103, 65535, 9, 13, 32, 44, 
	58, 59, 93, 0, 47, 48, 57, 60, 
	64, 65, 70, 71, 96, 97, 102, 103, 
	65535, 9, 13, 32, 44, 58, 59, 93, 
	0, 47, 48, 57, 60, 64, 65, 70, 
	71, 96, 97, 102, 103, 65535, 9, 13, 
	32, 44, 58, 59, 93, 0, 47, 48, 
	57, 60, 64, 65, 70, 71, 96, 97, 
	102, 103, 65535, 9, 13, 32, 44, 58, 
	59, 93, 0, 65535, 9, 13, 32, 44, 
	58, 59, 0, 47, 48, 57, 60, 64, 
	65, 70, 71, 96, 97, 102, 103, 65535, 
	9, 13, 32, 44, 46, 58, 59, 93, 
	0, 47, 48, 57, 60, 64, 65, 70, 
	71, 96, 97, 102, 103, 65535, 9, 13, 
	32, 44, 59, 0, 47, 48, 57, 58, 
	65535, 9, 13, 32, 44, 46, 59, 0, 
	47, 48, 57, 58, 65535, 9, 13, 32, 
	44, 59, 0, 47, 48, 57, 58, 65535, 
	9, 13, 32, 44, 46, 59, 0, 47, 
	48, 57, 58, 65535, 9, 13, 32, 44, 
	59, 0, 47, 48, 57, 58, 65535, 9, 
	13, 32, 44, 59, 93, 0, 47, 48, 
	57, 58, 65535, 9, 13, 32, 44, 59, 
	93, 0, 47, 48, 57, 58, 65535, 9, 
	13, 32, 44, 59, 93, 0, 65535, 9, 
	13, 32, 44, 46, 59, 0, 47, 48, 
	57, 58, 65535, 9, 13, 32, 44, 46, 
	59, 0, 65535, 9, 13, 32, 44, 46, 
	59, 0, 47, 48, 57, 58, 65535, 9, 
	13, 32, 44, 46, 59, 0, 65535, 9, 
	13, 32, 44, 46, 58, 59, 93, 0, 
	47, 48, 57, 60, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 9, 13, 32, 
	44, 46, 58, 59, 93, 0, 47, 48, 
	57, 60, 64, 65, 70, 71, 96, 97, 
	102, 103, 65535, 9, 13, 32, 44, 58, 
	59, 93, 0, 47, 48, 57, 60, 64, 
	65, 70, 71, 96, 97, 102, 103, 65535, 
	9, 13, 32, 44, 58, 59, 93, 0, 
	47, 48, 57, 60, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 9, 13, 32, 
	44, 58, 59, 93, 0, 47, 48, 57, 
	60, 64, 65, 70, 71, 96, 97, 102, 
	103, 65535, 9, 13, 32, 44, 58, 59, 
	93, 0, 47, 48, 57, 60, 64, 65, 
	70, 71, 96, 97, 102, 103, 65535, 9, 
	13, 32, 44, 58, 59, 93, 0, 65535, 
	9, 13, 32, 44, 59, 0, 47, 48, 
	57, 58, 64, 65, 70, 71, 96, 97, 
	102, 103, 65535, 9, 13, 32, 44, 46, 
	58, 59, 93, 0, 47, 48, 57, 60, 
	64, 65, 70, 71, 96, 97, 102, 103, 
	65535, 9, 13, 32, 44, 46, 58, 59, 
	93, 0, 47, 48, 57, 60, 64, 65, 
	70, 71, 96, 97, 102, 103, 65535, 9, 
	13, 32, 44, 46, 58, 59, 93, 0, 
	47, 48, 57, 60, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 9, 13, 32, 
	44, 59, 0, 47, 48, 57, 58, 65535, 
	9, 13, 32, 44, 46, 59, 0, 47, 
	48, 57, 58, 65535, 9, 13, 32, 44, 
	46, 59, 0, 47, 48, 57, 58, 65535, 
	9, 13, 32, 44, 46, 59, 0, 65535, 
	9, 13, 32, 44, 58, 59, 0, 65535, 
	10, 9, 32, 9, 13, 32, 44, 59, 
	0, 65535, 9, 32, 58, 65, 97, 0, 
	65535, 9, 32, 58, 76, 108, 0, 65535, 
	9, 32, 58, 76, 108, 0, 65535, 9, 
	32, 45, 58, 0, 65535, 9, 32, 58, 
	73, 105, 0, 65535, 9, 32, 58, 68, 
	100, 0, 65535, 9, 32, 58, 9, 32, 
	58, 65, 97, 0, 65535, 9, 32, 58, 
	84, 116, 0, 65535, 9, 32, 58, 69, 
	101, 0, 65535, 9, 32, 58, 9, 32, 
	58, 86, 118, 0, 65535, 9, 32, 58, 
	69, 101, 0, 65535, 9, 32, 58, 78, 
	110, 0, 65535, 9, 32, 58, 84, 116, 
	0, 65535, 9, 32, 58, 9, 32, 58, 
	82, 114, 71, 103, 65, 97, 78, 110, 
	73, 105, 90, 122, 65, 97, 84, 116, 
	73, 105, 79, 111, 78, 110, 9, 32, 
	58, 9, 32, 45, 58, 0, 65535, 9, 
	32, 58, 65, 67, 97, 99, 0, 65535, 
	9, 32, 58, 67, 99, 0, 65535, 9, 
	32, 58, 67, 99, 0, 65535, 9, 32, 
	58, 69, 101, 0, 65535, 9, 32, 58, 
	83, 115, 0, 65535, 9, 32, 58, 83, 
	115, 0, 65535, 9, 32, 45, 58, 0, 
	65535, 9, 32, 58, 78, 110, 0, 65535, 
	9, 32, 58, 69, 101, 0, 65535, 9, 
	32, 58, 84, 116, 0, 65535, 9, 32, 
	58, 87, 119, 0, 65535, 9, 32, 58, 
	79, 111, 0, 65535, 9, 32, 58, 82, 
	114, 0, 65535, 9, 32, 58, 75, 107, 
	0, 65535, 9, 32, 45, 58, 0, 65535, 
	9, 32, 58, 73, 105, 0, 65535, 9, 
	32, 58, 78, 110, 0, 65535, 9, 32, 
	58, 70, 102, 0, 65535, 9, 32, 58, 
	79, 111, 0, 65535, 9, 32, 58, 9, 
	32, 58, 72, 104, 0, 65535, 9, 32, 
	58, 65, 97, 0, 65535, 9, 32, 58, 
	82, 114, 0, 65535, 9, 32, 58, 71, 
	103, 0, 65535, 9, 32, 58, 73, 105, 
	0, 65535, 9, 32, 58, 78, 110, 0, 
	65535, 9, 32, 58, 71, 103, 0, 65535, 
	9, 32, 45, 58, 0, 65535, 9, 32, 
	58, 70, 102, 0, 65535, 9, 32, 58, 
	85, 117, 0, 65535, 9, 32, 58, 78, 
	110, 0, 65535, 9, 32, 58, 67, 99, 
	0, 65535, 9, 32, 58, 84, 116, 0, 
	65535, 9, 32, 58, 73, 105, 0, 65535, 
	9, 32, 58, 79, 111, 0, 65535, 9, 
	32, 58, 78, 110, 0, 65535, 9, 32, 
	45, 58, 0, 65535, 9, 32, 58, 65, 
	97, 0, 65535, 9, 32, 58, 68, 100, 
	0, 65535, 9, 32, 58, 68, 100, 0, 
	65535, 9, 32, 58, 82, 114, 0, 65535, 
	9, 32, 58, 69, 101, 0, 65535, 9, 
	32, 58, 83, 115, 0, 65535, 9, 32, 
	58, 83, 115, 0, 65535, 9, 32, 58, 
	69, 101, 0, 65535, 9, 32, 58, 83, 
	115, 0, 65535, 9, 32, 58, 9, 32, 
	58, 69, 73, 101, 105, 0, 65535, 9, 
	32, 58, 82, 114, 0, 65535, 9, 32, 
	58, 86, 118, 0, 65535, 9, 32, 58, 
	69, 101, 0, 65535, 9, 32, 58, 82, 
	114, 0, 65535, 9, 32, 58, 9, 32, 
	58, 80, 112, 0, 65535, 9, 32, 45, 
	58, 0, 65535, 9, 32, 58, 69, 73, 
	101, 105, 0, 65535, 9, 32, 58, 84, 
	116, 0, 65535, 9, 32, 58, 65, 97, 
	0, 65535, 9, 32, 58, 71, 103, 0, 
	65535, 9, 32, 58, 9, 32, 58, 70, 
	102, 0, 65535, 9, 32, 45, 58, 0, 
	65535, 9, 32, 58, 77, 109, 0, 65535, 
	9, 32, 58, 65, 97, 0, 65535, 9, 
	32, 58, 84, 116, 0, 65535, 9, 32, 
	58, 67, 99, 0, 65535, 9, 32, 58, 
	72, 104, 0, 65535, 9, 32, 58, 9, 
	32, 58, 83, 115, 0, 65535, 9, 32, 
	58, 69, 101, 0, 65535, 9, 32, 58, 
	82, 114, 0, 65535, 9, 32, 45, 58, 
	0, 65535, 9, 32, 58, 65, 97, 0, 
	65535, 9, 32, 58, 71, 103, 0, 65535, 
	9, 32, 58, 69, 101, 0, 65535, 9, 
	32, 58, 78, 110, 0, 65535, 9, 32, 
	58, 84, 116, 0, 65535, 9, 32, 58, 
	9, 32, 58, 65, 97, 0, 65535, 9, 
	32, 58, 82, 114, 0, 65535, 9, 32, 
	58, 78, 110, 0, 65535, 9, 32, 58, 
	73, 105, 0, 65535, 9, 32, 58, 78, 
	110, 0, 65535, 9, 32, 58, 71, 103, 
	0, 65535, 9, 32, 58, 0
];

_tsip_machine_parser_header_Str_single_lengths = [
	0, 21, 3, 3, 5, 5, 1, 10, 
	11, 6, 12, 10, 8, 5, 13, 14, 
	9, 14, 13, 6, 8, 9, 10, 10, 
	10, 10, 9, 11, 8, 9, 8, 9, 
	8, 9, 9, 9, 9, 9, 9, 9, 
	11, 11, 10, 10, 10, 10, 10, 8, 
	11, 11, 11, 8, 9, 9, 9, 9, 
	6, 7, 7, 7, 7, 6, 8, 5, 
	6, 5, 6, 5, 6, 6, 6, 6, 
	6, 6, 6, 8, 8, 7, 7, 7, 
	7, 7, 5, 8, 8, 8, 5, 6, 
	6, 6, 6, 1, 2, 5, 5, 5, 
	5, 4, 5, 5, 3, 5, 5, 5, 
	3, 5, 5, 5, 5, 3, 5, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 3, 4, 7, 5, 5, 5, 5, 
	5, 4, 5, 5, 5, 5, 5, 5, 
	5, 4, 5, 5, 5, 5, 3, 5, 
	5, 5, 5, 5, 5, 5, 4, 5, 
	5, 5, 5, 5, 5, 5, 5, 4, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 3, 7, 5, 5, 5, 5, 3, 
	5, 4, 7, 5, 5, 5, 3, 5, 
	4, 5, 5, 5, 5, 5, 3, 5, 
	5, 5, 4, 5, 5, 5, 5, 5, 
	3, 5, 5, 5, 5, 5, 5, 3, 
	0
];

_tsip_machine_parser_header_Str_range_lengths = [
	0, 1, 1, 0, 1, 1, 0, 7, 
	7, 1, 7, 7, 3, 1, 9, 9, 
	3, 9, 9, 2, 3, 9, 9, 9, 
	9, 3, 9, 9, 5, 5, 5, 5, 
	5, 5, 5, 3, 5, 3, 5, 3, 
	9, 9, 9, 9, 9, 9, 3, 9, 
	9, 9, 9, 5, 5, 5, 3, 3, 
	7, 7, 7, 7, 1, 7, 7, 3, 
	3, 3, 3, 3, 3, 3, 1, 3, 
	1, 3, 1, 7, 7, 7, 7, 7, 
	7, 1, 7, 7, 7, 7, 3, 3, 
	3, 1, 1, 0, 0, 1, 1, 1, 
	1, 1, 1, 1, 0, 1, 1, 1, 
	0, 1, 1, 1, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 0, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 0, 1, 1, 1, 1, 1, 0, 
	1, 1, 1, 1, 1, 1, 0, 1, 
	1, 1, 1, 1, 1, 1, 0, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	0, 1, 1, 1, 1, 1, 1, 0, 
	0
];

_tsip_machine_parser_header_Str_index_offsets = [
	0, 0, 23, 28, 32, 39, 46, 48, 
	66, 85, 93, 113, 131, 143, 150, 173, 
	197, 210, 234, 257, 266, 278, 297, 317, 
	337, 357, 371, 390, 411, 425, 440, 454, 
	469, 483, 498, 513, 526, 541, 554, 569, 
	582, 603, 624, 644, 664, 684, 704, 718, 
	736, 757, 778, 799, 813, 828, 843, 856, 
	869, 883, 898, 913, 928, 937, 951, 967, 
	976, 986, 995, 1005, 1014, 1024, 1034, 1042, 
	1052, 1060, 1070, 1078, 1094, 1110, 1125, 1140, 
	1155, 1170, 1179, 1192, 1208, 1224, 1240, 1249, 
	1259, 1269, 1277, 1285, 1287, 1290, 1297, 1304, 
	1311, 1318, 1324, 1331, 1338, 1342, 1349, 1356, 
	1363, 1367, 1374, 1381, 1388, 1395, 1399, 1405, 
	1408, 1411, 1414, 1417, 1420, 1423, 1426, 1429, 
	1432, 1435, 1439, 1445, 1454, 1461, 1468, 1475, 
	1482, 1489, 1495, 1502, 1509, 1516, 1523, 1530, 
	1537, 1544, 1550, 1557, 1564, 1571, 1578, 1582, 
	1589, 1596, 1603, 1610, 1617, 1624, 1631, 1637, 
	1644, 1651, 1658, 1665, 1672, 1679, 1686, 1693, 
	1699, 1706, 1713, 1720, 1727, 1734, 1741, 1748, 
	1755, 1762, 1766, 1775, 1782, 1789, 1796, 1803, 
	1807, 1814, 1820, 1829, 1836, 1843, 1850, 1854, 
	1861, 1867, 1874, 1881, 1888, 1895, 1902, 1906, 
	1913, 1920, 1927, 1933, 1940, 1947, 1954, 1961, 
	1968, 1972, 1979, 1986, 1993, 2000, 2007, 2014, 
	2018
];

_tsip_machine_parser_header_Str_indicies = [
	2, 2, 3, 4, 5, 6, 7, 8, 
	9, 10, 11, 12, 4, 5, 6, 7, 
	8, 9, 10, 11, 12, 0, 1, 14, 
	14, 15, 13, 1, 16, 16, 17, 1, 
	17, 19, 17, 20, 20, 18, 1, 22, 
	23, 22, 24, 24, 21, 1, 25, 1, 
	24, 23, 24, 26, 26, 26, 24, 21, 
	24, 26, 21, 26, 21, 26, 21, 26, 
	21, 1, 27, 28, 27, 29, 29, 29, 
	30, 21, 30, 31, 29, 21, 29, 21, 
	29, 21, 29, 21, 1, 32, 23, 32, 
	24, 24, 31, 21, 1, 33, 23, 33, 
	34, 35, 34, 34, 24, 21, 24, 36, 
	34, 21, 34, 21, 34, 21, 34, 21, 
	1, 37, 28, 37, 34, 34, 34, 30, 
	21, 30, 34, 21, 34, 21, 34, 21, 
	34, 21, 1, 38, 23, 38, 39, 40, 
	40, 41, 21, 21, 35, 21, 1, 37, 
	28, 37, 30, 30, 21, 1, 40, 23, 
	40, 42, 39, 42, 42, 40, 35, 40, 
	41, 42, 21, 21, 35, 42, 35, 42, 
	35, 42, 35, 21, 1, 43, 28, 43, 
	44, 39, 44, 44, 45, 35, 45, 46, 
	41, 44, 21, 21, 35, 44, 35, 44, 
	35, 44, 35, 21, 1, 47, 23, 47, 
	39, 40, 40, 46, 41, 21, 21, 35, 
	21, 1, 48, 23, 48, 49, 50, 49, 
	49, 40, 35, 40, 51, 41, 49, 21, 
	21, 35, 49, 35, 49, 35, 49, 35, 
	21, 1, 52, 28, 52, 49, 39, 49, 
	49, 45, 35, 45, 41, 49, 21, 21, 
	35, 49, 35, 49, 35, 49, 35, 21, 
	1, 38, 21, 23, 38, 40, 40, 35, 
	21, 1, 52, 28, 52, 39, 45, 45, 
	41, 21, 21, 35, 21, 1, 38, 23, 
	38, 39, 40, 54, 40, 41, 21, 21, 
	35, 53, 35, 53, 35, 53, 35, 21, 
	1, 38, 23, 38, 39, 40, 56, 40, 
	41, 50, 21, 21, 35, 55, 35, 55, 
	35, 55, 35, 21, 1, 38, 23, 38, 
	39, 40, 56, 40, 41, 50, 21, 21, 
	35, 57, 35, 57, 35, 57, 35, 21, 
	1, 38, 23, 38, 39, 40, 56, 40, 
	41, 50, 21, 21, 35, 58, 35, 58, 
	35, 58, 35, 21, 1, 38, 23, 38, 
	39, 40, 56, 40, 41, 50, 21, 21, 
	35, 21, 1, 38, 23, 38, 39, 40, 
	60, 40, 41, 21, 21, 35, 59, 35, 
	53, 35, 53, 35, 21, 1, 38, 23, 
	38, 39, 40, 61, 56, 40, 41, 50, 
	21, 21, 35, 62, 35, 55, 35, 55, 
	35, 21, 1, 38, 23, 38, 39, 40, 
	40, 41, 21, 21, 35, 63, 35, 21, 
	1, 38, 23, 38, 39, 40, 64, 40, 
	41, 21, 21, 35, 65, 35, 21, 1, 
	38, 23, 38, 39, 40, 40, 41, 21, 
	21, 35, 66, 35, 21, 1, 38, 23, 
	38, 39, 40, 67, 40, 41, 21, 21, 
	35, 68, 35, 21, 1, 38, 23, 38, 
	39, 40, 40, 41, 21, 21, 35, 69, 
	35, 21, 1, 38, 23, 38, 39, 40, 
	40, 41, 50, 21, 21, 35, 70, 35, 
	21, 1, 38, 23, 38, 39, 40, 40, 
	41, 50, 21, 21, 35, 71, 35, 21, 
	1, 38, 23, 38, 39, 40, 40, 41, 
	50, 21, 21, 35, 21, 1, 38, 23, 
	38, 39, 40, 67, 40, 41, 21, 21, 
	35, 72, 35, 21, 1, 38, 23, 38, 
	39, 40, 67, 40, 41, 21, 21, 35, 
	21, 1, 38, 23, 38, 39, 40, 64, 
	40, 41, 21, 21, 35, 73, 35, 21, 
	1, 38, 23, 38, 39, 40, 64, 40, 
	41, 21, 21, 35, 21, 1, 38, 23, 
	38, 39, 40, 61, 56, 40, 41, 50, 
	21, 21, 35, 74, 35, 57, 35, 57, 
	35, 21, 1, 38, 23, 38, 39, 40, 
	61, 56, 40, 41, 50, 21, 21, 35, 
	58, 35, 58, 35, 58, 35, 21, 1, 
	38, 23, 38, 39, 40, 76, 40, 41, 
	50, 21, 21, 35, 75, 35, 75, 35, 
	75, 35, 21, 1, 38, 23, 38, 39, 
	40, 78, 40, 41, 50, 21, 21, 35, 
	77, 35, 77, 35, 77, 35, 21, 1, 
	38, 23, 38, 39, 40, 78, 40, 41, 
	50, 21, 21, 35, 79, 35, 79, 35, 
	79, 35, 21, 1, 38, 23, 38, 39, 
	40, 78, 40, 41, 50, 21, 21, 35, 
	80, 35, 80, 35, 80, 35, 21, 1, 
	38, 23, 38, 39, 40, 78, 40, 41, 
	50, 21, 21, 35, 21, 1, 38, 23, 
	38, 39, 40, 40, 41, 21, 21, 35, 
	81, 35, 75, 35, 75, 35, 21, 1, 
	38, 23, 38, 39, 40, 61, 78, 40, 
	41, 50, 21, 21, 35, 82, 35, 77, 
	35, 77, 35, 21, 1, 38, 23, 38, 
	39, 40, 61, 78, 40, 41, 50, 21, 
	21, 35, 83, 35, 79, 35, 79, 35, 
	21, 1, 38, 23, 38, 39, 40, 61, 
	78, 40, 41, 50, 21, 21, 35, 80, 
	35, 80, 35, 80, 35, 21, 1, 38, 
	23, 38, 39, 40, 40, 41, 21, 21, 
	35, 84, 35, 21, 1, 38, 23, 38, 
	39, 40, 61, 40, 41, 21, 21, 35, 
	85, 35, 21, 1, 38, 23, 38, 39, 
	40, 61, 40, 41, 21, 21, 35, 86, 
	35, 21, 1, 38, 23, 38, 39, 40, 
	61, 40, 41, 21, 21, 35, 21, 1, 
	38, 23, 38, 39, 40, 60, 40, 41, 
	21, 21, 35, 21, 1, 22, 23, 22, 
	24, 88, 24, 21, 87, 21, 87, 21, 
	87, 21, 1, 22, 23, 22, 24, 90, 
	24, 39, 21, 89, 21, 89, 21, 89, 
	21, 1, 22, 23, 22, 24, 90, 24, 
	39, 21, 91, 21, 91, 21, 91, 21, 
	1, 22, 23, 22, 24, 90, 24, 39, 
	21, 92, 21, 92, 21, 92, 21, 1, 
	22, 23, 22, 24, 90, 24, 39, 21, 
	1, 22, 23, 22, 24, 94, 24, 21, 
	93, 21, 87, 21, 87, 21, 1, 22, 
	23, 22, 24, 95, 90, 24, 39, 21, 
	96, 21, 89, 21, 89, 21, 1, 22, 
	23, 22, 24, 24, 21, 97, 21, 1, 
	22, 23, 22, 24, 98, 24, 21, 99, 
	21, 1, 22, 23, 22, 24, 24, 21, 
	100, 21, 1, 22, 23, 22, 24, 101, 
	24, 21, 102, 21, 1, 22, 23, 22, 
	24, 24, 21, 103, 21, 1, 22, 23, 
	22, 24, 24, 39, 21, 104, 21, 1, 
	22, 23, 22, 24, 24, 39, 21, 105, 
	21, 1, 22, 23, 22, 24, 24, 39, 
	21, 1, 22, 23, 22, 24, 101, 24, 
	21, 106, 21, 1, 22, 23, 22, 24, 
	101, 24, 21, 1, 22, 23, 22, 24, 
	98, 24, 21, 107, 21, 1, 22, 23, 
	22, 24, 98, 24, 21, 1, 22, 23, 
	22, 24, 95, 90, 24, 39, 21, 108, 
	21, 91, 21, 91, 21, 1, 22, 23, 
	22, 24, 95, 90, 24, 39, 21, 92, 
	21, 92, 21, 92, 21, 1, 22, 23, 
	22, 24, 110, 24, 39, 21, 109, 21, 
	109, 21, 109, 21, 1, 22, 23, 22, 
	24, 112, 24, 39, 21, 111, 21, 111, 
	21, 111, 21, 1, 22, 23, 22, 24, 
	112, 24, 39, 21, 113, 21, 113, 21, 
	113, 21, 1, 22, 23, 22, 24, 112, 
	24, 39, 21, 114, 21, 114, 21, 114, 
	21, 1, 22, 23, 22, 24, 112, 24, 
	39, 21, 1, 22, 23, 22, 24, 24, 
	21, 115, 21, 109, 21, 109, 21, 1, 
	22, 23, 22, 24, 95, 112, 24, 39, 
	21, 116, 21, 111, 21, 111, 21, 1, 
	22, 23, 22, 24, 95, 112, 24, 39, 
	21, 117, 21, 113, 21, 113, 21, 1, 
	22, 23, 22, 24, 95, 112, 24, 39, 
	21, 114, 21, 114, 21, 114, 21, 1, 
	22, 23, 22, 24, 24, 21, 118, 21, 
	1, 22, 23, 22, 24, 95, 24, 21, 
	119, 21, 1, 22, 23, 22, 24, 95, 
	24, 21, 120, 21, 1, 22, 23, 22, 
	24, 95, 24, 21, 1, 22, 23, 22, 
	24, 94, 24, 21, 1, 121, 1, 122, 
	122, 1, 122, 123, 122, 20, 20, 18, 
	1, 14, 14, 15, 124, 124, 13, 1, 
	14, 14, 15, 125, 125, 13, 1, 14, 
	14, 15, 126, 126, 13, 1, 14, 14, 
	127, 15, 13, 1, 14, 14, 15, 128, 
	128, 13, 1, 14, 14, 15, 129, 129, 
	13, 1, 130, 130, 131, 1, 14, 14, 
	15, 132, 132, 13, 1, 14, 14, 15, 
	133, 133, 13, 1, 14, 14, 15, 134, 
	134, 13, 1, 135, 135, 136, 1, 14, 
	14, 15, 137, 137, 13, 1, 14, 14, 
	15, 138, 138, 13, 1, 14, 14, 15, 
	139, 139, 13, 1, 14, 14, 15, 140, 
	140, 13, 1, 141, 141, 142, 1, 141, 
	141, 142, 143, 143, 1, 144, 144, 1, 
	145, 145, 1, 146, 146, 1, 147, 147, 
	1, 148, 148, 1, 149, 149, 1, 150, 
	150, 1, 151, 151, 1, 152, 152, 1, 
	153, 153, 1, 154, 154, 155, 1, 14, 
	14, 156, 15, 13, 1, 14, 14, 15, 
	157, 158, 157, 158, 13, 1, 14, 14, 
	15, 159, 159, 13, 1, 14, 14, 15, 
	160, 160, 13, 1, 14, 14, 15, 161, 
	161, 13, 1, 14, 14, 15, 162, 162, 
	13, 1, 14, 14, 15, 163, 163, 13, 
	1, 14, 14, 164, 15, 13, 1, 14, 
	14, 15, 165, 165, 13, 1, 14, 14, 
	15, 166, 166, 13, 1, 14, 14, 15, 
	167, 167, 13, 1, 14, 14, 15, 168, 
	168, 13, 1, 14, 14, 15, 169, 169, 
	13, 1, 14, 14, 15, 170, 170, 13, 
	1, 14, 14, 15, 171, 171, 13, 1, 
	14, 14, 172, 15, 13, 1, 14, 14, 
	15, 173, 173, 13, 1, 14, 14, 15, 
	174, 174, 13, 1, 14, 14, 15, 175, 
	175, 13, 1, 14, 14, 15, 176, 176, 
	13, 1, 177, 177, 178, 1, 14, 14, 
	15, 179, 179, 13, 1, 14, 14, 15, 
	180, 180, 13, 1, 14, 14, 15, 181, 
	181, 13, 1, 14, 14, 15, 182, 182, 
	13, 1, 14, 14, 15, 183, 183, 13, 
	1, 14, 14, 15, 184, 184, 13, 1, 
	14, 14, 15, 185, 185, 13, 1, 14, 
	14, 186, 15, 13, 1, 14, 14, 15, 
	187, 187, 13, 1, 14, 14, 15, 188, 
	188, 13, 1, 14, 14, 15, 189, 189, 
	13, 1, 14, 14, 15, 190, 190, 13, 
	1, 14, 14, 15, 191, 191, 13, 1, 
	14, 14, 15, 192, 192, 13, 1, 14, 
	14, 15, 193, 193, 13, 1, 14, 14, 
	15, 194, 194, 13, 1, 14, 14, 195, 
	15, 13, 1, 14, 14, 15, 196, 196, 
	13, 1, 14, 14, 15, 197, 197, 13, 
	1, 14, 14, 15, 198, 198, 13, 1, 
	14, 14, 15, 199, 199, 13, 1, 14, 
	14, 15, 200, 200, 13, 1, 14, 14, 
	15, 201, 201, 13, 1, 14, 14, 15, 
	202, 202, 13, 1, 14, 14, 15, 203, 
	203, 13, 1, 14, 14, 15, 204, 204, 
	13, 1, 205, 205, 206, 1, 14, 14, 
	15, 207, 208, 207, 208, 13, 1, 14, 
	14, 15, 209, 209, 13, 1, 14, 14, 
	15, 210, 210, 13, 1, 14, 14, 15, 
	211, 211, 13, 1, 14, 14, 15, 212, 
	212, 13, 1, 213, 213, 214, 1, 14, 
	14, 15, 215, 215, 13, 1, 14, 14, 
	216, 15, 13, 1, 14, 14, 15, 217, 
	218, 217, 218, 13, 1, 14, 14, 15, 
	219, 219, 13, 1, 14, 14, 15, 220, 
	220, 13, 1, 14, 14, 15, 221, 221, 
	13, 1, 222, 222, 223, 1, 14, 14, 
	15, 224, 224, 13, 1, 14, 14, 225, 
	15, 13, 1, 14, 14, 15, 226, 226, 
	13, 1, 14, 14, 15, 227, 227, 13, 
	1, 14, 14, 15, 228, 228, 13, 1, 
	14, 14, 15, 229, 229, 13, 1, 14, 
	14, 15, 230, 230, 13, 1, 231, 231, 
	232, 1, 14, 14, 15, 233, 233, 13, 
	1, 14, 14, 15, 234, 234, 13, 1, 
	14, 14, 15, 235, 235, 13, 1, 14, 
	14, 236, 15, 13, 1, 14, 14, 15, 
	237, 237, 13, 1, 14, 14, 15, 238, 
	238, 13, 1, 14, 14, 15, 239, 239, 
	13, 1, 14, 14, 15, 240, 240, 13, 
	1, 14, 14, 15, 241, 241, 13, 1, 
	242, 242, 243, 1, 14, 14, 15, 244, 
	244, 13, 1, 14, 14, 15, 245, 245, 
	13, 1, 14, 14, 15, 246, 246, 13, 
	1, 14, 14, 15, 247, 247, 13, 1, 
	14, 14, 15, 248, 248, 13, 1, 14, 
	14, 15, 249, 249, 13, 1, 250, 250, 
	251, 1, 1, 0
];

_tsip_machine_parser_header_Str_trans_targs = [
	2, 0, 3, 4, 94, 101, 105, 100, 
	110, 122, 170, 191, 201, 2, 3, 4, 
	3, 4, 5, 91, 7, 5, 5, 6, 
	7, 208, 8, 9, 6, 8, 7, 10, 
	9, 10, 11, 12, 56, 5, 12, 13, 
	14, 19, 15, 16, 15, 14, 17, 16, 
	17, 18, 20, 21, 12, 22, 55, 23, 
	26, 24, 25, 27, 42, 28, 40, 29, 
	30, 38, 31, 32, 36, 33, 34, 35, 
	37, 39, 41, 43, 51, 44, 47, 45, 
	46, 48, 49, 50, 52, 53, 54, 57, 
	90, 58, 61, 59, 60, 62, 77, 63, 
	75, 64, 65, 73, 66, 67, 71, 68, 
	69, 70, 72, 74, 76, 78, 86, 79, 
	82, 80, 81, 83, 84, 85, 87, 88, 
	89, 92, 93, 6, 95, 96, 97, 98, 
	99, 100, 3, 4, 102, 103, 104, 3, 
	4, 106, 107, 108, 109, 3, 4, 111, 
	112, 113, 114, 115, 116, 117, 118, 119, 
	120, 121, 3, 4, 123, 124, 143, 125, 
	126, 127, 128, 129, 130, 131, 132, 133, 
	134, 135, 136, 137, 138, 139, 140, 141, 
	142, 3, 4, 144, 145, 146, 147, 148, 
	149, 150, 151, 152, 153, 154, 155, 156, 
	157, 158, 159, 160, 161, 162, 163, 164, 
	165, 166, 167, 168, 169, 3, 4, 171, 
	176, 172, 173, 174, 175, 3, 4, 177, 
	178, 179, 183, 180, 181, 182, 3, 4, 
	184, 185, 186, 187, 188, 189, 190, 3, 
	4, 192, 193, 194, 195, 196, 197, 198, 
	199, 200, 3, 4, 202, 203, 204, 205, 
	206, 207, 3, 4
];

_tsip_machine_parser_header_Str_trans_actions = [
	1, 0, 49, 49, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 0, 43, 43, 
	0, 0, 1, 0, 7, 0, 3, 3, 
	3, 5, 1, 46, 46, 0, 46, 0, 
	3, 3, 0, 0, 0, 46, 3, 0, 
	3, 0, 1, 46, 0, 46, 0, 3, 
	3, 0, 0, 0, 46, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 7, 0, 0, 0, 0, 
	0, 0, 10, 10, 0, 0, 0, 13, 
	13, 0, 0, 0, 0, 16, 16, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 19, 19, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 22, 22, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 25, 25, 0, 
	0, 0, 0, 0, 0, 28, 28, 0, 
	0, 0, 0, 0, 0, 0, 31, 31, 
	0, 0, 0, 0, 0, 0, 0, 34, 
	34, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 37, 37, 0, 0, 0, 0, 
	0, 0, 40, 40
];

tsip_machine_parser_header_Str_start = 1;
tsip_machine_parser_header_Str_first_final = 208;
tsip_machine_parser_header_Str_error = 0;

tsip_machine_parser_header_Str_en_main = 1;


/* line 89 "./ragel/tsip_parser_header_Str.jrl" */

function tsip_header_Str(e_type, s_value){
	tsip_header.call(this, e_type);
    this.s_value = s_value;
}

tsip_header_Str.prototype.toString = function(){
    return this.s_value;
};

tsip_header_Str.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var o_hdr = null;
	
	
/* line 814 "./src/headers/tsip_header_Str.js" */
{
	 cs = tsip_machine_parser_header_Str_start;
} /* JSCodeGen::writeInit */

/* line 109 "./ragel/tsip_parser_header_Str.jrl" */
	
/* line 821 "./src/headers/tsip_header_Str.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_Str_key_offsets[cs];
	_trans = _tsip_machine_parser_header_Str_index_offsets[cs];
	_klen = _tsip_machine_parser_header_Str_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_Str_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_Str_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_Str_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_Str_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_Str_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_Str_indicies[_trans];
	cs = _tsip_machine_parser_header_Str_trans_targs[_trans];
	if (_tsip_machine_parser_header_Str_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_Str_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_Str_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_Str_actions[_acts - 1]) {
case 0:
/* line 28 "./ragel/tsip_parser_header_Str.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 32 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new  tsip_header_Call_ID(); 		break;
case 2:
/* line 33 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new  tsip_header_Date(); 		break;
case 3:
/* line 34 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new  tsip_header_Event(); 		break;
case 4:
/* line 35 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new tsip_header_Organization(); 		break;
case 5:
/* line 36 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new tsip_header_P_Access_Network_Info(); 		break;
case 6:
/* line 37 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new tsip_header_P_Charging_Function_Addresses(); 		break;
case 7:
/* line 38 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new tsip_header_Server(); 		break;
case 8:
/* line 39 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new tsip_header_SIP_ETag(); 		break;
case 9:
/* line 40 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new tsip_header_SIP_If_Match(); 		break;
case 10:
/* line 41 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new tsip_header_User_Agent(); 		break;
case 11:
/* line 42 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new tsip_header_Warning(); 		break;
case 12:
/* line 43 "./ragel/tsip_parser_header_Str.jrl" */
 o_hdr = new tsip_header_Dummy(); 		break;
case 13:
/* line 45 "./ragel/tsip_parser_header_Str.jrl" */

		if(o_hdr){
			o_hdr.s_name = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
		}
			break;
case 14:
/* line 51 "./ragel/tsip_parser_header_Str.jrl" */

		if(o_hdr){
			o_hdr.s_value = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
		}
			break;
case 15:
/* line 57 "./ragel/tsip_parser_header_Str.jrl" */

		if(o_hdr){
			tsk_ragel_add_param(s_str, p, i_tag_start, o_hdr.ao_params);
		}
			break;
case 16:
/* line 63 "./ragel/tsip_parser_header_Str.jrl" */
 		break;
/* line 970 "./src/headers/tsip_header_Str.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 110 "./ragel/tsip_parser_header_Str.jrl" */
	
	if( cs < 
/* line 1000 "./src/headers/tsip_header_Str.js" */
208
/* line 111 "./ragel/tsip_parser_header_Str.jrl" */
 ){
		tsk_utils_log_error("Failed to parse header: " + s_str);
		return null;
	}
	
	return o_hdr;
}

function tsip_header_Call_ID(s_value){ tsip_header_Str.call(this, tsip_header_type_e.Call_ID, s_value); }
function tsip_header_Date(s_value){ tsip_header_Str.call(this, tsip_header_type_e.Date, s_value); }
function tsip_header_Event(s_value){ tsip_header_Str.call(this, tsip_header_type_e.Event, s_value); }
function tsip_header_Organization(s_value){ tsip_header_Str.call(this, tsip_header_type_e.Organization, s_value); }
function tsip_header_P_Access_Network_Info(s_value){ tsip_header_Str.call(this, tsip_header_type_e.P_Access_Network_Info, s_value); }
function tsip_header_P_Charging_Function_Addresses(s_value){ tsip_header_Str.call(this, tsip_header_type_e.P_Charging_Function_Addresses, s_value); }
function tsip_header_Server(s_value){ tsip_header_Str.call(this, tsip_header_type_e.Server, s_value); }
function tsip_header_SIP_ETag(s_value){ tsip_header_Str.call(this, tsip_header_type_e.SIP_ETag, s_value); }
function tsip_header_SIP_If_Match(s_value){ tsip_header_Str.call(this, tsip_header_type_e.SIP_If_Match, s_value); }
function tsip_header_User_Agent(s_value){ tsip_header_Str.call(this, tsip_header_type_e.User_Agent, s_value); }
function tsip_header_Warning(s_value){ tsip_header_Str.call(this, tsip_header_type_e.Warning, s_value); }
function tsip_header_Dummy(s_name, s_value){ tsip_header_Str.call(this, tsip_header_type_e.Dummy, s_value); this.s_name = s_name; }

/* line 1 "./ragel/tsip_parser_header_StrArray.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

// Parse headers: 'Allow', 'Allow-Events', 'Privacy', 'Require', 'Supported'

var TSIP_HEADER_ALLOW_DEFAULT =	"ACK, BYE, CANCEL, INVITE, MESSAGE, NOTIFY, OPTIONS, PRACK, REFER, UPDATE";

tsip_header_StrArray.prototype = Object.create(tsip_header.prototype);
tsip_header_StrArray.prototype.as_values = null;

tsip_header_Allow.prototype = Object.create(tsip_header_StrArray.prototype);
tsip_header_Allow_Events.prototype = Object.create(tsip_header_StrArray.prototype);
tsip_header_Privacy.prototype = Object.create(tsip_header_StrArray.prototype);
tsip_header_Require.prototype = Object.create(tsip_header_StrArray.prototype);
tsip_header_Supported.prototype = Object.create(tsip_header_StrArray.prototype);


/* line 61 "./ragel/tsip_parser_header_StrArray.jrl" */



/* line 28 "./src/headers/tsip_header_StrArray.js" */
_tsip_machine_parser_header_Allow_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7
];

_tsip_machine_parser_header_Allow_key_offsets = [
	0, 0, 12, 14, 16, 18, 20, 24, 
	27, 44, 45, 61, 65, 66, 68, 71, 
	88, 89, 91, 107, 109, 111, 113, 115, 
	117, 119, 122, 125, 141, 142, 144, 159, 
	176, 180, 181, 183, 186, 199, 202, 204, 
	206, 208, 210, 212, 214, 217, 220, 249, 
	250, 252, 280, 296, 322, 340, 358, 376, 
	394, 412, 430, 448, 450, 470, 488, 506, 
	524, 542, 560, 578, 596, 614, 632, 650, 
	668, 686, 704, 722, 740, 758, 776, 794, 
	812, 830, 832, 834, 836, 838, 840, 842, 
	845, 848, 850, 852, 854, 856, 858, 860, 
	862, 864
];

_tsip_machine_parser_header_Allow_trans_keys = [
	65, 75, 80, 82, 83, 85, 97, 107, 
	112, 114, 115, 117, 76, 108, 76, 108, 
	79, 111, 87, 119, 9, 32, 45, 58, 
	9, 32, 58, 9, 13, 32, 33, 37, 
	39, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 10, 9, 13, 32, 
	33, 37, 39, 44, 126, 42, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	44, 10, 9, 32, 9, 32, 44, 9, 
	13, 32, 33, 37, 39, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	10, 9, 32, 9, 32, 33, 37, 39, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 69, 101, 86, 118, 69, 
	101, 78, 110, 84, 116, 83, 115, 9, 
	32, 58, 9, 32, 58, 9, 13, 32, 
	33, 37, 39, 45, 126, 42, 43, 48, 
	57, 65, 90, 95, 122, 10, 9, 32, 
	9, 32, 33, 37, 39, 45, 126, 42, 
	43, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 46, 126, 
	42, 45, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 44, 10, 9, 32, 9, 
	32, 44, 33, 37, 39, 45, 126, 42, 
	43, 48, 57, 65, 90, 95, 122, 9, 
	32, 58, 82, 114, 73, 105, 86, 118, 
	65, 97, 67, 99, 89, 121, 9, 32, 
	58, 9, 32, 58, 9, 13, 32, 33, 
	37, 39, 67, 72, 73, 78, 83, 85, 
	99, 104, 105, 110, 115, 117, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 10, 9, 32, 9, 32, 33, 37, 
	39, 67, 72, 73, 78, 83, 85, 99, 
	104, 105, 110, 115, 117, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	13, 33, 37, 39, 59, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	33, 37, 39, 67, 72, 73, 78, 83, 
	85, 99, 104, 105, 110, 115, 117, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 13, 33, 37, 39, 59, 82, 
	114, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 13, 33, 37, 39, 
	59, 73, 105, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 13, 33, 
	37, 39, 59, 84, 116, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	13, 33, 37, 39, 59, 73, 105, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 13, 33, 37, 39, 59, 67, 
	99, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 13, 33, 37, 39, 
	59, 65, 97, 126, 42, 43, 45, 46, 
	48, 57, 66, 90, 95, 122, 13, 33, 
	37, 39, 59, 76, 108, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	13, 59, 13, 33, 37, 39, 59, 69, 
	73, 101, 105, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 13, 33, 
	37, 39, 59, 65, 97, 126, 42, 43, 
	45, 46, 48, 57, 66, 90, 95, 122, 
	13, 33, 37, 39, 59, 68, 100, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 13, 33, 37, 39, 59, 69, 
	101, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 13, 33, 37, 39, 
	59, 82, 114, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 13, 33, 
	37, 39, 59, 83, 115, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	13, 33, 37, 39, 59, 84, 116, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 13, 33, 37, 39, 59, 79, 
	111, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 13, 33, 37, 39, 
	59, 82, 114, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 13, 33, 
	37, 39, 59, 89, 121, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	13, 33, 37, 39, 59, 68, 100, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 13, 33, 37, 39, 59, 79, 
	111, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 13, 33, 37, 39, 
	59, 78, 110, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 13, 33, 
	37, 39, 59, 69, 101, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	13, 33, 37, 39, 59, 69, 101, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 13, 33, 37, 39, 59, 83, 
	115, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 13, 33, 37, 39, 
	59, 83, 115, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 13, 33, 
	37, 39, 59, 73, 105, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	13, 33, 37, 39, 59, 79, 111, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 13, 33, 37, 39, 59, 78, 
	110, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 13, 33, 37, 39, 
	59, 83, 115, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 69, 101, 
	81, 113, 85, 117, 73, 105, 82, 114, 
	69, 101, 9, 32, 58, 9, 32, 58, 
	85, 117, 80, 112, 80, 112, 79, 111, 
	82, 114, 84, 116, 69, 101, 68, 100, 
	0
];

_tsip_machine_parser_header_Allow_single_lengths = [
	0, 12, 2, 2, 2, 2, 4, 3, 
	7, 1, 8, 4, 1, 2, 3, 7, 
	1, 2, 6, 2, 2, 2, 2, 2, 
	2, 3, 3, 8, 1, 2, 7, 9, 
	4, 1, 2, 3, 5, 3, 2, 2, 
	2, 2, 2, 2, 3, 3, 19, 1, 
	2, 18, 6, 16, 8, 8, 8, 8, 
	8, 8, 8, 2, 10, 8, 8, 8, 
	8, 8, 8, 8, 8, 8, 8, 8, 
	8, 8, 8, 8, 8, 8, 8, 8, 
	8, 2, 2, 2, 2, 2, 2, 3, 
	3, 2, 2, 2, 2, 2, 2, 2, 
	2, 0
];

_tsip_machine_parser_header_Allow_range_lengths = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	5, 0, 4, 0, 0, 0, 0, 5, 
	0, 0, 5, 0, 0, 0, 0, 0, 
	0, 0, 0, 4, 0, 0, 4, 4, 
	0, 0, 0, 0, 4, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 5, 0, 
	0, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 0, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0
];

_tsip_machine_parser_header_Allow_index_offsets = [
	0, 0, 13, 16, 19, 22, 25, 30, 
	34, 47, 49, 62, 67, 69, 72, 76, 
	89, 91, 94, 106, 109, 112, 115, 118, 
	121, 124, 128, 132, 145, 147, 150, 162, 
	176, 181, 183, 186, 190, 200, 204, 207, 
	210, 213, 216, 219, 222, 226, 230, 255, 
	257, 260, 284, 296, 318, 332, 346, 360, 
	374, 388, 402, 416, 419, 435, 449, 463, 
	477, 491, 505, 519, 533, 547, 561, 575, 
	589, 603, 617, 631, 645, 659, 673, 687, 
	701, 715, 718, 721, 724, 727, 730, 733, 
	737, 741, 744, 747, 750, 753, 756, 759, 
	762, 765
];

_tsip_machine_parser_header_Allow_indicies = [
	0, 2, 3, 4, 5, 6, 0, 2, 
	3, 4, 5, 6, 1, 7, 7, 1, 
	8, 8, 1, 9, 9, 1, 10, 10, 
	1, 11, 11, 12, 13, 1, 14, 14, 
	15, 1, 15, 16, 15, 17, 17, 17, 
	17, 17, 17, 17, 17, 17, 1, 18, 
	1, 19, 20, 19, 21, 21, 21, 22, 
	21, 21, 21, 21, 21, 1, 23, 24, 
	23, 25, 1, 26, 1, 27, 27, 1, 
	27, 27, 25, 1, 25, 28, 25, 17, 
	17, 17, 17, 17, 17, 17, 17, 17, 
	1, 29, 1, 30, 30, 1, 30, 30, 
	17, 17, 17, 17, 17, 17, 17, 17, 
	17, 1, 31, 31, 1, 32, 32, 1, 
	33, 33, 1, 34, 34, 1, 35, 35, 
	1, 6, 6, 1, 36, 36, 37, 1, 
	38, 38, 39, 1, 39, 40, 39, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	1, 42, 1, 43, 43, 1, 43, 43, 
	41, 41, 41, 41, 41, 41, 41, 41, 
	41, 1, 44, 20, 44, 45, 45, 45, 
	46, 47, 45, 45, 45, 45, 45, 1, 
	48, 49, 48, 39, 1, 50, 1, 51, 
	51, 1, 51, 51, 39, 1, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 1, 
	52, 52, 53, 1, 54, 54, 1, 55, 
	55, 1, 56, 56, 1, 57, 57, 1, 
	58, 58, 1, 59, 59, 1, 60, 60, 
	61, 1, 62, 62, 63, 1, 63, 64, 
	63, 65, 65, 65, 66, 67, 68, 69, 
	70, 71, 66, 67, 68, 69, 70, 71, 
	65, 65, 65, 65, 65, 65, 1, 72, 
	1, 73, 73, 1, 73, 73, 65, 65, 
	65, 66, 67, 68, 69, 70, 71, 66, 
	67, 68, 69, 70, 71, 65, 65, 65, 
	65, 65, 65, 1, 20, 74, 74, 74, 
	75, 74, 74, 74, 74, 74, 74, 1, 
	65, 65, 65, 66, 67, 68, 69, 70, 
	71, 66, 67, 68, 69, 70, 71, 65, 
	65, 65, 65, 65, 65, 1, 20, 74, 
	74, 74, 75, 76, 76, 74, 74, 74, 
	74, 74, 74, 1, 20, 74, 74, 74, 
	75, 77, 77, 74, 74, 74, 74, 74, 
	74, 1, 20, 74, 74, 74, 75, 78, 
	78, 74, 74, 74, 74, 74, 74, 1, 
	20, 74, 74, 74, 75, 79, 79, 74, 
	74, 74, 74, 74, 74, 1, 20, 74, 
	74, 74, 75, 80, 80, 74, 74, 74, 
	74, 74, 74, 1, 20, 74, 74, 74, 
	75, 81, 81, 74, 74, 74, 74, 74, 
	74, 1, 20, 74, 74, 74, 75, 82, 
	82, 74, 74, 74, 74, 74, 74, 1, 
	20, 75, 1, 20, 74, 74, 74, 75, 
	83, 84, 83, 84, 74, 74, 74, 74, 
	74, 74, 1, 20, 74, 74, 74, 75, 
	85, 85, 74, 74, 74, 74, 74, 74, 
	1, 20, 74, 74, 74, 75, 86, 86, 
	74, 74, 74, 74, 74, 74, 1, 20, 
	74, 74, 74, 75, 87, 87, 74, 74, 
	74, 74, 74, 74, 1, 20, 74, 74, 
	74, 75, 82, 82, 74, 74, 74, 74, 
	74, 74, 1, 20, 74, 74, 74, 75, 
	88, 88, 74, 74, 74, 74, 74, 74, 
	1, 20, 74, 74, 74, 75, 89, 89, 
	74, 74, 74, 74, 74, 74, 1, 20, 
	74, 74, 74, 75, 90, 90, 74, 74, 
	74, 74, 74, 74, 1, 20, 74, 74, 
	74, 75, 91, 91, 74, 74, 74, 74, 
	74, 74, 1, 20, 74, 74, 74, 75, 
	82, 82, 74, 74, 74, 74, 74, 74, 
	1, 20, 74, 74, 74, 75, 82, 82, 
	74, 74, 74, 74, 74, 74, 1, 20, 
	74, 74, 74, 75, 92, 92, 74, 74, 
	74, 74, 74, 74, 1, 20, 74, 74, 
	74, 75, 93, 93, 74, 74, 74, 74, 
	74, 74, 1, 20, 74, 74, 74, 75, 
	82, 82, 74, 74, 74, 74, 74, 74, 
	1, 20, 74, 74, 74, 75, 94, 94, 
	74, 74, 74, 74, 74, 74, 1, 20, 
	74, 74, 74, 75, 95, 95, 74, 74, 
	74, 74, 74, 74, 1, 20, 74, 74, 
	74, 75, 96, 96, 74, 74, 74, 74, 
	74, 74, 1, 20, 74, 74, 74, 75, 
	97, 97, 74, 74, 74, 74, 74, 74, 
	1, 20, 74, 74, 74, 75, 98, 98, 
	74, 74, 74, 74, 74, 74, 1, 20, 
	74, 74, 74, 75, 82, 82, 74, 74, 
	74, 74, 74, 74, 1, 20, 74, 74, 
	74, 75, 86, 86, 74, 74, 74, 74, 
	74, 74, 1, 99, 99, 1, 100, 100, 
	1, 101, 101, 1, 102, 102, 1, 103, 
	103, 1, 104, 104, 1, 105, 105, 106, 
	1, 107, 107, 25, 1, 108, 108, 1, 
	109, 109, 1, 110, 110, 1, 111, 111, 
	1, 112, 112, 1, 113, 113, 1, 114, 
	114, 1, 2, 2, 1, 1, 0
];

_tsip_machine_parser_header_Allow_trans_targs = [
	2, 0, 37, 38, 81, 89, 25, 3, 
	4, 5, 6, 7, 19, 8, 7, 8, 
	9, 10, 97, 11, 9, 10, 15, 11, 
	12, 15, 13, 14, 16, 17, 18, 20, 
	21, 22, 23, 24, 26, 27, 26, 27, 
	28, 31, 29, 30, 32, 31, 27, 36, 
	32, 33, 34, 35, 7, 8, 39, 40, 
	41, 42, 43, 44, 45, 46, 45, 46, 
	47, 50, 52, 60, 70, 71, 74, 80, 
	48, 49, 50, 51, 53, 54, 55, 56, 
	57, 58, 59, 61, 65, 62, 63, 64, 
	66, 67, 68, 69, 72, 73, 75, 76, 
	77, 78, 79, 82, 83, 84, 85, 86, 
	87, 88, 15, 88, 90, 91, 92, 93, 
	94, 95, 96
];

_tsip_machine_parser_header_Allow_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 5, 0, 5, 0, 0, 
	0, 1, 15, 3, 3, 0, 3, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 7, 7, 0, 0, 
	0, 1, 0, 0, 3, 0, 3, 0, 
	0, 0, 0, 0, 13, 13, 0, 0, 
	0, 0, 0, 0, 9, 9, 0, 0, 
	0, 1, 1, 1, 1, 1, 1, 1, 
	0, 0, 0, 3, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 11, 11, 0, 0, 0, 0, 0, 
	0, 0, 0
];

tsip_machine_parser_header_Allow_start = 1;
tsip_machine_parser_header_Allow_first_final = 97;
tsip_machine_parser_header_Allow_error = 0;

tsip_machine_parser_header_Allow_en_main = 1;


/* line 64 "./ragel/tsip_parser_header_StrArray.jrl" */

function tsip_header_StrArray(e_type, s_value){
	tsip_header.call(this, e_type);
    this.as_values = new Array();
	if(s_value){
		this.as_values.push(s_value);
	}
}

tsip_header_StrArray.prototype.toString = function(){
    var s_str = null;
	var c_sep;
	switch(this.e_type){
		case tsip_header_type_e.Privacy:
			c_sep = ';'; break;
		default: 
			c_sep = ','; 
		break;
	}
    for(var i = 0; i < this.as_values.length; ++i){
        if(i == 0){
            s_str = this.as_values[i];
        }
        else{
            s_str += tsk_string_format("{0}{1}", c_sep, this.as_values[i]);
        }
    }
    return s_str;
};

tsip_header_StrArray.prototype.has_value = function(s_value){
    if(this.as_values && s_value){
        var s_value_i = s_value.toLowerCase();
        for(var i = 0; i < this.as_values.length; ++i){
            if(this.as_values[i].toLowerCase() == s_value_i){
                return true;
            }
        }
    }
    return false;
}

tsip_header_StrArray.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var o_hdr = null;
	
	
/* line 406 "./src/headers/tsip_header_StrArray.js" */
{
	 cs = tsip_machine_parser_header_Allow_start;
} /* JSCodeGen::writeInit */

/* line 116 "./ragel/tsip_parser_header_StrArray.jrl" */
	
/* line 413 "./src/headers/tsip_header_StrArray.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_Allow_key_offsets[cs];
	_trans = _tsip_machine_parser_header_Allow_index_offsets[cs];
	_klen = _tsip_machine_parser_header_Allow_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_Allow_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_Allow_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_Allow_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_Allow_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_Allow_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_Allow_indicies[_trans];
	cs = _tsip_machine_parser_header_Allow_trans_targs[_trans];
	if (_tsip_machine_parser_header_Allow_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_Allow_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_Allow_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_Allow_actions[_acts - 1]) {
case 0:
/* line 26 "./ragel/tsip_parser_header_StrArray.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 30 "./ragel/tsip_parser_header_StrArray.jrl" */

		if(o_hdr){
			tsk_ragel_parser_add_string(s_str, p, i_tag_start, o_hdr.as_values);
		}
			break;
case 2:
/* line 36 "./ragel/tsip_parser_header_StrArray.jrl" */
 o_hdr = new tsip_header_Allow(); 		break;
case 3:
/* line 37 "./ragel/tsip_parser_header_StrArray.jrl" */
 o_hdr = new tsip_header_Allow_Events(); 		break;
case 4:
/* line 38 "./ragel/tsip_parser_header_StrArray.jrl" */
 o_hdr = new tsip_header_Privacy(); 		break;
case 5:
/* line 39 "./ragel/tsip_parser_header_StrArray.jrl" */
 o_hdr = new tsip_header_Require(); 		break;
case 6:
/* line 40 "./ragel/tsip_parser_header_StrArray.jrl" */
 o_hdr = new tsip_header_Supported(); 		break;
case 7:
/* line 42 "./ragel/tsip_parser_header_StrArray.jrl" */
		break;
/* line 527 "./src/headers/tsip_header_StrArray.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 117 "./ragel/tsip_parser_header_StrArray.jrl" */
	
	if( cs < 
/* line 557 "./src/headers/tsip_header_StrArray.js" */
97
/* line 118 "./ragel/tsip_parser_header_StrArray.jrl" */
 ){
		tsk_utils_log_error("Failed to parse header: " + s_str);
		return null;
	}
	
	return o_hdr;
}


function tsip_header_Allow(s_value){ tsip_header_StrArray.call(this, tsip_header_type_e.Allow, s_value); }
function tsip_header_Allow_Events(s_value){ tsip_header_StrArray.call(this, tsip_header_type_e.Allow_Events, s_value); }
function tsip_header_Privacy(s_value){ tsip_header_StrArray.call(this, tsip_header_type_e.Privacy, s_value); }
function tsip_header_Require(s_value){ tsip_header_StrArray.call(this, tsip_header_type_e.Require, s_value); }
function tsip_header_Supported(s_value){ tsip_header_StrArray.call(this, tsip_header_type_e.Supported, s_value); }

/* line 1 "./ragel/tsip_parser_header_Authorization.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_Authorization.prototype = Object.create(tsip_header.prototype);

function tsip_header_Authorization(){
	tsip_header.call(this, tsip_header_type_e.Authorization);
	this.s_scheme = null;
	this.s_username = null;
	this.s_realm = null;
	this.s_nonce = null;
	this.s_uri = null;
	this.s_response = null;
	this.s_algorithm = null;
	this.s_cnonce = null;
	this.s_opaque = null;
	this.s_qop = null;
	this.s_nc = null; 
}

tsip_header_Authorization.prototype.toString = function(){
    if(tsk_string_iequals(this.s_scheme, "Basic")){
		return tsk_string_format("{0} {1}", this.s_scheme, this.s_response);
	}
	else{
        // nonce and response could be empty for IMS auth: https://code.google.com/p/sipml5/issues/detail?id=120 
		return tsk_string_format("{0} {1}{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}{16}{17}{18}{19}{20}{21}{22}{23}{24}{25}{26}{27}", 
			this.s_scheme,

			this.s_username ? "username=\"" : "",
			this.s_username ? this.s_username : "",
			this.s_username ? "\"" : "",

			this.s_realm ? ",realm=\"" : "",
			this.s_realm ? this.s_realm : "",
			this.s_realm ? "\"" : "",

			(this.s_nonce || this.s_nonce==="") ? ",nonce=\"" : "",
			(this.s_nonce || this.s_nonce==="") ? this.s_nonce : "",
			(this.s_nonce || this.s_nonce==="") ? "\"" : "",

			this.s_uri ? ",uri=\"" : "",
			this.s_uri ? this.s_uri : "",
			this.s_uri ? "\"" : "",
					
			(this.s_response || this.s_response==="") ? ",response=\"" : "",
			(this.s_response || this.s_response==="") ? this.s_response : "",
			(this.s_response || this.s_response==="") ? "\"" : "",
					
			this.s_algorithm ? ",algorithm=" : "",
			this.s_algorithm ? this.s_algorithm : "",

			this.s_cnonce ? ",cnonce=\"" : "",
			this.s_cnonce ? this.s_cnonce : "",
			this.s_cnonce ? "\"" : "",

			this.s_opaque ? ",opaque=\"" : "",
			this.s_opaque ? this.s_opaque : "",
			this.s_opaque ? "\"" : "",

			this.s_qop ? ",qop=" : "",
			this.s_qop ? this.s_qop : "",

			this.s_nc ? ",nc=" : "",
			this.s_nc ? this.s_nc : ""
			);
	}
}


/* line 1 "./ragel/tsip_parser_header_Contact.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_Contact.prototype = Object.create(tsip_header.prototype);

/* line 74 "./ragel/tsip_parser_header_Contact.jrl" */




/* line 16 "./src/headers/tsip_header_Contact.js" */
_tsip_machine_parser_header_Contact_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 2, 1, 0, 2, 3, 6, 2, 
	4, 6, 2, 5, 6
];

_tsip_machine_parser_header_Contact_key_offsets = [
	0, 0, 4, 6, 8, 10, 12, 14, 
	16, 19, 40, 41, 43, 64, 65, 67, 
	71, 74, 75, 79, 91, 94, 96, 99, 
	104, 109, 110, 112, 116, 137, 138, 140, 
	161, 162, 164, 167, 184, 202, 206, 207, 
	209, 217, 218, 220, 224, 230, 250, 269, 
	274, 276, 283, 302, 303, 305, 323, 341, 
	347, 348, 350, 355, 374, 375, 377, 396, 
	397, 399, 402, 410, 411, 413, 418, 424, 
	441, 448, 456, 464, 472, 474, 481, 490, 
	492, 495, 497, 500, 502, 505, 508, 509, 
	512, 513, 516, 517, 526, 535, 543, 551, 
	559, 567, 569, 575, 584, 593, 602, 604, 
	607, 610, 611, 612, 632, 652, 672, 692, 
	712, 732, 750, 756, 757, 759, 764, 783, 
	784, 786, 805, 812, 829, 847, 851
];

_tsip_machine_parser_header_Contact_trans_keys = [
	67, 77, 99, 109, 79, 111, 78, 110, 
	84, 116, 65, 97, 67, 99, 84, 116, 
	9, 32, 58, 9, 13, 32, 33, 34, 
	37, 39, 42, 43, 60, 126, 45, 46, 
	48, 57, 65, 90, 95, 96, 97, 122, 
	10, 9, 32, 9, 13, 32, 33, 34, 
	37, 39, 42, 43, 60, 126, 45, 46, 
	48, 57, 65, 90, 95, 96, 97, 122, 
	10, 9, 32, 9, 32, 42, 60, 9, 
	13, 32, 10, 65, 90, 97, 122, 9, 
	32, 43, 58, 45, 46, 48, 57, 65, 
	90, 97, 122, 9, 32, 58, 0, 65535, 
	62, 0, 65535, 9, 13, 32, 44, 59, 
	9, 13, 32, 44, 59, 10, 9, 32, 
	9, 32, 44, 59, 9, 13, 32, 33, 
	34, 37, 39, 60, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 96, 97, 
	122, 10, 9, 32, 9, 13, 32, 33, 
	34, 37, 39, 60, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 96, 97, 
	122, 10, 9, 32, 9, 32, 60, 9, 
	13, 32, 33, 37, 39, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 33, 37, 39, 60, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 60, 10, 9, 
	32, 9, 13, 34, 92, 32, 126, 128, 
	255, 10, 9, 32, 9, 13, 32, 60, 
	0, 9, 11, 12, 14, 127, 9, 13, 
	32, 33, 37, 39, 42, 43, 58, 126, 
	45, 46, 48, 57, 65, 90, 95, 96, 
	97, 122, 9, 13, 32, 33, 37, 39, 
	58, 60, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	58, 60, 0, 65535, 9, 13, 32, 44, 
	59, 0, 65535, 9, 13, 32, 33, 37, 
	39, 69, 101, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 10, 9, 
	32, 9, 32, 33, 37, 39, 69, 101, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 44, 59, 61, 126, 42, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	44, 59, 61, 10, 9, 32, 9, 32, 
	44, 59, 61, 9, 13, 32, 33, 34, 
	37, 39, 91, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 10, 9, 
	32, 9, 13, 32, 33, 34, 37, 39, 
	91, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 10, 9, 32, 9, 
	32, 34, 9, 13, 34, 92, 32, 126, 
	128, 255, 10, 9, 32, 9, 13, 32, 
	44, 59, 0, 9, 11, 12, 14, 127, 
	9, 13, 32, 33, 37, 39, 44, 59, 
	126, 42, 46, 48, 57, 65, 90, 95, 
	122, 58, 48, 57, 65, 70, 97, 102, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	58, 93, 58, 48, 57, 65, 70, 97, 
	102, 46, 58, 93, 48, 57, 65, 70, 
	97, 102, 48, 57, 46, 48, 57, 48, 
	57, 46, 48, 57, 48, 57, 93, 48, 
	57, 93, 48, 57, 93, 46, 48, 57, 
	46, 46, 48, 57, 46, 46, 58, 93, 
	48, 57, 65, 70, 97, 102, 46, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 46, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 46, 58, 93, 48, 57, 65, 70, 
	97, 102, 48, 57, 46, 48, 57, 46, 
	48, 57, 46, 58, 9, 13, 32, 33, 
	37, 39, 44, 59, 61, 88, 120, 126, 
	42, 46, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 33, 37, 39, 44, 59, 
	61, 80, 112, 126, 42, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 44, 59, 61, 73, 105, 126, 
	42, 46, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 33, 37, 39, 44, 59, 
	61, 82, 114, 126, 42, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 44, 59, 61, 69, 101, 126, 
	42, 46, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 33, 37, 39, 44, 59, 
	61, 83, 115, 126, 42, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 44, 59, 61, 126, 42, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 44, 59, 61, 10, 9, 32, 9, 
	32, 44, 59, 61, 9, 13, 32, 33, 
	34, 37, 39, 91, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 10, 
	9, 32, 9, 13, 32, 33, 34, 37, 
	39, 91, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	44, 59, 48, 57, 9, 13, 32, 33, 
	37, 39, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 60, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 60, 0
];

_tsip_machine_parser_header_Contact_single_lengths = [
	0, 4, 2, 2, 2, 2, 2, 2, 
	3, 11, 1, 2, 11, 1, 2, 4, 
	3, 1, 0, 4, 3, 0, 1, 5, 
	5, 1, 2, 4, 9, 1, 2, 9, 
	1, 2, 3, 7, 8, 4, 1, 2, 
	4, 1, 2, 4, 0, 10, 9, 5, 
	0, 5, 9, 1, 2, 8, 10, 6, 
	1, 2, 5, 9, 1, 2, 9, 1, 
	2, 3, 4, 1, 2, 5, 0, 9, 
	1, 2, 2, 2, 2, 1, 3, 0, 
	1, 0, 1, 0, 1, 1, 1, 1, 
	1, 1, 1, 3, 3, 2, 2, 2, 
	2, 2, 0, 3, 3, 3, 0, 1, 
	1, 1, 1, 12, 12, 12, 12, 12, 
	12, 10, 6, 1, 2, 5, 9, 1, 
	2, 9, 5, 7, 8, 4, 0
];

_tsip_machine_parser_header_Contact_range_lengths = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 5, 0, 0, 5, 0, 0, 0, 
	0, 0, 2, 4, 0, 1, 1, 0, 
	0, 0, 0, 0, 6, 0, 0, 6, 
	0, 0, 0, 5, 5, 0, 0, 0, 
	2, 0, 0, 0, 3, 5, 5, 0, 
	1, 1, 5, 0, 0, 5, 4, 0, 
	0, 0, 0, 5, 0, 0, 5, 0, 
	0, 0, 2, 0, 0, 0, 3, 4, 
	3, 3, 3, 3, 0, 3, 3, 1, 
	1, 1, 1, 1, 1, 1, 0, 1, 
	0, 1, 0, 3, 3, 3, 3, 3, 
	3, 0, 3, 3, 3, 3, 1, 1, 
	1, 0, 0, 4, 4, 4, 4, 4, 
	4, 4, 0, 0, 0, 0, 5, 0, 
	0, 5, 1, 5, 5, 0, 0
];

_tsip_machine_parser_header_Contact_index_offsets = [
	0, 0, 5, 8, 11, 14, 17, 20, 
	23, 27, 44, 46, 49, 66, 68, 71, 
	76, 80, 82, 85, 94, 98, 100, 103, 
	109, 115, 117, 120, 125, 141, 143, 146, 
	162, 164, 167, 171, 184, 198, 203, 205, 
	208, 215, 217, 220, 225, 229, 245, 260, 
	266, 268, 275, 290, 292, 295, 309, 324, 
	331, 333, 336, 342, 357, 359, 362, 377, 
	379, 382, 386, 393, 395, 398, 404, 408, 
	422, 427, 433, 439, 445, 448, 453, 460, 
	462, 465, 467, 470, 472, 475, 478, 480, 
	483, 485, 488, 490, 497, 504, 510, 516, 
	522, 528, 531, 535, 542, 549, 556, 558, 
	561, 564, 566, 568, 585, 602, 619, 636, 
	653, 670, 685, 692, 694, 697, 703, 718, 
	720, 723, 738, 745, 758, 772, 777
];

_tsip_machine_parser_header_Contact_indicies = [
	0, 2, 0, 2, 1, 3, 3, 1, 
	4, 4, 1, 5, 5, 1, 6, 6, 
	1, 7, 7, 1, 2, 2, 1, 2, 
	2, 8, 1, 9, 10, 9, 11, 12, 
	11, 11, 13, 11, 14, 11, 11, 11, 
	15, 11, 15, 1, 16, 1, 17, 17, 
	1, 18, 19, 18, 11, 12, 11, 11, 
	13, 11, 14, 11, 11, 11, 15, 11, 
	15, 1, 20, 1, 21, 21, 1, 21, 
	21, 22, 23, 1, 22, 24, 22, 1, 
	25, 1, 26, 26, 1, 27, 27, 28, 
	29, 28, 28, 28, 28, 1, 27, 27, 
	29, 1, 30, 1, 31, 30, 1, 32, 
	33, 32, 34, 35, 1, 36, 37, 36, 
	38, 35, 1, 39, 1, 40, 40, 1, 
	40, 40, 38, 35, 1, 41, 42, 41, 
	11, 12, 11, 11, 14, 11, 11, 11, 
	11, 15, 11, 15, 1, 43, 1, 44, 
	44, 1, 45, 46, 45, 11, 12, 11, 
	11, 14, 11, 11, 11, 11, 15, 11, 
	15, 1, 47, 1, 48, 48, 1, 48, 
	48, 23, 1, 49, 50, 49, 51, 51, 
	51, 51, 51, 51, 51, 51, 51, 1, 
	52, 53, 52, 51, 51, 51, 54, 51, 
	51, 51, 51, 51, 51, 1, 55, 56, 
	55, 23, 1, 57, 1, 49, 49, 1, 
	58, 59, 60, 61, 58, 58, 1, 62, 
	1, 58, 58, 1, 52, 53, 52, 54, 
	1, 58, 58, 58, 1, 63, 50, 63, 
	51, 51, 51, 51, 64, 65, 51, 64, 
	64, 64, 51, 64, 1, 66, 53, 66, 
	51, 51, 51, 65, 54, 51, 51, 51, 
	51, 51, 51, 1, 67, 56, 67, 65, 
	23, 1, 68, 1, 69, 70, 69, 71, 
	72, 68, 1, 35, 73, 35, 74, 74, 
	74, 75, 75, 74, 74, 74, 74, 74, 
	74, 1, 76, 1, 77, 77, 1, 77, 
	77, 74, 74, 74, 75, 75, 74, 74, 
	74, 74, 74, 74, 1, 78, 79, 78, 
	80, 80, 80, 81, 82, 83, 80, 80, 
	80, 80, 80, 1, 84, 85, 84, 38, 
	35, 83, 1, 86, 1, 87, 87, 1, 
	87, 87, 38, 35, 83, 1, 83, 88, 
	83, 89, 90, 89, 89, 91, 89, 89, 
	89, 89, 89, 89, 1, 92, 1, 93, 
	93, 1, 93, 94, 93, 89, 90, 89, 
	89, 91, 89, 89, 89, 89, 89, 89, 
	1, 95, 1, 96, 96, 1, 96, 96, 
	90, 1, 90, 97, 98, 99, 90, 90, 
	1, 100, 1, 90, 90, 1, 101, 79, 
	101, 81, 82, 1, 90, 90, 90, 1, 
	101, 79, 101, 89, 89, 89, 81, 82, 
	89, 89, 89, 89, 89, 1, 103, 102, 
	102, 102, 1, 105, 98, 104, 104, 104, 
	1, 105, 98, 106, 106, 106, 1, 105, 
	98, 107, 107, 107, 1, 105, 98, 1, 
	109, 108, 102, 102, 1, 110, 105, 98, 
	111, 104, 104, 1, 112, 1, 113, 114, 
	1, 115, 1, 116, 117, 1, 118, 1, 
	98, 119, 1, 98, 120, 1, 98, 1, 
	116, 121, 1, 116, 1, 113, 122, 1, 
	113, 1, 110, 105, 98, 123, 106, 106, 
	1, 110, 105, 98, 107, 107, 107, 1, 
	125, 98, 124, 124, 124, 1, 127, 98, 
	126, 126, 126, 1, 127, 98, 128, 128, 
	128, 1, 127, 98, 129, 129, 129, 1, 
	127, 98, 1, 130, 124, 124, 1, 110, 
	127, 98, 131, 126, 126, 1, 110, 127, 
	98, 132, 128, 128, 1, 110, 127, 98, 
	129, 129, 129, 1, 133, 1, 110, 134, 
	1, 110, 135, 1, 110, 1, 109, 1, 
	78, 79, 78, 80, 80, 80, 81, 82, 
	83, 136, 136, 80, 80, 80, 80, 80, 
	1, 78, 79, 78, 80, 80, 80, 81, 
	82, 83, 137, 137, 80, 80, 80, 80, 
	80, 1, 78, 79, 78, 80, 80, 80, 
	81, 82, 83, 138, 138, 80, 80, 80, 
	80, 80, 1, 78, 79, 78, 80, 80, 
	80, 81, 82, 83, 139, 139, 80, 80, 
	80, 80, 80, 1, 78, 79, 78, 80, 
	80, 80, 81, 82, 83, 140, 140, 80, 
	80, 80, 80, 80, 1, 78, 79, 78, 
	80, 80, 80, 81, 82, 83, 141, 141, 
	80, 80, 80, 80, 80, 1, 142, 79, 
	142, 80, 80, 80, 81, 82, 143, 80, 
	80, 80, 80, 80, 1, 144, 145, 144, 
	38, 35, 143, 1, 146, 1, 147, 147, 
	1, 147, 147, 38, 35, 143, 1, 143, 
	148, 143, 89, 90, 89, 89, 91, 89, 
	89, 89, 149, 89, 89, 1, 150, 1, 
	151, 151, 1, 151, 94, 151, 89, 90, 
	89, 89, 91, 89, 89, 89, 149, 89, 
	89, 1, 152, 153, 152, 154, 156, 155, 
	1, 157, 24, 157, 51, 51, 51, 51, 
	51, 51, 51, 51, 51, 1, 158, 24, 
	158, 51, 51, 51, 54, 51, 51, 51, 
	51, 51, 51, 1, 159, 24, 159, 23, 
	1, 1, 0
];

_tsip_machine_parser_header_Contact_trans_targs = [
	2, 0, 8, 3, 4, 5, 6, 7, 
	9, 9, 10, 35, 40, 123, 18, 45, 
	11, 12, 12, 13, 14, 15, 16, 18, 
	17, 126, 19, 20, 19, 21, 22, 23, 
	24, 17, 28, 50, 24, 25, 28, 26, 
	27, 28, 29, 30, 31, 31, 32, 33, 
	34, 36, 38, 35, 37, 32, 18, 37, 
	32, 39, 40, 41, 43, 44, 42, 46, 
	45, 48, 47, 47, 49, 24, 17, 28, 
	50, 51, 54, 107, 52, 53, 55, 17, 
	54, 28, 50, 59, 55, 56, 57, 58, 
	60, 71, 66, 72, 61, 62, 63, 64, 
	65, 67, 69, 70, 68, 24, 73, 106, 
	74, 77, 75, 76, 78, 93, 79, 91, 
	80, 81, 89, 82, 83, 87, 84, 85, 
	86, 88, 90, 92, 94, 102, 95, 98, 
	96, 97, 99, 100, 101, 103, 104, 105, 
	108, 109, 110, 111, 112, 113, 114, 118, 
	114, 115, 116, 117, 119, 122, 120, 121, 
	24, 17, 28, 122, 50, 124, 125, 125
];

_tsip_machine_parser_header_Contact_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 3, 3, 17, 17, 17, 3, 17, 
	0, 0, 3, 3, 0, 0, 0, 0, 
	0, 15, 1, 0, 0, 0, 0, 7, 
	13, 13, 13, 0, 0, 0, 0, 0, 
	0, 3, 3, 0, 0, 3, 3, 0, 
	0, 0, 0, 0, 5, 5, 5, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 5, 0, 0, 20, 20, 20, 
	7, 0, 1, 1, 0, 0, 26, 26, 
	0, 26, 11, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 26, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 26, 0, 
	0, 0, 0, 0, 0, 1, 0, 0, 
	23, 23, 23, 0, 9, 0, 5, 0
];

tsip_machine_parser_header_Contact_start = 1;
tsip_machine_parser_header_Contact_first_final = 126;
tsip_machine_parser_header_Contact_error = 0;

tsip_machine_parser_header_Contact_en_main = 1;


/* line 78 "./ragel/tsip_parser_header_Contact.jrl" */

function tsip_header_Contact(){
	tsip_header.call(this, tsip_header_type_e.Contact);
    this.s_display_name = null;
    this.o_uri = null;
    this.i_expires = -1;
}

tsip_header_Contact.prototype.toString = function(){
    var s_str = tsip_uri_tostring(this.o_uri, true, true);
    if(s_str && this.i_expires >= 0){
        s_str += tsk_string_format(";expires={0}", this.i_expires);
    }
    return s_str;
}

// returns an array of 'Contact' headers
tsip_header_Contact.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_i_tag_start;
	var hdr_contacts = new Array();
	var curr_contact = null;
	
	
/* line 393 "./src/headers/tsip_header_Contact.js" */
{
	 cs = tsip_machine_parser_header_Contact_start;
} /* JSCodeGen::writeInit */

/* line 106 "./ragel/tsip_parser_header_Contact.jrl" */
	
/* line 400 "./src/headers/tsip_header_Contact.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_Contact_key_offsets[cs];
	_trans = _tsip_machine_parser_header_Contact_index_offsets[cs];
	_klen = _tsip_machine_parser_header_Contact_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_Contact_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_Contact_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_Contact_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_Contact_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_Contact_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_Contact_indicies[_trans];
	cs = _tsip_machine_parser_header_Contact_trans_targs[_trans];
	if (_tsip_machine_parser_header_Contact_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_Contact_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_Contact_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_Contact_actions[_acts - 1]) {
case 0:
/* line 13 "./ragel/tsip_parser_header_Contact.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 17 "./ragel/tsip_parser_header_Contact.jrl" */

		if(!curr_contact){
			curr_contact = new tsip_header_Contact();
		}
			break;
case 2:
/* line 23 "./ragel/tsip_parser_header_Contact.jrl" */

		if(curr_contact){
		    curr_contact.s_display_name = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
            curr_contact.s_display_name = tsk_string_unquote_2(curr_contact.s_display_name);
		}
			break;
case 3:
/* line 30 "./ragel/tsip_parser_header_Contact.jrl" */

		if(curr_contact && !curr_contact.o_uri){
		    var s_uri = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			if((curr_contact.o_uri = tsip_uri.prototype.Parse(s_uri)) && curr_contact.s_display_name){
				curr_contact.o_uri.s_display_name = tsk_strdup(curr_contact.s_display_name);
			}
		}
			break;
case 4:
/* line 39 "./ragel/tsip_parser_header_Contact.jrl" */

		if(curr_contact){
		    curr_contact.i_expires = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
		}
			break;
case 5:
/* line 45 "./ragel/tsip_parser_header_Contact.jrl" */

		if(curr_contact){
		    tsk_ragel_add_param(s_str, p, i_tag_start, curr_contact.ao_params);
		}
			break;
case 6:
/* line 51 "./ragel/tsip_parser_header_Contact.jrl" */

		if(curr_contact){
		    hdr_contacts.push(curr_contact);
		    curr_contact = null;
		}
			break;
case 7:
/* line 58 "./ragel/tsip_parser_header_Contact.jrl" */

			break;
/* line 540 "./src/headers/tsip_header_Contact.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 107 "./ragel/tsip_parser_header_Contact.jrl" */
	
	if( cs < 
/* line 570 "./src/headers/tsip_header_Contact.js" */
126
/* line 108 "./ragel/tsip_parser_header_Contact.jrl" */
 ){
		tsk_utils_log_error("Failed to parse 'Contact' header: " + s_str);
		return null;
	}
	
	return hdr_contacts;
}


/* line 1 "./ragel/tsip_parser_header_Content_Type.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_Content_Type.prototype = Object.create(tsip_header.prototype);

/* line 46 "./ragel/tsip_parser_header_Content_Type.jrl" */




/* line 16 "./src/headers/tsip_header_Content_Type.js" */
_tsip_machine_parser_header_Content_Type_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3
];

_tsip_machine_parser_header_Content_Type_key_offsets = [
	0, 0, 2, 7, 10, 27, 28, 30, 
	46, 62, 66, 67, 69, 72, 89, 90, 
	92, 108, 126, 130, 131, 133, 136, 153, 
	154, 156, 172, 190, 194, 195, 197, 200, 
	218, 219, 221, 239, 240, 242, 245, 253, 
	254, 256, 260, 261, 267, 285, 287, 289, 
	291, 293, 295, 296, 298, 300, 302, 304
];

_tsip_machine_parser_header_Content_Type_trans_keys = [
	67, 99, 9, 32, 58, 79, 111, 9, 
	32, 58, 9, 13, 32, 33, 37, 39, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 10, 9, 32, 9, 32, 
	33, 37, 39, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 33, 37, 39, 47, 126, 42, 43, 
	45, 57, 65, 90, 95, 122, 9, 13, 
	32, 47, 10, 9, 32, 9, 32, 47, 
	9, 13, 32, 33, 37, 39, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 10, 9, 32, 9, 32, 33, 37, 
	39, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 59, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 59, 10, 9, 32, 9, 32, 59, 
	9, 13, 32, 33, 37, 39, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 10, 9, 32, 9, 32, 33, 37, 
	39, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 61, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 61, 10, 9, 32, 9, 32, 61, 
	9, 13, 32, 33, 34, 37, 39, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 10, 9, 32, 9, 13, 32, 
	33, 34, 37, 39, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 10, 
	9, 32, 9, 32, 34, 9, 13, 34, 
	92, 32, 126, 128, 255, 10, 9, 32, 
	9, 13, 32, 59, 10, 0, 9, 11, 
	12, 14, 127, 9, 13, 32, 33, 37, 
	39, 59, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 78, 110, 84, 
	116, 69, 101, 78, 110, 84, 116, 45, 
	84, 116, 89, 121, 80, 112, 69, 101, 
	0
];

_tsip_machine_parser_header_Content_Type_single_lengths = [
	0, 2, 5, 3, 7, 1, 2, 6, 
	8, 4, 1, 2, 3, 7, 1, 2, 
	6, 8, 4, 1, 2, 3, 7, 1, 
	2, 6, 8, 4, 1, 2, 3, 8, 
	1, 2, 8, 1, 2, 3, 4, 1, 
	2, 4, 1, 0, 8, 2, 2, 2, 
	2, 2, 1, 2, 2, 2, 2, 0
];

_tsip_machine_parser_header_Content_Type_range_lengths = [
	0, 0, 0, 0, 5, 0, 0, 5, 
	4, 0, 0, 0, 0, 5, 0, 0, 
	5, 5, 0, 0, 0, 0, 5, 0, 
	0, 5, 5, 0, 0, 0, 0, 5, 
	0, 0, 5, 0, 0, 0, 2, 0, 
	0, 0, 0, 3, 5, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0
];

_tsip_machine_parser_header_Content_Type_index_offsets = [
	0, 0, 3, 9, 13, 26, 28, 31, 
	43, 56, 61, 63, 66, 70, 83, 85, 
	88, 100, 114, 119, 121, 124, 128, 141, 
	143, 146, 158, 172, 177, 179, 182, 186, 
	200, 202, 205, 219, 221, 224, 228, 235, 
	237, 240, 245, 247, 251, 265, 268, 271, 
	274, 277, 280, 282, 285, 288, 291, 294
];

_tsip_machine_parser_header_Content_Type_indicies = [
	0, 0, 1, 2, 2, 3, 4, 4, 
	1, 2, 2, 3, 1, 3, 5, 3, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 1, 7, 1, 8, 8, 1, 8, 
	8, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 1, 9, 10, 9, 11, 11, 
	11, 12, 11, 11, 11, 11, 11, 1, 
	9, 10, 9, 12, 1, 13, 1, 14, 
	14, 1, 14, 14, 12, 1, 12, 15, 
	12, 16, 16, 16, 16, 16, 16, 16, 
	16, 16, 1, 17, 1, 18, 18, 1, 
	18, 18, 16, 16, 16, 16, 16, 16, 
	16, 16, 16, 1, 19, 20, 19, 16, 
	16, 16, 21, 16, 16, 16, 16, 16, 
	16, 1, 22, 23, 22, 24, 1, 25, 
	1, 26, 26, 1, 26, 26, 24, 1, 
	24, 27, 24, 28, 28, 28, 28, 28, 
	28, 28, 28, 28, 1, 29, 1, 30, 
	30, 1, 30, 30, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 1, 31, 32, 
	31, 33, 33, 33, 34, 33, 33, 33, 
	33, 33, 33, 1, 31, 32, 31, 34, 
	1, 35, 1, 36, 36, 1, 36, 36, 
	34, 1, 34, 37, 34, 38, 39, 38, 
	38, 38, 38, 38, 38, 38, 38, 1, 
	40, 1, 41, 41, 1, 41, 42, 41, 
	38, 39, 38, 38, 38, 38, 38, 38, 
	38, 38, 1, 43, 1, 44, 44, 1, 
	44, 44, 39, 1, 39, 45, 46, 47, 
	39, 39, 1, 48, 1, 39, 39, 1, 
	49, 50, 49, 51, 1, 52, 1, 39, 
	39, 39, 1, 49, 50, 49, 38, 38, 
	38, 51, 38, 38, 38, 38, 38, 38, 
	1, 53, 53, 1, 54, 54, 1, 55, 
	55, 1, 56, 56, 1, 57, 57, 1, 
	58, 1, 59, 59, 1, 60, 60, 1, 
	61, 61, 1, 2, 2, 1, 1, 0
];

_tsip_machine_parser_header_Content_Type_trans_targs = [
	2, 0, 3, 4, 45, 5, 8, 6, 
	7, 9, 10, 8, 13, 11, 12, 14, 
	17, 15, 16, 18, 42, 22, 18, 19, 
	22, 20, 21, 23, 26, 24, 25, 27, 
	28, 26, 31, 29, 30, 32, 44, 38, 
	33, 34, 35, 36, 37, 39, 41, 43, 
	40, 18, 42, 22, 55, 46, 47, 48, 
	49, 50, 51, 52, 53, 54
];

_tsip_machine_parser_header_Content_Type_trans_actions = [
	0, 0, 0, 0, 0, 0, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 3, 3, 3, 0, 0, 
	0, 0, 0, 0, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 5, 5, 5, 7, 0, 0, 0, 
	0, 0, 0, 0, 0, 0
];

tsip_machine_parser_header_Content_Type_start = 1;
tsip_machine_parser_header_Content_Type_first_final = 55;
tsip_machine_parser_header_Content_Type_error = 0;

tsip_machine_parser_header_Content_Type_en_main = 1;


/* line 50 "./ragel/tsip_parser_header_Content_Type.jrl" */

function tsip_header_Content_Type(s_type){
	tsip_header.call(this, tsip_header_type_e.Content_Type);
    this.s_type = s_type;
}

tsip_header_Content_Type.prototype.toString = function(){
    return this.s_type;
}

tsip_header_Content_Type.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_i_tag_start;	
	var hdr_ctype = new tsip_header_Content_Type(null);
	
	
/* line 194 "./src/headers/tsip_header_Content_Type.js" */
{
	 cs = tsip_machine_parser_header_Content_Type_start;
} /* JSCodeGen::writeInit */

/* line 70 "./ragel/tsip_parser_header_Content_Type.jrl" */
	
/* line 201 "./src/headers/tsip_header_Content_Type.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_Content_Type_key_offsets[cs];
	_trans = _tsip_machine_parser_header_Content_Type_index_offsets[cs];
	_klen = _tsip_machine_parser_header_Content_Type_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_Content_Type_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_Content_Type_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_Content_Type_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_Content_Type_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_Content_Type_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_Content_Type_indicies[_trans];
	cs = _tsip_machine_parser_header_Content_Type_trans_targs[_trans];
	if (_tsip_machine_parser_header_Content_Type_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_Content_Type_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_Content_Type_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_Content_Type_actions[_acts - 1]) {
case 0:
/* line 13 "./ragel/tsip_parser_header_Content_Type.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 17 "./ragel/tsip_parser_header_Content_Type.jrl" */

	    hdr_ctype.s_type = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 2:
/* line 21 "./ragel/tsip_parser_header_Content_Type.jrl" */

	    tsk_ragel_add_param(s_str, p, i_tag_start, hdr_ctype.ao_params);
			break;
case 3:
/* line 25 "./ragel/tsip_parser_header_Content_Type.jrl" */

			break;
/* line 304 "./src/headers/tsip_header_Content_Type.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 71 "./ragel/tsip_parser_header_Content_Type.jrl" */
	
	if( cs < 
/* line 334 "./src/headers/tsip_header_Content_Type.js" */
55
/* line 72 "./ragel/tsip_parser_header_Content_Type.jrl" */
 ){
		tsk_utils_log_error("Failed to parse 'Content-Type' header: " + s_str);
		return null;
	}
	
	return hdr_ctype;
}


/* line 1 "./ragel/tsip_parser_header_CSeq.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_CSeq.prototype = Object.create(tsip_header.prototype);

var TSIP_HEADER_CSEQ_NONE = 0;
var TSIP_HEADER_CSEQ_DEFAULT = 1;


/* line 38 "./ragel/tsip_parser_header_CSeq.jrl" */



/* line 19 "./src/headers/tsip_header_CSeq.js" */
_tsip_machine_parser_header_CSeq_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3
];

_tsip_machine_parser_header_CSeq_key_offsets = [
	0, 0, 2, 4, 6, 8, 11, 16, 
	17, 19, 23, 28, 45, 46, 48, 64, 
	79, 80
];

_tsip_machine_parser_header_CSeq_trans_keys = [
	67, 99, 83, 115, 69, 101, 81, 113, 
	9, 32, 58, 9, 13, 32, 48, 57, 
	10, 9, 32, 9, 32, 48, 57, 9, 
	13, 32, 48, 57, 9, 13, 32, 33, 
	37, 39, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 10, 9, 32, 
	9, 32, 33, 37, 39, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	13, 33, 37, 39, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 10, 
	0
];

_tsip_machine_parser_header_CSeq_single_lengths = [
	0, 2, 2, 2, 2, 3, 3, 1, 
	2, 2, 3, 7, 1, 2, 6, 5, 
	1, 0
];

_tsip_machine_parser_header_CSeq_range_lengths = [
	0, 0, 0, 0, 0, 0, 1, 0, 
	0, 1, 1, 5, 0, 0, 5, 5, 
	0, 0
];

_tsip_machine_parser_header_CSeq_index_offsets = [
	0, 0, 3, 6, 9, 12, 16, 21, 
	23, 26, 30, 35, 48, 50, 53, 65, 
	76, 78
];

_tsip_machine_parser_header_CSeq_indicies = [
	0, 0, 1, 2, 2, 1, 3, 3, 
	1, 4, 4, 1, 4, 4, 5, 1, 
	5, 6, 5, 7, 1, 8, 1, 9, 
	9, 1, 9, 9, 7, 1, 10, 11, 
	10, 12, 1, 13, 14, 13, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 1, 
	16, 1, 17, 17, 1, 17, 17, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 
	1, 18, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 1, 20, 1, 1, 0
];

_tsip_machine_parser_header_CSeq_trans_targs = [
	2, 0, 3, 4, 5, 6, 7, 10, 
	8, 9, 11, 12, 10, 11, 12, 15, 
	13, 14, 16, 15, 17
];

_tsip_machine_parser_header_CSeq_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 1, 
	0, 0, 5, 5, 0, 0, 0, 1, 
	0, 0, 3, 0, 7
];

tsip_machine_parser_header_CSeq_start = 1;
tsip_machine_parser_header_CSeq_first_final = 17;
tsip_machine_parser_header_CSeq_error = 0;

tsip_machine_parser_header_CSeq_en_main = 1;


/* line 41 "./ragel/tsip_parser_header_CSeq.jrl" */

function tsip_header_CSeq(i_seq, s_method){
	tsip_header.call(this, tsip_header_type_e.CSeq);
    this.i_seq = i_seq;
    this.s_method = s_method;
	if(s_method){
		this.e_req_type = tsip_message.prototype.GetRequestType(this.s_method);
	}
	else{
		this.e_req_type = tsip_request_type_e.UNKNOWN;
	}
}

tsip_header_CSeq.prototype.toString = function(){
    return tsk_string_format("{0} {1}", this.i_seq, this.s_method);
}

tsip_header_CSeq.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_cseq = new tsip_header_CSeq(TSIP_HEADER_CSEQ_NONE);
	
	
/* line 123 "./src/headers/tsip_header_CSeq.js" */
{
	 cs = tsip_machine_parser_header_CSeq_start;
} /* JSCodeGen::writeInit */

/* line 68 "./ragel/tsip_parser_header_CSeq.jrl" */
	
/* line 130 "./src/headers/tsip_header_CSeq.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_CSeq_key_offsets[cs];
	_trans = _tsip_machine_parser_header_CSeq_index_offsets[cs];
	_klen = _tsip_machine_parser_header_CSeq_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_CSeq_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_CSeq_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_CSeq_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_CSeq_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_CSeq_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_CSeq_indicies[_trans];
	cs = _tsip_machine_parser_header_CSeq_trans_targs[_trans];
	if (_tsip_machine_parser_header_CSeq_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_CSeq_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_CSeq_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_CSeq_actions[_acts - 1]) {
case 0:
/* line 17 "./ragel/tsip_parser_header_CSeq.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 21 "./ragel/tsip_parser_header_CSeq.jrl" */

		hdr_cseq.s_method = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
		hdr_cseq.e_req_type = tsip_message.prototype.GetRequestType(hdr_cseq.s_method);
			break;
case 2:
/* line 26 "./ragel/tsip_parser_header_CSeq.jrl" */

	    hdr_cseq.i_seq = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 3:
/* line 30 "./ragel/tsip_parser_header_CSeq.jrl" */

			break;
/* line 234 "./src/headers/tsip_header_CSeq.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 69 "./ragel/tsip_parser_header_CSeq.jrl" */
	
	if( cs < 
/* line 264 "./src/headers/tsip_header_CSeq.js" */
17
/* line 70 "./ragel/tsip_parser_header_CSeq.jrl" */
 ){
		tsk_utils_log_error("Failed to parse 'CSeq' header: " + s_str);
		return null;
	}
	
	return hdr_cseq;
}

/* line 1 "./ragel/tsip_parser_header_RAck.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_RAck.prototype = Object.create(tsip_header.prototype);

/* line 37 "./ragel/tsip_parser_header_RAck.jrl" */



/* line 15 "./src/headers/tsip_header_RAck.js" */
_tsip_machine_parser_header_RAck_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4
];

_tsip_machine_parser_header_RAck_key_offsets = [
	0, 0, 2, 4, 6, 8, 11, 16, 
	17, 19, 23, 28, 33, 34, 36, 40, 
	45, 62, 63, 65, 81, 96, 97
];

_tsip_machine_parser_header_RAck_trans_keys = [
	82, 114, 65, 97, 67, 99, 75, 107, 
	9, 32, 58, 9, 13, 32, 48, 57, 
	10, 9, 32, 9, 32, 48, 57, 9, 
	13, 32, 48, 57, 9, 13, 32, 48, 
	57, 10, 9, 32, 9, 32, 48, 57, 
	9, 13, 32, 48, 57, 9, 13, 32, 
	33, 37, 39, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 10, 9, 
	32, 9, 32, 33, 37, 39, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 13, 33, 37, 39, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	10, 0
];

_tsip_machine_parser_header_RAck_single_lengths = [
	0, 2, 2, 2, 2, 3, 3, 1, 
	2, 2, 3, 3, 1, 2, 2, 3, 
	7, 1, 2, 6, 5, 1, 0
];

_tsip_machine_parser_header_RAck_range_lengths = [
	0, 0, 0, 0, 0, 0, 1, 0, 
	0, 1, 1, 1, 0, 0, 1, 1, 
	5, 0, 0, 5, 5, 0, 0
];

_tsip_machine_parser_header_RAck_index_offsets = [
	0, 0, 3, 6, 9, 12, 16, 21, 
	23, 26, 30, 35, 40, 42, 45, 49, 
	54, 67, 69, 72, 84, 95, 97
];

_tsip_machine_parser_header_RAck_indicies = [
	0, 0, 1, 2, 2, 1, 3, 3, 
	1, 4, 4, 1, 4, 4, 5, 1, 
	5, 6, 5, 7, 1, 8, 1, 9, 
	9, 1, 9, 9, 7, 1, 10, 11, 
	10, 12, 1, 13, 14, 13, 15, 1, 
	16, 1, 17, 17, 1, 17, 17, 15, 
	1, 18, 19, 18, 20, 1, 21, 22, 
	21, 23, 23, 23, 23, 23, 23, 23, 
	23, 23, 1, 24, 1, 25, 25, 1, 
	25, 25, 23, 23, 23, 23, 23, 23, 
	23, 23, 23, 1, 26, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 1, 28, 
	1, 1, 0
];

_tsip_machine_parser_header_RAck_trans_targs = [
	2, 0, 3, 4, 5, 6, 7, 10, 
	8, 9, 11, 12, 10, 11, 12, 15, 
	13, 14, 16, 17, 15, 16, 17, 20, 
	18, 19, 21, 20, 22
];

_tsip_machine_parser_header_RAck_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 1, 
	0, 0, 3, 3, 0, 0, 0, 1, 
	0, 0, 5, 5, 0, 0, 0, 1, 
	0, 0, 7, 0, 9
];

tsip_machine_parser_header_RAck_start = 1;
tsip_machine_parser_header_RAck_first_final = 22;
tsip_machine_parser_header_RAck_error = 0;

tsip_machine_parser_header_RAck_en_main = 1;


/* line 40 "./ragel/tsip_parser_header_RAck.jrl" */

function tsip_header_RAck(i_seq, i_cseq, s_method){
	tsip_header.call(this, tsip_header_type_e.RAck);
    this.i_seq = i_seq;
    this.i_cseq = i_cseq;
    this.s_method = s_method;
}

tsip_header_RAck.prototype.toString = function(){
    return tsk_string_format("{0} {1} {2}",
        this.i_seq, this.i_cseq, this.s_method);
};

tsip_header_RAck.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_rack = new tsip_header_RAck(0, 0, null);
	
	
/* line 122 "./src/headers/tsip_header_RAck.js" */
{
	 cs = tsip_machine_parser_header_RAck_start;
} /* JSCodeGen::writeInit */

/* line 63 "./ragel/tsip_parser_header_RAck.jrl" */
	
/* line 129 "./src/headers/tsip_header_RAck.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_RAck_key_offsets[cs];
	_trans = _tsip_machine_parser_header_RAck_index_offsets[cs];
	_klen = _tsip_machine_parser_header_RAck_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_RAck_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_RAck_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_RAck_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_RAck_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_RAck_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_RAck_indicies[_trans];
	cs = _tsip_machine_parser_header_RAck_trans_targs[_trans];
	if (_tsip_machine_parser_header_RAck_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_RAck_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_RAck_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_RAck_actions[_acts - 1]) {
case 0:
/* line 13 "./ragel/tsip_parser_header_RAck.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 17 "./ragel/tsip_parser_header_RAck.jrl" */

	    hdr_rack.i_seq = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 2:
/* line 21 "./ragel/tsip_parser_header_RAck.jrl" */

	    hdr_rack.i_cseq = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 3:
/* line 25 "./ragel/tsip_parser_header_RAck.jrl" */

	    hdr_rack.s_method= tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 4:
/* line 29 "./ragel/tsip_parser_header_RAck.jrl" */

			break;
/* line 237 "./src/headers/tsip_header_RAck.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 64 "./ragel/tsip_parser_header_RAck.jrl" */
	
	if( cs < 
/* line 267 "./src/headers/tsip_header_RAck.js" */
22
/* line 65 "./ragel/tsip_parser_header_RAck.jrl" */
 ){
		tsk_utils_log_error("Failed to parse 'RAck' header: " + s_str);
		return null;
	}
	
	return hdr_rack;
}

/* line 1 "./ragel/tsip_parser_header_Refer_Sub.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_Refer_Sub.prototype = Object.create(tsip_header.prototype);

/* line 37 "./ragel/tsip_parser_header_Refer_Sub.jrl" */



/* line 15 "./src/headers/tsip_header_Refer_Sub.js" */
_tsip_machine_parser_header_Refer_Sub_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4
];

_tsip_machine_parser_header_Refer_Sub_key_offsets = [
	0, 0, 2, 4, 6, 8, 10, 11, 
	13, 15, 17, 20, 27, 28, 30, 36, 
	38, 40, 42, 44, 48, 52, 53, 55, 
	58, 75, 76, 78, 94, 113, 118, 119, 
	121, 125, 144, 145, 147, 166, 167, 169, 
	172, 180, 181, 183, 187, 188, 194, 212, 
	219, 227, 235, 243, 245, 252, 261, 263, 
	266, 268, 271, 273, 276, 279, 280, 283, 
	284, 287, 288, 297, 306, 314, 322, 330, 
	338, 340, 346, 355, 364, 373, 375, 378, 
	381, 382, 383, 385, 387, 389, 393
];

_tsip_machine_parser_header_Refer_Sub_trans_keys = [
	82, 114, 69, 101, 70, 102, 69, 101, 
	82, 114, 45, 83, 115, 85, 117, 66, 
	98, 9, 32, 58, 9, 13, 32, 70, 
	84, 102, 116, 10, 9, 32, 9, 32, 
	70, 84, 102, 116, 65, 97, 76, 108, 
	83, 115, 69, 101, 9, 13, 32, 59, 
	9, 13, 32, 59, 10, 9, 32, 9, 
	32, 59, 9, 13, 32, 33, 37, 39, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 10, 9, 32, 9, 32, 
	33, 37, 39, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 33, 37, 39, 59, 61, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 59, 61, 10, 9, 
	32, 9, 32, 59, 61, 9, 13, 32, 
	33, 34, 37, 39, 91, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	10, 9, 32, 9, 13, 32, 33, 34, 
	37, 39, 91, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 10, 9, 
	32, 9, 32, 34, 9, 13, 34, 92, 
	32, 126, 128, 255, 10, 9, 32, 9, 
	13, 32, 59, 10, 0, 9, 11, 12, 
	14, 127, 9, 13, 32, 33, 37, 39, 
	59, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 58, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 58, 48, 57, 
	65, 70, 97, 102, 46, 58, 93, 48, 
	57, 65, 70, 97, 102, 48, 57, 46, 
	48, 57, 48, 57, 46, 48, 57, 48, 
	57, 93, 48, 57, 93, 48, 57, 93, 
	46, 48, 57, 46, 46, 48, 57, 46, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 46, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 46, 58, 93, 48, 57, 65, 
	70, 97, 102, 46, 58, 93, 48, 57, 
	65, 70, 97, 102, 46, 58, 93, 48, 
	57, 65, 70, 97, 102, 48, 57, 46, 
	48, 57, 46, 48, 57, 46, 58, 82, 
	114, 85, 117, 69, 101, 9, 13, 32, 
	59, 0
];

_tsip_machine_parser_header_Refer_Sub_single_lengths = [
	0, 2, 2, 2, 2, 2, 1, 2, 
	2, 2, 3, 7, 1, 2, 6, 2, 
	2, 2, 2, 4, 4, 1, 2, 3, 
	7, 1, 2, 6, 9, 5, 1, 2, 
	4, 9, 1, 2, 9, 1, 2, 3, 
	4, 1, 2, 4, 1, 0, 8, 1, 
	2, 2, 2, 2, 1, 3, 0, 1, 
	0, 1, 0, 1, 1, 1, 1, 1, 
	1, 1, 3, 3, 2, 2, 2, 2, 
	2, 0, 3, 3, 3, 0, 1, 1, 
	1, 1, 2, 2, 2, 4, 0
];

_tsip_machine_parser_header_Refer_Sub_range_lengths = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	5, 0, 0, 5, 5, 0, 0, 0, 
	0, 5, 0, 0, 5, 0, 0, 0, 
	2, 0, 0, 0, 0, 3, 5, 3, 
	3, 3, 3, 0, 3, 3, 1, 1, 
	1, 1, 1, 1, 1, 0, 1, 0, 
	1, 0, 3, 3, 3, 3, 3, 3, 
	0, 3, 3, 3, 3, 1, 1, 1, 
	0, 0, 0, 0, 0, 0, 0
];

_tsip_machine_parser_header_Refer_Sub_index_offsets = [
	0, 0, 3, 6, 9, 12, 15, 17, 
	20, 23, 26, 30, 38, 40, 43, 50, 
	53, 56, 59, 62, 67, 72, 74, 77, 
	81, 94, 96, 99, 111, 126, 132, 134, 
	137, 142, 157, 159, 162, 177, 179, 182, 
	186, 193, 195, 198, 203, 205, 209, 223, 
	228, 234, 240, 246, 249, 254, 261, 263, 
	266, 268, 271, 273, 276, 279, 281, 284, 
	286, 289, 291, 298, 305, 311, 317, 323, 
	329, 332, 336, 343, 350, 357, 359, 362, 
	365, 367, 369, 372, 375, 378, 383
];

_tsip_machine_parser_header_Refer_Sub_indicies = [
	0, 0, 1, 2, 2, 1, 3, 3, 
	1, 4, 4, 1, 5, 5, 1, 6, 
	1, 7, 7, 1, 8, 8, 1, 9, 
	9, 1, 9, 9, 10, 1, 10, 11, 
	10, 12, 13, 12, 13, 1, 14, 1, 
	15, 15, 1, 15, 15, 12, 13, 12, 
	13, 1, 16, 16, 1, 17, 17, 1, 
	18, 18, 1, 19, 19, 1, 20, 21, 
	20, 22, 1, 23, 24, 23, 25, 1, 
	26, 1, 27, 27, 1, 27, 27, 25, 
	1, 25, 28, 25, 29, 29, 29, 29, 
	29, 29, 29, 29, 29, 1, 30, 1, 
	31, 31, 1, 31, 31, 29, 29, 29, 
	29, 29, 29, 29, 29, 29, 1, 32, 
	33, 32, 34, 34, 34, 35, 36, 34, 
	34, 34, 34, 34, 34, 1, 37, 38, 
	37, 25, 36, 1, 39, 1, 40, 40, 
	1, 40, 40, 25, 36, 1, 36, 41, 
	36, 42, 43, 42, 42, 44, 42, 42, 
	42, 42, 42, 42, 1, 45, 1, 46, 
	46, 1, 46, 47, 46, 42, 43, 42, 
	42, 44, 42, 42, 42, 42, 42, 42, 
	1, 48, 1, 49, 49, 1, 49, 49, 
	43, 1, 43, 50, 51, 52, 43, 43, 
	1, 53, 1, 43, 43, 1, 54, 33, 
	54, 35, 1, 55, 1, 43, 43, 43, 
	1, 54, 33, 54, 42, 42, 42, 35, 
	42, 42, 42, 42, 42, 42, 1, 57, 
	56, 56, 56, 1, 59, 51, 58, 58, 
	58, 1, 59, 51, 60, 60, 60, 1, 
	59, 51, 61, 61, 61, 1, 59, 51, 
	1, 63, 62, 56, 56, 1, 64, 59, 
	51, 65, 58, 58, 1, 66, 1, 67, 
	68, 1, 69, 1, 70, 71, 1, 72, 
	1, 51, 73, 1, 51, 74, 1, 51, 
	1, 70, 75, 1, 70, 1, 67, 76, 
	1, 67, 1, 64, 59, 51, 77, 60, 
	60, 1, 64, 59, 51, 61, 61, 61, 
	1, 79, 51, 78, 78, 78, 1, 81, 
	51, 80, 80, 80, 1, 81, 51, 82, 
	82, 82, 1, 81, 51, 83, 83, 83, 
	1, 81, 51, 1, 84, 78, 78, 1, 
	64, 81, 51, 85, 80, 80, 1, 64, 
	81, 51, 86, 82, 82, 1, 64, 81, 
	51, 83, 83, 83, 1, 87, 1, 64, 
	88, 1, 64, 89, 1, 64, 1, 63, 
	1, 90, 90, 1, 91, 91, 1, 92, 
	92, 1, 93, 94, 93, 95, 1, 1, 
	0
];

_tsip_machine_parser_header_Refer_Sub_trans_targs = [
	2, 0, 3, 4, 5, 6, 7, 8, 
	9, 10, 11, 12, 15, 82, 13, 14, 
	16, 17, 18, 19, 20, 44, 24, 20, 
	21, 24, 22, 23, 25, 28, 26, 27, 
	29, 44, 28, 24, 33, 29, 30, 31, 
	32, 34, 46, 40, 47, 35, 36, 37, 
	38, 39, 41, 43, 45, 42, 20, 86, 
	48, 81, 49, 52, 50, 51, 53, 68, 
	54, 66, 55, 56, 64, 57, 58, 62, 
	59, 60, 61, 63, 65, 67, 69, 77, 
	70, 73, 71, 72, 74, 75, 76, 78, 
	79, 80, 83, 84, 85, 20, 44, 24
];

_tsip_machine_parser_header_Refer_Sub_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 1, 1, 0, 0, 
	0, 0, 0, 0, 5, 5, 5, 0, 
	0, 0, 0, 0, 0, 1, 0, 0, 
	7, 7, 0, 7, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 7, 9, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 3, 3, 3
];

tsip_machine_parser_header_Refer_Sub_start = 1;
tsip_machine_parser_header_Refer_Sub_first_final = 86;
tsip_machine_parser_header_Refer_Sub_error = 0;

tsip_machine_parser_header_Refer_Sub_en_main = 1;


/* line 40 "./ragel/tsip_parser_header_Refer_Sub.jrl" */

function tsip_header_Refer_Sub(b_sub){
	tsip_header.call(this, tsip_header_type_e.Refer_Sub);
    this.b_sub = b_sub;
}

tsip_header_Refer_Sub.prototype.toString = function(){
    return this.b_sub ? "true" : "false";
}

tsip_header_Refer_Sub.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_rsub = new tsip_header_Refer_Sub(true);
	
	
/* line 240 "./src/headers/tsip_header_Refer_Sub.js" */
{
	 cs = tsip_machine_parser_header_Refer_Sub_start;
} /* JSCodeGen::writeInit */

/* line 60 "./ragel/tsip_parser_header_Refer_Sub.jrl" */
	
/* line 247 "./src/headers/tsip_header_Refer_Sub.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_Refer_Sub_key_offsets[cs];
	_trans = _tsip_machine_parser_header_Refer_Sub_index_offsets[cs];
	_klen = _tsip_machine_parser_header_Refer_Sub_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_Refer_Sub_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_Refer_Sub_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_Refer_Sub_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_Refer_Sub_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_Refer_Sub_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_Refer_Sub_indicies[_trans];
	cs = _tsip_machine_parser_header_Refer_Sub_trans_targs[_trans];
	if (_tsip_machine_parser_header_Refer_Sub_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_Refer_Sub_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_Refer_Sub_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_Refer_Sub_actions[_acts - 1]) {
case 0:
/* line 13 "./ragel/tsip_parser_header_Refer_Sub.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 17 "./ragel/tsip_parser_header_Refer_Sub.jrl" */

		hdr_rsub.b_sub = true;
			break;
case 2:
/* line 20 "./ragel/tsip_parser_header_Refer_Sub.jrl" */

		hdr_rsub.b_sub = false;
			break;
case 3:
/* line 23 "./ragel/tsip_parser_header_Refer_Sub.jrl" */

		tsk_ragel_add_param(s_str, p, i_tag_start, hdr_rsub.ao_params);
			break;
case 4:
/* line 27 "./ragel/tsip_parser_header_Refer_Sub.jrl" */

			break;
/* line 355 "./src/headers/tsip_header_Refer_Sub.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 61 "./ragel/tsip_parser_header_Refer_Sub.jrl" */
	
	if( cs < 
/* line 385 "./src/headers/tsip_header_Refer_Sub.js" */
86
/* line 62 "./ragel/tsip_parser_header_Refer_Sub.jrl" */
 ){
		tsk_utils_log_error("Failed to parse 'Refer-Sub' header: " + s_str);
		return null;
	}
	
	return hdr_rsub;
}


/* line 1 "./ragel/tsip_parser_header_Session_Expires.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_Session_Expires.prototype = Object.create(tsip_header.prototype);
var TSIP_SESSION_EXPIRES_DEFAULT_VALUE = 1800;


/* line 44 "./ragel/tsip_parser_header_Session_Expires.jrl" */




/* line 18 "./src/headers/tsip_header_Session_Expires.js" */
_tsip_machine_parser_header_Session_Expires_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5
];

_tsip_machine_parser_header_Session_Expires_key_offsets = [
	0, 0, 4, 6, 8, 10, 12, 14, 
	16, 17, 19, 21, 23, 25, 27, 29, 
	31, 34, 39, 40, 42, 46, 52, 56, 
	57, 59, 62, 81, 82, 84, 102, 121, 
	126, 127, 129, 133, 152, 153, 155, 174, 
	175, 177, 180, 188, 189, 191, 195, 196, 
	202, 220, 227, 235, 243, 251, 253, 260, 
	269, 271, 274, 276, 279, 281, 284, 287, 
	288, 291, 292, 295, 296, 305, 314, 322, 
	330, 338, 346, 348, 354, 363, 372, 381, 
	383, 386, 389, 390, 391, 412, 433, 454, 
	475, 496, 517, 538, 559, 578, 583, 584, 
	586, 590, 611, 612, 614, 635, 655, 677, 
	681, 685
];

_tsip_machine_parser_header_Session_Expires_trans_keys = [
	83, 88, 115, 120, 69, 101, 83, 115, 
	83, 115, 73, 105, 79, 111, 78, 110, 
	45, 69, 101, 88, 120, 80, 112, 73, 
	105, 82, 114, 69, 101, 83, 115, 9, 
	32, 58, 9, 13, 32, 48, 57, 10, 
	9, 32, 9, 32, 48, 57, 9, 13, 
	32, 59, 48, 57, 9, 13, 32, 59, 
	10, 9, 32, 9, 32, 59, 9, 13, 
	32, 33, 37, 39, 82, 114, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 10, 9, 32, 9, 32, 33, 37, 
	39, 82, 114, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 33, 37, 39, 59, 61, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 59, 61, 10, 9, 
	32, 9, 32, 59, 61, 9, 13, 32, 
	33, 34, 37, 39, 91, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	10, 9, 32, 9, 13, 32, 33, 34, 
	37, 39, 91, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 10, 9, 
	32, 9, 32, 34, 9, 13, 34, 92, 
	32, 126, 128, 255, 10, 9, 32, 9, 
	13, 32, 59, 10, 0, 9, 11, 12, 
	14, 127, 9, 13, 32, 33, 37, 39, 
	59, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 58, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 48, 57, 65, 
	70, 97, 102, 58, 93, 58, 48, 57, 
	65, 70, 97, 102, 46, 58, 93, 48, 
	57, 65, 70, 97, 102, 48, 57, 46, 
	48, 57, 48, 57, 46, 48, 57, 48, 
	57, 93, 48, 57, 93, 48, 57, 93, 
	46, 48, 57, 46, 46, 48, 57, 46, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 46, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 58, 93, 48, 57, 65, 70, 
	97, 102, 46, 58, 93, 48, 57, 65, 
	70, 97, 102, 46, 58, 93, 48, 57, 
	65, 70, 97, 102, 46, 58, 93, 48, 
	57, 65, 70, 97, 102, 48, 57, 46, 
	48, 57, 46, 48, 57, 46, 58, 9, 
	13, 32, 33, 37, 39, 59, 61, 69, 
	101, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 59, 61, 70, 102, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 33, 37, 39, 59, 
	61, 82, 114, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 33, 37, 39, 59, 61, 69, 101, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 59, 61, 83, 115, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 33, 37, 39, 59, 61, 
	72, 104, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 59, 61, 69, 101, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	59, 61, 82, 114, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 59, 61, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 59, 61, 10, 
	9, 32, 9, 32, 59, 61, 9, 13, 
	32, 33, 34, 37, 39, 85, 91, 117, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 10, 9, 32, 9, 13, 
	32, 33, 34, 37, 39, 85, 91, 117, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 59, 65, 97, 126, 42, 43, 45, 
	46, 48, 57, 66, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 59, 67, 83, 
	99, 115, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	59, 9, 13, 32, 59, 0
];

_tsip_machine_parser_header_Session_Expires_single_lengths = [
	0, 4, 2, 2, 2, 2, 2, 2, 
	1, 2, 2, 2, 2, 2, 2, 2, 
	3, 3, 1, 2, 2, 4, 4, 1, 
	2, 3, 9, 1, 2, 8, 9, 5, 
	1, 2, 4, 9, 1, 2, 9, 1, 
	2, 3, 4, 1, 2, 4, 1, 0, 
	8, 1, 2, 2, 2, 2, 1, 3, 
	0, 1, 0, 1, 0, 1, 1, 1, 
	1, 1, 1, 1, 3, 3, 2, 2, 
	2, 2, 2, 0, 3, 3, 3, 0, 
	1, 1, 1, 1, 11, 11, 11, 11, 
	11, 11, 11, 11, 9, 5, 1, 2, 
	4, 11, 1, 2, 11, 10, 12, 4, 
	4, 0
];

_tsip_machine_parser_header_Session_Expires_range_lengths = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 1, 1, 0, 0, 
	0, 0, 5, 0, 0, 5, 5, 0, 
	0, 0, 0, 5, 0, 0, 5, 0, 
	0, 0, 2, 0, 0, 0, 0, 3, 
	5, 3, 3, 3, 3, 0, 3, 3, 
	1, 1, 1, 1, 1, 1, 1, 0, 
	1, 0, 1, 0, 3, 3, 3, 3, 
	3, 3, 0, 3, 3, 3, 3, 1, 
	1, 1, 0, 0, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 0, 0, 0, 
	0, 5, 0, 0, 5, 5, 5, 0, 
	0, 0
];

_tsip_machine_parser_header_Session_Expires_index_offsets = [
	0, 0, 5, 8, 11, 14, 17, 20, 
	23, 25, 28, 31, 34, 37, 40, 43, 
	46, 50, 55, 57, 60, 64, 70, 75, 
	77, 80, 84, 99, 101, 104, 118, 133, 
	139, 141, 144, 149, 164, 166, 169, 184, 
	186, 189, 193, 200, 202, 205, 210, 212, 
	216, 230, 235, 241, 247, 253, 256, 261, 
	268, 270, 273, 275, 278, 280, 283, 286, 
	288, 291, 293, 296, 298, 305, 312, 318, 
	324, 330, 336, 339, 343, 350, 357, 364, 
	366, 369, 372, 374, 376, 393, 410, 427, 
	444, 461, 478, 495, 512, 527, 533, 535, 
	538, 543, 560, 562, 565, 582, 598, 616, 
	621, 626
];

_tsip_machine_parser_header_Session_Expires_indicies = [
	0, 2, 0, 2, 1, 3, 3, 1, 
	4, 4, 1, 5, 5, 1, 6, 6, 
	1, 7, 7, 1, 8, 8, 1, 9, 
	1, 10, 10, 1, 11, 11, 1, 12, 
	12, 1, 13, 13, 1, 14, 14, 1, 
	15, 15, 1, 2, 2, 1, 2, 2, 
	16, 1, 16, 17, 16, 18, 1, 19, 
	1, 20, 20, 1, 20, 20, 18, 1, 
	21, 22, 21, 24, 23, 1, 25, 26, 
	25, 27, 1, 28, 1, 29, 29, 1, 
	29, 29, 27, 1, 27, 30, 27, 31, 
	31, 31, 32, 32, 31, 31, 31, 31, 
	31, 31, 1, 33, 1, 34, 34, 1, 
	34, 34, 31, 31, 31, 32, 32, 31, 
	31, 31, 31, 31, 31, 1, 35, 36, 
	35, 37, 37, 37, 38, 39, 37, 37, 
	37, 37, 37, 37, 1, 40, 41, 40, 
	27, 39, 1, 42, 1, 43, 43, 1, 
	43, 43, 27, 39, 1, 39, 44, 39, 
	45, 46, 45, 45, 47, 45, 45, 45, 
	45, 45, 45, 1, 48, 1, 49, 49, 
	1, 49, 50, 49, 45, 46, 45, 45, 
	47, 45, 45, 45, 45, 45, 45, 1, 
	51, 1, 52, 52, 1, 52, 52, 46, 
	1, 46, 53, 54, 55, 46, 46, 1, 
	56, 1, 46, 46, 1, 57, 36, 57, 
	38, 1, 58, 1, 46, 46, 46, 1, 
	57, 36, 57, 45, 45, 45, 38, 45, 
	45, 45, 45, 45, 45, 1, 60, 59, 
	59, 59, 1, 62, 54, 61, 61, 61, 
	1, 62, 54, 63, 63, 63, 1, 62, 
	54, 64, 64, 64, 1, 62, 54, 1, 
	66, 65, 59, 59, 1, 67, 62, 54, 
	68, 61, 61, 1, 69, 1, 70, 71, 
	1, 72, 1, 73, 74, 1, 75, 1, 
	54, 76, 1, 54, 77, 1, 54, 1, 
	73, 78, 1, 73, 1, 70, 79, 1, 
	70, 1, 67, 62, 54, 80, 63, 63, 
	1, 67, 62, 54, 64, 64, 64, 1, 
	82, 54, 81, 81, 81, 1, 84, 54, 
	83, 83, 83, 1, 84, 54, 85, 85, 
	85, 1, 84, 54, 86, 86, 86, 1, 
	84, 54, 1, 87, 81, 81, 1, 67, 
	84, 54, 88, 83, 83, 1, 67, 84, 
	54, 89, 85, 85, 1, 67, 84, 54, 
	86, 86, 86, 1, 90, 1, 67, 91, 
	1, 67, 92, 1, 67, 1, 66, 1, 
	35, 36, 35, 37, 37, 37, 38, 39, 
	93, 93, 37, 37, 37, 37, 37, 37, 
	1, 35, 36, 35, 37, 37, 37, 38, 
	39, 94, 94, 37, 37, 37, 37, 37, 
	37, 1, 35, 36, 35, 37, 37, 37, 
	38, 39, 95, 95, 37, 37, 37, 37, 
	37, 37, 1, 35, 36, 35, 37, 37, 
	37, 38, 39, 96, 96, 37, 37, 37, 
	37, 37, 37, 1, 35, 36, 35, 37, 
	37, 37, 38, 39, 97, 97, 37, 37, 
	37, 37, 37, 37, 1, 35, 36, 35, 
	37, 37, 37, 38, 39, 98, 98, 37, 
	37, 37, 37, 37, 37, 1, 35, 36, 
	35, 37, 37, 37, 38, 39, 99, 99, 
	37, 37, 37, 37, 37, 37, 1, 35, 
	36, 35, 37, 37, 37, 38, 39, 100, 
	100, 37, 37, 37, 37, 37, 37, 1, 
	101, 36, 101, 37, 37, 37, 38, 102, 
	37, 37, 37, 37, 37, 37, 1, 103, 
	104, 103, 27, 102, 1, 105, 1, 106, 
	106, 1, 106, 106, 27, 102, 1, 102, 
	107, 102, 45, 46, 45, 45, 108, 47, 
	108, 45, 45, 45, 45, 45, 45, 1, 
	109, 1, 110, 110, 1, 110, 50, 110, 
	45, 46, 45, 45, 108, 47, 108, 45, 
	45, 45, 45, 45, 45, 1, 57, 36, 
	57, 45, 45, 45, 38, 111, 111, 45, 
	45, 45, 45, 45, 45, 1, 57, 36, 
	57, 45, 45, 45, 38, 112, 113, 112, 
	113, 45, 45, 45, 45, 45, 45, 1, 
	114, 115, 114, 116, 1, 117, 118, 117, 
	119, 1, 1, 0
];

_tsip_machine_parser_header_Session_Expires_trans_targs = [
	2, 0, 16, 3, 4, 5, 6, 7, 
	8, 9, 10, 11, 12, 13, 14, 15, 
	17, 18, 21, 19, 20, 22, 46, 21, 
	26, 22, 23, 26, 24, 25, 27, 30, 
	84, 28, 29, 31, 46, 30, 26, 35, 
	31, 32, 33, 34, 36, 48, 42, 49, 
	37, 38, 39, 40, 41, 43, 45, 47, 
	44, 22, 105, 50, 83, 51, 54, 52, 
	53, 55, 70, 56, 68, 57, 58, 66, 
	59, 60, 64, 61, 62, 63, 65, 67, 
	69, 71, 79, 72, 75, 73, 74, 76, 
	77, 78, 80, 81, 82, 85, 86, 87, 
	88, 89, 90, 91, 92, 93, 97, 93, 
	94, 95, 96, 98, 101, 99, 100, 102, 
	103, 104, 22, 46, 26, 22, 46, 26
];

_tsip_machine_parser_header_Session_Expires_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 0, 0, 3, 3, 0, 
	3, 0, 0, 0, 0, 0, 0, 1, 
	1, 0, 0, 9, 9, 0, 9, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 9, 11, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 9, 0, 0, 
	0, 0, 0, 0, 1, 0, 0, 0, 
	0, 0, 7, 7, 7, 5, 5, 5
];

tsip_machine_parser_header_Session_Expires_start = 1;
tsip_machine_parser_header_Session_Expires_first_final = 105;
tsip_machine_parser_header_Session_Expires_error = 0;

tsip_machine_parser_header_Session_Expires_en_main = 1;


/* line 48 "./ragel/tsip_parser_header_Session_Expires.jrl" */

function tsip_header_Session_Expires(i_delta_seconds, b_refresher_uas){
	tsip_header.call(this, tsip_header_type_e.Session_Expires);
    this.i_delta_seconds = i_delta_seconds;
    this.b_refresher_uas = b_refresher_uas;
}

tsip_header_Session_Expires.prototype.toString = function(){
    if(this.i_delta_seconds >= 0){
        return tsk_string_format("{0};refresher={1}", this.i_delta_seconds, this.b_refresher_uas ? "uas" : "uac");
    }
    return null;
}

tsip_header_Session_Expires.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_session_expires = new tsip_header_Session_Expires(TSIP_SESSION_EXPIRES_DEFAULT_VALUE, false);
	
	
/* line 331 "./src/headers/tsip_header_Session_Expires.js" */
{
	 cs = tsip_machine_parser_header_Session_Expires_start;
} /* JSCodeGen::writeInit */

/* line 72 "./ragel/tsip_parser_header_Session_Expires.jrl" */
	
/* line 338 "./src/headers/tsip_header_Session_Expires.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_Session_Expires_key_offsets[cs];
	_trans = _tsip_machine_parser_header_Session_Expires_index_offsets[cs];
	_klen = _tsip_machine_parser_header_Session_Expires_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_Session_Expires_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_Session_Expires_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_Session_Expires_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_Session_Expires_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_Session_Expires_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_Session_Expires_indicies[_trans];
	cs = _tsip_machine_parser_header_Session_Expires_trans_targs[_trans];
	if (_tsip_machine_parser_header_Session_Expires_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_Session_Expires_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_Session_Expires_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_Session_Expires_actions[_acts - 1]) {
case 0:
/* line 15 "./ragel/tsip_parser_header_Session_Expires.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 19 "./ragel/tsip_parser_header_Session_Expires.jrl" */

	    hdr_session_expires.i_delta_seconds = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 2:
/* line 23 "./ragel/tsip_parser_header_Session_Expires.jrl" */

		hdr_session_expires.b_refresher_uas = true;
			break;
case 3:
/* line 26 "./ragel/tsip_parser_header_Session_Expires.jrl" */

		hdr_session_expires.b_refresher_uas = false;
			break;
case 4:
/* line 30 "./ragel/tsip_parser_header_Session_Expires.jrl" */

	    tsk_ragel_add_param(s_str, p, i_tag_start, hdr_session_expires.ao_params);
			break;
case 5:
/* line 34 "./ragel/tsip_parser_header_Session_Expires.jrl" */

			break;
/* line 451 "./src/headers/tsip_header_Session_Expires.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 73 "./ragel/tsip_parser_header_Session_Expires.jrl" */
	
	if( cs < 
/* line 481 "./src/headers/tsip_header_Session_Expires.js" */
105
/* line 74 "./ragel/tsip_parser_header_Session_Expires.jrl" */
 ){
		tsk_utils_log_error("Failed to parse 'Session-Expires' header: " + s_str);
		return null;
	}
	
	return hdr_session_expires;
}

/* line 1 "./ragel/tsip_parser_header_Subscription_State.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_Subscription_State.prototype = Object.create(tsip_header.prototype);

/* line 46 "./ragel/tsip_parser_header_Subscription_State.jrl" */



/* line 15 "./src/headers/tsip_header_Subscription_State.js" */
_tsip_machine_parser_header_Subscription_State_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6
];

_tsip_machine_parser_header_Subscription_State_key_offsets = [
	0, 0, 2, 4, 6, 8, 10, 12, 
	14, 16, 18, 20, 22, 24, 25, 27, 
	29, 31, 33, 35, 38, 55, 56, 58, 
	74, 92, 96, 97, 99, 102, 123, 124, 
	126, 146, 165, 170, 171, 173, 177, 196, 
	197, 199, 218, 219, 221, 224, 232, 233, 
	235, 239, 240, 246, 264, 271, 279, 287, 
	295, 297, 304, 313, 315, 318, 320, 323, 
	325, 328, 331, 332, 335, 336, 339, 340, 
	349, 358, 366, 374, 382, 390, 392, 398, 
	407, 416, 425, 427, 430, 433, 434, 435, 
	456, 477, 498, 519, 540, 561, 580, 585, 
	586, 588, 592, 611, 612, 614, 633, 639, 
	660, 683, 704, 725, 746, 765, 770, 771, 
	773, 777, 796, 797, 799, 818, 836, 857, 
	878, 897, 918, 939, 960, 981, 1002, 1021, 
	1026, 1027, 1029, 1033, 1052, 1053, 1055, 1074, 
	1080
];

_tsip_machine_parser_header_Subscription_State_trans_keys = [
	83, 115, 85, 117, 66, 98, 83, 115, 
	67, 99, 82, 114, 73, 105, 80, 112, 
	84, 116, 73, 105, 79, 111, 78, 110, 
	45, 83, 115, 84, 116, 65, 97, 84, 
	116, 69, 101, 9, 32, 58, 9, 13, 
	32, 33, 37, 39, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 10, 
	9, 32, 9, 32, 33, 37, 39, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	59, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 59, 
	10, 9, 32, 9, 32, 59, 9, 13, 
	32, 33, 37, 39, 69, 82, 101, 114, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 10, 9, 32, 9, 32, 
	33, 37, 39, 69, 82, 101, 114, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	59, 61, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	59, 61, 10, 9, 32, 9, 32, 59, 
	61, 9, 13, 32, 33, 34, 37, 39, 
	91, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 10, 9, 32, 9, 
	13, 32, 33, 34, 37, 39, 91, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 10, 9, 32, 9, 32, 34, 
	9, 13, 34, 92, 32, 126, 128, 255, 
	10, 9, 32, 9, 13, 32, 59, 10, 
	0, 9, 11, 12, 14, 127, 9, 13, 
	32, 33, 37, 39, 59, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	58, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 58, 48, 57, 65, 70, 97, 102, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 48, 57, 46, 48, 57, 48, 57, 
	46, 48, 57, 48, 57, 93, 48, 57, 
	93, 48, 57, 93, 46, 48, 57, 46, 
	46, 48, 57, 46, 46, 58, 93, 48, 
	57, 65, 70, 97, 102, 46, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 46, 58, 
	93, 48, 57, 65, 70, 97, 102, 46, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 48, 57, 46, 48, 57, 46, 48, 
	57, 46, 58, 9, 13, 32, 33, 37, 
	39, 59, 61, 88, 120, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 33, 37, 39, 59, 61, 
	80, 112, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 59, 61, 73, 105, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	59, 61, 82, 114, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 59, 61, 69, 
	101, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 59, 61, 83, 115, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 33, 37, 39, 59, 
	61, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 59, 
	61, 10, 9, 32, 9, 32, 59, 61, 
	9, 13, 32, 33, 34, 37, 39, 91, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 10, 9, 32, 9, 13, 
	32, 33, 34, 37, 39, 91, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 59, 48, 57, 9, 
	13, 32, 33, 37, 39, 59, 61, 69, 
	101, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 59, 61, 65, 84, 97, 116, 
	126, 42, 43, 45, 46, 48, 57, 66, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 59, 61, 83, 115, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 33, 37, 39, 59, 61, 
	79, 111, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 59, 61, 78, 110, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	59, 61, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	59, 61, 10, 9, 32, 9, 32, 59, 
	61, 9, 13, 32, 33, 34, 37, 39, 
	91, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 10, 9, 32, 9, 
	13, 32, 33, 34, 37, 39, 91, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	59, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 59, 61, 82, 114, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 33, 37, 39, 59, 
	61, 89, 121, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 33, 37, 39, 45, 46, 59, 61, 
	126, 42, 43, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 33, 37, 39, 59, 
	61, 65, 97, 126, 42, 43, 45, 46, 
	48, 57, 66, 90, 95, 122, 9, 13, 
	32, 33, 37, 39, 59, 61, 70, 102, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 59, 61, 84, 116, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 33, 37, 39, 59, 61, 
	69, 101, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 59, 61, 82, 114, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	59, 61, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	59, 61, 10, 9, 32, 9, 32, 59, 
	61, 9, 13, 32, 33, 34, 37, 39, 
	91, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 10, 9, 32, 9, 
	13, 32, 33, 34, 37, 39, 91, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 59, 48, 57, 
	0
];

_tsip_machine_parser_header_Subscription_State_single_lengths = [
	0, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 1, 2, 2, 
	2, 2, 2, 3, 7, 1, 2, 6, 
	8, 4, 1, 2, 3, 11, 1, 2, 
	10, 9, 5, 1, 2, 4, 9, 1, 
	2, 9, 1, 2, 3, 4, 1, 2, 
	4, 1, 0, 8, 1, 2, 2, 2, 
	2, 1, 3, 0, 1, 0, 1, 0, 
	1, 1, 1, 1, 1, 1, 1, 3, 
	3, 2, 2, 2, 2, 2, 0, 3, 
	3, 3, 0, 1, 1, 1, 1, 11, 
	11, 11, 11, 11, 11, 9, 5, 1, 
	2, 4, 9, 1, 2, 9, 4, 11, 
	13, 11, 11, 11, 9, 5, 1, 2, 
	4, 9, 1, 2, 9, 8, 11, 11, 
	11, 11, 11, 11, 11, 11, 9, 5, 
	1, 2, 4, 9, 1, 2, 9, 4, 
	0
];

_tsip_machine_parser_header_Subscription_State_range_lengths = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 5, 0, 0, 5, 
	5, 0, 0, 0, 0, 5, 0, 0, 
	5, 5, 0, 0, 0, 0, 5, 0, 
	0, 5, 0, 0, 0, 2, 0, 0, 
	0, 0, 3, 5, 3, 3, 3, 3, 
	0, 3, 3, 1, 1, 1, 1, 1, 
	1, 1, 0, 1, 0, 1, 0, 3, 
	3, 3, 3, 3, 3, 0, 3, 3, 
	3, 3, 1, 1, 1, 0, 0, 5, 
	5, 5, 5, 5, 5, 5, 0, 0, 
	0, 0, 5, 0, 0, 5, 1, 5, 
	5, 5, 5, 5, 5, 0, 0, 0, 
	0, 5, 0, 0, 5, 5, 5, 5, 
	4, 5, 5, 5, 5, 5, 5, 0, 
	0, 0, 0, 5, 0, 0, 5, 1, 
	0
];

_tsip_machine_parser_header_Subscription_State_index_offsets = [
	0, 0, 3, 6, 9, 12, 15, 18, 
	21, 24, 27, 30, 33, 36, 38, 41, 
	44, 47, 50, 53, 57, 70, 72, 75, 
	87, 101, 106, 108, 111, 115, 132, 134, 
	137, 153, 168, 174, 176, 179, 184, 199, 
	201, 204, 219, 221, 224, 228, 235, 237, 
	240, 245, 247, 251, 265, 270, 276, 282, 
	288, 291, 296, 303, 305, 308, 310, 313, 
	315, 318, 321, 323, 326, 328, 331, 333, 
	340, 347, 353, 359, 365, 371, 374, 378, 
	385, 392, 399, 401, 404, 407, 409, 411, 
	428, 445, 462, 479, 496, 513, 528, 534, 
	536, 539, 544, 559, 561, 564, 579, 585, 
	602, 621, 638, 655, 672, 687, 693, 695, 
	698, 703, 718, 720, 723, 738, 752, 769, 
	786, 802, 819, 836, 853, 870, 887, 902, 
	908, 910, 913, 918, 933, 935, 938, 953, 
	959
];

_tsip_machine_parser_header_Subscription_State_indicies = [
	0, 0, 1, 2, 2, 1, 3, 3, 
	1, 4, 4, 1, 5, 5, 1, 6, 
	6, 1, 7, 7, 1, 8, 8, 1, 
	9, 9, 1, 10, 10, 1, 11, 11, 
	1, 12, 12, 1, 13, 1, 14, 14, 
	1, 15, 15, 1, 16, 16, 1, 17, 
	17, 1, 18, 18, 1, 18, 18, 19, 
	1, 19, 20, 19, 21, 21, 21, 21, 
	21, 21, 21, 21, 21, 1, 22, 1, 
	23, 23, 1, 23, 23, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 1, 24, 
	25, 24, 26, 26, 26, 27, 26, 26, 
	26, 26, 26, 26, 1, 28, 29, 28, 
	30, 1, 31, 1, 32, 32, 1, 32, 
	32, 30, 1, 30, 33, 30, 34, 34, 
	34, 35, 36, 35, 36, 34, 34, 34, 
	34, 34, 34, 1, 37, 1, 38, 38, 
	1, 38, 38, 34, 34, 34, 35, 36, 
	35, 36, 34, 34, 34, 34, 34, 34, 
	1, 39, 40, 39, 41, 41, 41, 42, 
	43, 41, 41, 41, 41, 41, 41, 1, 
	44, 45, 44, 30, 43, 1, 46, 1, 
	47, 47, 1, 47, 47, 30, 43, 1, 
	43, 48, 43, 49, 50, 49, 49, 51, 
	49, 49, 49, 49, 49, 49, 1, 52, 
	1, 53, 53, 1, 53, 54, 53, 49, 
	50, 49, 49, 51, 49, 49, 49, 49, 
	49, 49, 1, 55, 1, 56, 56, 1, 
	56, 56, 50, 1, 50, 57, 58, 59, 
	50, 50, 1, 60, 1, 50, 50, 1, 
	61, 40, 61, 42, 1, 62, 1, 50, 
	50, 50, 1, 61, 40, 61, 49, 49, 
	49, 42, 49, 49, 49, 49, 49, 49, 
	1, 64, 63, 63, 63, 1, 66, 58, 
	65, 65, 65, 1, 66, 58, 67, 67, 
	67, 1, 66, 58, 68, 68, 68, 1, 
	66, 58, 1, 70, 69, 63, 63, 1, 
	71, 66, 58, 72, 65, 65, 1, 73, 
	1, 74, 75, 1, 76, 1, 77, 78, 
	1, 79, 1, 58, 80, 1, 58, 81, 
	1, 58, 1, 77, 82, 1, 77, 1, 
	74, 83, 1, 74, 1, 71, 66, 58, 
	84, 67, 67, 1, 71, 66, 58, 68, 
	68, 68, 1, 86, 58, 85, 85, 85, 
	1, 88, 58, 87, 87, 87, 1, 88, 
	58, 89, 89, 89, 1, 88, 58, 90, 
	90, 90, 1, 88, 58, 1, 91, 85, 
	85, 1, 71, 88, 58, 92, 87, 87, 
	1, 71, 88, 58, 93, 89, 89, 1, 
	71, 88, 58, 90, 90, 90, 1, 94, 
	1, 71, 95, 1, 71, 96, 1, 71, 
	1, 70, 1, 39, 40, 39, 41, 41, 
	41, 42, 43, 97, 97, 41, 41, 41, 
	41, 41, 41, 1, 39, 40, 39, 41, 
	41, 41, 42, 43, 98, 98, 41, 41, 
	41, 41, 41, 41, 1, 39, 40, 39, 
	41, 41, 41, 42, 43, 99, 99, 41, 
	41, 41, 41, 41, 41, 1, 39, 40, 
	39, 41, 41, 41, 42, 43, 100, 100, 
	41, 41, 41, 41, 41, 41, 1, 39, 
	40, 39, 41, 41, 41, 42, 43, 101, 
	101, 41, 41, 41, 41, 41, 41, 1, 
	39, 40, 39, 41, 41, 41, 42, 43, 
	102, 102, 41, 41, 41, 41, 41, 41, 
	1, 103, 40, 103, 41, 41, 41, 42, 
	104, 41, 41, 41, 41, 41, 41, 1, 
	105, 106, 105, 30, 104, 1, 107, 1, 
	108, 108, 1, 108, 108, 30, 104, 1, 
	104, 109, 104, 49, 50, 49, 49, 51, 
	49, 49, 49, 110, 49, 49, 1, 111, 
	1, 112, 112, 1, 112, 54, 112, 49, 
	50, 49, 49, 51, 49, 49, 49, 110, 
	49, 49, 1, 113, 114, 113, 116, 115, 
	1, 39, 40, 39, 41, 41, 41, 42, 
	43, 117, 117, 41, 41, 41, 41, 41, 
	41, 1, 39, 40, 39, 41, 41, 41, 
	42, 43, 118, 119, 118, 119, 41, 41, 
	41, 41, 41, 41, 1, 39, 40, 39, 
	41, 41, 41, 42, 43, 120, 120, 41, 
	41, 41, 41, 41, 41, 1, 39, 40, 
	39, 41, 41, 41, 42, 43, 121, 121, 
	41, 41, 41, 41, 41, 41, 1, 39, 
	40, 39, 41, 41, 41, 42, 43, 122, 
	122, 41, 41, 41, 41, 41, 41, 1, 
	123, 40, 123, 41, 41, 41, 42, 124, 
	41, 41, 41, 41, 41, 41, 1, 125, 
	126, 125, 30, 124, 1, 127, 1, 128, 
	128, 1, 128, 128, 30, 124, 1, 124, 
	129, 124, 130, 50, 130, 130, 51, 130, 
	130, 130, 130, 130, 130, 1, 131, 1, 
	132, 132, 1, 132, 54, 132, 130, 50, 
	130, 130, 51, 130, 130, 130, 130, 130, 
	130, 1, 133, 134, 133, 135, 135, 135, 
	136, 135, 135, 135, 135, 135, 135, 1, 
	39, 40, 39, 41, 41, 41, 42, 43, 
	137, 137, 41, 41, 41, 41, 41, 41, 
	1, 39, 40, 39, 41, 41, 41, 42, 
	43, 138, 138, 41, 41, 41, 41, 41, 
	41, 1, 39, 40, 39, 41, 41, 41, 
	139, 41, 42, 43, 41, 41, 41, 41, 
	41, 1, 39, 40, 39, 41, 41, 41, 
	42, 43, 140, 140, 41, 41, 41, 41, 
	41, 41, 1, 39, 40, 39, 41, 41, 
	41, 42, 43, 141, 141, 41, 41, 41, 
	41, 41, 41, 1, 39, 40, 39, 41, 
	41, 41, 42, 43, 142, 142, 41, 41, 
	41, 41, 41, 41, 1, 39, 40, 39, 
	41, 41, 41, 42, 43, 143, 143, 41, 
	41, 41, 41, 41, 41, 1, 39, 40, 
	39, 41, 41, 41, 42, 43, 144, 144, 
	41, 41, 41, 41, 41, 41, 1, 145, 
	40, 145, 41, 41, 41, 42, 146, 41, 
	41, 41, 41, 41, 41, 1, 147, 148, 
	147, 30, 146, 1, 149, 1, 150, 150, 
	1, 150, 150, 30, 146, 1, 146, 151, 
	146, 49, 50, 49, 49, 51, 49, 49, 
	49, 152, 49, 49, 1, 153, 1, 154, 
	154, 1, 154, 54, 154, 49, 50, 49, 
	49, 51, 49, 49, 49, 152, 49, 49, 
	1, 155, 156, 155, 158, 157, 1, 1, 
	0
];

_tsip_machine_parser_header_Subscription_State_trans_targs = [
	2, 0, 3, 4, 5, 6, 7, 8, 
	9, 10, 11, 12, 13, 14, 15, 16, 
	17, 18, 19, 20, 21, 24, 22, 23, 
	25, 49, 24, 29, 25, 26, 29, 27, 
	28, 30, 33, 87, 103, 31, 32, 34, 
	49, 33, 29, 38, 34, 35, 36, 37, 
	39, 51, 45, 52, 40, 41, 42, 43, 
	44, 46, 48, 50, 47, 25, 136, 53, 
	86, 54, 57, 55, 56, 58, 73, 59, 
	71, 60, 61, 69, 62, 63, 67, 64, 
	65, 66, 68, 70, 72, 74, 82, 75, 
	78, 76, 77, 79, 80, 81, 83, 84, 
	85, 88, 89, 90, 91, 92, 93, 94, 
	98, 94, 95, 96, 97, 99, 102, 100, 
	101, 25, 49, 102, 29, 104, 105, 118, 
	106, 107, 108, 109, 113, 109, 110, 111, 
	112, 114, 117, 115, 116, 25, 49, 117, 
	29, 119, 120, 121, 122, 123, 124, 125, 
	126, 127, 131, 127, 128, 129, 130, 132, 
	135, 133, 134, 25, 49, 135, 29
];

_tsip_machine_parser_header_Subscription_State_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 0, 0, 
	3, 3, 0, 3, 0, 0, 0, 0, 
	0, 0, 1, 1, 1, 0, 0, 11, 
	11, 0, 11, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 11, 13, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 11, 
	0, 0, 0, 0, 0, 0, 1, 0, 
	0, 7, 7, 0, 7, 0, 0, 0, 
	0, 0, 0, 11, 0, 0, 0, 0, 
	0, 0, 1, 0, 0, 5, 5, 0, 
	5, 0, 0, 0, 0, 0, 0, 0, 
	0, 11, 0, 0, 0, 0, 0, 0, 
	1, 0, 0, 9, 9, 0, 9
];

tsip_machine_parser_header_Subscription_State_start = 1;
tsip_machine_parser_header_Subscription_State_first_final = 136;
tsip_machine_parser_header_Subscription_State_error = 0;

tsip_machine_parser_header_Subscription_State_en_main = 1;


/* line 49 "./ragel/tsip_parser_header_Subscription_State.jrl" */

function tsip_header_Subscription_State(s_state, s_reason, i_expires, i_retry_after){
	tsip_header.call(this, tsip_header_type_e.Subscription_State);
    this.s_state = s_state;
    this.s_reason = s_reason;
    this.i_expires = i_expires;
    this.i_retry_after = i_retry_after;
}

tsip_header_Subscription_State.prototype.toString = function(){
    var s_str = tsk_string_format("{0}{1}{2}",
                    this.s_state,
			
			        this.s_reason ? ";reason=" : "",
			        this.s_reason ? this.s_reason : ""
                );
    if(this.i_expires >= 0){
        s_str += tsk_string_format(";expires={0}", this.i_expires);
    }
    if(this.i_retry_after >= 0){
        s_str += tsk_string_format(";retry-after={0}", this.i_retry_after);
    }
    return s_str;
}

tsip_header_Subscription_State.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_Subscription_State = new tsip_header_Subscription_State(null, null, -1, -1);
	
	
/* line 457 "./src/headers/tsip_header_Subscription_State.js" */
{
	 cs = tsip_machine_parser_header_Subscription_State_start;
} /* JSCodeGen::writeInit */

/* line 84 "./ragel/tsip_parser_header_Subscription_State.jrl" */
	
/* line 464 "./src/headers/tsip_header_Subscription_State.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_Subscription_State_key_offsets[cs];
	_trans = _tsip_machine_parser_header_Subscription_State_index_offsets[cs];
	_klen = _tsip_machine_parser_header_Subscription_State_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_Subscription_State_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_Subscription_State_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_Subscription_State_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_Subscription_State_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_Subscription_State_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_Subscription_State_indicies[_trans];
	cs = _tsip_machine_parser_header_Subscription_State_trans_targs[_trans];
	if (_tsip_machine_parser_header_Subscription_State_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_Subscription_State_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_Subscription_State_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_Subscription_State_actions[_acts - 1]) {
case 0:
/* line 13 "./ragel/tsip_parser_header_Subscription_State.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 17 "./ragel/tsip_parser_header_Subscription_State.jrl" */

		hdr_Subscription_State.s_state = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 2:
/* line 21 "./ragel/tsip_parser_header_Subscription_State.jrl" */

	    hdr_Subscription_State.s_reason = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 3:
/* line 25 "./ragel/tsip_parser_header_Subscription_State.jrl" */

	    hdr_Subscription_State.i_expires = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 4:
/* line 29 "./ragel/tsip_parser_header_Subscription_State.jrl" */

	    hdr_Subscription_State.i_retry_after = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 5:
/* line 33 "./ragel/tsip_parser_header_Subscription_State.jrl" */

		tsk_ragel_add_param(s_str, p, i_tag_start, hdr_Subscription_State.ao_params);
			break;
case 6:
/* line 37 "./ragel/tsip_parser_header_Subscription_State.jrl" */

			break;
/* line 582 "./src/headers/tsip_header_Subscription_State.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 85 "./ragel/tsip_parser_header_Subscription_State.jrl" */
	
	if( cs < 
/* line 612 "./src/headers/tsip_header_Subscription_State.js" */
136
/* line 86 "./ragel/tsip_parser_header_Subscription_State.jrl" */
 ){
		tsk_utils_log_error("Failed to parse 'Subscription-State' header: " + s_str);
		return null;
	}
	
	return hdr_Subscription_State;
}


/* line 1 "./ragel/tsip_parser_header_Via.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_Via.prototype = Object.create(tsip_header.prototype);
tsip_header_Via.prototype.__s_proto_name_default = "SIP";
tsip_header_Via.prototype.__s_proto_version_default = "2.0";


/* line 113 "./ragel/tsip_parser_header_Via.jrl" */




/* line 19 "./src/headers/tsip_header_Via.js" */
_tsip_machine_parser_header_Via_actions = [
	0, 1, 0, 1, 2, 1, 3, 1, 
	4, 1, 5, 1, 6, 1, 7, 1, 
	8, 1, 9, 1, 10, 1, 11, 1, 
	13, 1, 14, 1, 16, 2, 1, 0, 
	2, 4, 15, 2, 5, 15, 2, 7, 
	15, 2, 8, 15, 2, 9, 15, 2, 
	10, 15, 2, 11, 15, 2, 12, 13, 
	2, 13, 15, 2, 14, 15, 3, 12, 
	13, 15
];

_tsip_machine_parser_header_Via_key_offsets = [
	0, 0, 2, 7, 10, 27, 28, 30, 
	46, 62, 66, 67, 69, 72, 89, 90, 
	92, 108, 124, 128, 129, 131, 134, 151, 
	152, 154, 170, 187, 197, 198, 200, 209, 
	217, 224, 232, 238, 252, 258, 259, 261, 
	266, 271, 272, 274, 278, 285, 290, 291, 
	293, 297, 324, 325, 327, 353, 371, 377, 
	378, 380, 385, 404, 405, 407, 426, 427, 
	429, 432, 440, 441, 443, 448, 449, 455, 
	472, 479, 487, 495, 503, 505, 512, 521, 
	523, 526, 528, 531, 533, 536, 539, 540, 
	543, 544, 547, 548, 557, 566, 574, 582, 
	590, 598, 600, 606, 615, 624, 633, 635, 
	638, 641, 642, 643, 663, 683, 703, 723, 
	743, 761, 767, 768, 770, 775, 794, 795, 
	797, 816, 833, 853, 873, 893, 911, 917, 
	918, 920, 925, 944, 945, 947, 966, 983, 
	1003, 1023, 1043, 1063, 1081, 1087, 1088, 1090, 
	1095, 1116, 1117, 1119, 1140, 1161, 1181, 1202, 
	1221, 1234, 1241, 1252, 1260, 1267, 1273, 1292, 
	1313, 1332, 1353, 1372, 1385, 1398, 1411, 1432, 
	1453, 1474, 1495, 1516, 1537, 1544, 1552, 1560, 
	1568, 1570, 1577, 1586, 1588, 1591, 1593, 1596, 
	1598, 1601, 1604, 1605, 1610, 1613, 1614, 1617, 
	1618, 1627, 1636, 1644, 1652, 1660, 1668, 1670, 
	1676, 1685, 1694, 1703, 1705, 1708, 1711, 1712, 
	1713, 1735, 1755, 1775, 1795, 1815, 1835, 1855, 
	1873, 1879, 1880, 1882, 1887, 1913, 1914, 1916, 
	1942, 1955, 1957, 1960, 1962, 1965, 1967, 1974, 
	1981, 1986, 1989, 1990, 1993, 1994, 2007, 2020, 
	2026, 2033, 2045, 2057, 2069, 2081, 2087, 2093, 
	2106, 2119, 2132, 2134, 2137, 2140, 2141, 2153, 
	2165, 2177, 2178, 2198, 2218, 2238, 2244, 2250, 
	2251, 2253, 2258, 2263, 2264, 2266, 2270, 2277, 
	2297, 2317, 2335, 2341, 2342, 2344, 2349, 2368, 
	2369, 2371, 2390, 2397, 2404, 2409, 2416, 2428, 
	2434, 2442, 2448, 2456, 2462, 2476, 2490, 2504, 
	2512, 2520, 2528, 2536, 2544, 2552, 2559, 2567, 
	2575, 2583, 2585, 2592, 2601, 2603, 2606, 2608, 
	2611, 2613, 2616, 2619, 2620, 2626, 2629, 2630, 
	2633, 2634, 2643, 2652, 2660, 2668, 2676, 2684, 
	2686, 2692, 2701, 2710, 2719, 2721, 2724, 2727, 
	2728, 2729, 2731
];

_tsip_machine_parser_header_Via_trans_keys = [
	86, 118, 9, 32, 58, 73, 105, 9, 
	32, 58, 9, 13, 32, 33, 37, 39, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 10, 9, 32, 9, 32, 
	33, 37, 39, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 33, 37, 39, 47, 126, 42, 43, 
	45, 57, 65, 90, 95, 122, 9, 13, 
	32, 47, 10, 9, 32, 9, 32, 47, 
	9, 13, 32, 33, 37, 39, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 10, 9, 32, 9, 32, 33, 37, 
	39, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 13, 32, 33, 
	37, 39, 47, 126, 42, 43, 45, 57, 
	65, 90, 95, 122, 9, 13, 32, 47, 
	10, 9, 32, 9, 32, 47, 9, 13, 
	32, 33, 37, 39, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 10, 
	9, 32, 9, 32, 33, 37, 39, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 91, 48, 
	57, 65, 90, 97, 122, 10, 9, 32, 
	9, 32, 91, 48, 57, 65, 90, 97, 
	122, 45, 46, 48, 57, 65, 90, 97, 
	122, 45, 48, 57, 65, 90, 97, 122, 
	45, 46, 48, 57, 65, 90, 97, 122, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 44, 45, 46, 58, 59, 48, 57, 
	65, 90, 97, 122, 9, 13, 32, 44, 
	58, 59, 10, 9, 32, 9, 32, 44, 
	58, 59, 9, 13, 32, 48, 57, 10, 
	9, 32, 9, 32, 48, 57, 9, 13, 
	32, 44, 59, 48, 57, 9, 13, 32, 
	44, 59, 10, 9, 32, 9, 32, 44, 
	59, 9, 13, 32, 33, 37, 39, 66, 
	67, 77, 82, 84, 98, 99, 109, 114, 
	116, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 10, 9, 32, 9, 
	32, 33, 37, 39, 66, 67, 77, 82, 
	84, 98, 99, 109, 114, 116, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 33, 37, 39, 44, 
	59, 61, 126, 42, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 44, 59, 
	61, 10, 9, 32, 9, 32, 44, 59, 
	61, 9, 13, 32, 33, 34, 37, 39, 
	91, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 10, 9, 32, 9, 
	13, 32, 33, 34, 37, 39, 91, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 10, 9, 32, 9, 32, 34, 
	9, 13, 34, 92, 32, 126, 128, 255, 
	10, 9, 32, 9, 13, 32, 44, 59, 
	10, 0, 9, 11, 12, 14, 127, 9, 
	13, 32, 33, 37, 39, 44, 59, 126, 
	42, 46, 48, 57, 65, 90, 95, 122, 
	58, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 58, 48, 57, 65, 70, 97, 102, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 48, 57, 46, 48, 57, 48, 57, 
	46, 48, 57, 48, 57, 93, 48, 57, 
	93, 48, 57, 93, 46, 48, 57, 46, 
	46, 48, 57, 46, 46, 58, 93, 48, 
	57, 65, 70, 97, 102, 46, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 58, 93, 
	48, 57, 65, 70, 97, 102, 46, 58, 
	93, 48, 57, 65, 70, 97, 102, 46, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 48, 57, 46, 48, 57, 46, 48, 
	57, 46, 58, 9, 13, 32, 33, 37, 
	39, 44, 59, 61, 82, 114, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	65, 97, 126, 42, 46, 48, 57, 66, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 44, 59, 61, 78, 110, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	67, 99, 126, 42, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 44, 59, 61, 72, 104, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	126, 42, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 44, 59, 61, 10, 
	9, 32, 9, 32, 44, 59, 61, 9, 
	13, 32, 33, 34, 37, 39, 91, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 10, 9, 32, 9, 13, 32, 
	33, 34, 37, 39, 91, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 13, 32, 33, 37, 39, 44, 59, 
	126, 42, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 33, 37, 39, 44, 
	59, 61, 79, 111, 126, 42, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 44, 59, 61, 77, 109, 
	126, 42, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 33, 37, 39, 44, 
	59, 61, 80, 112, 126, 42, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 44, 59, 61, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 44, 59, 61, 10, 9, 32, 
	9, 32, 44, 59, 61, 9, 13, 32, 
	33, 34, 37, 39, 91, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	10, 9, 32, 9, 13, 32, 33, 34, 
	37, 39, 91, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 33, 37, 39, 44, 59, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	65, 97, 126, 42, 46, 48, 57, 66, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 44, 59, 61, 68, 100, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	68, 100, 126, 42, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 44, 59, 61, 82, 114, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	126, 42, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 44, 59, 61, 10, 
	9, 32, 9, 32, 44, 59, 61, 9, 
	13, 32, 33, 34, 37, 39, 91, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 96, 97, 122, 10, 9, 32, 9, 
	13, 32, 33, 34, 37, 39, 91, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 96, 97, 122, 9, 13, 32, 33, 
	37, 39, 44, 45, 46, 59, 126, 42, 
	43, 48, 57, 65, 90, 95, 96, 97, 
	122, 9, 13, 32, 33, 37, 39, 44, 
	45, 59, 126, 42, 46, 48, 57, 65, 
	90, 95, 96, 97, 122, 9, 13, 32, 
	33, 37, 39, 44, 45, 46, 59, 126, 
	42, 43, 48, 57, 65, 90, 95, 96, 
	97, 122, 9, 13, 32, 33, 37, 39, 
	44, 59, 126, 42, 46, 48, 57, 65, 
	90, 95, 96, 97, 122, 9, 13, 32, 
	44, 45, 46, 59, 48, 57, 65, 90, 
	97, 122, 45, 48, 57, 65, 90, 97, 
	122, 9, 13, 32, 44, 59, 48, 57, 
	65, 90, 97, 122, 45, 46, 48, 57, 
	65, 90, 97, 122, 45, 48, 57, 65, 
	90, 97, 122, 48, 57, 65, 90, 97, 
	122, 9, 13, 32, 33, 37, 39, 44, 
	59, 126, 42, 46, 48, 57, 65, 90, 
	95, 96, 97, 122, 9, 13, 32, 33, 
	37, 39, 44, 45, 46, 59, 126, 42, 
	43, 48, 57, 65, 90, 95, 96, 97, 
	122, 9, 13, 32, 33, 37, 39, 44, 
	59, 126, 42, 46, 48, 57, 65, 90, 
	95, 96, 97, 122, 9, 13, 32, 33, 
	37, 39, 44, 45, 46, 59, 126, 42, 
	43, 48, 57, 65, 90, 95, 96, 97, 
	122, 9, 13, 32, 33, 37, 39, 44, 
	59, 126, 42, 46, 48, 57, 65, 90, 
	95, 96, 97, 122, 9, 13, 32, 44, 
	45, 46, 59, 48, 57, 65, 90, 97, 
	122, 9, 13, 32, 44, 45, 46, 59, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 44, 45, 46, 59, 48, 57, 65, 
	90, 97, 122, 9, 13, 32, 33, 37, 
	39, 44, 45, 46, 59, 126, 42, 43, 
	48, 57, 65, 90, 95, 96, 97, 122, 
	9, 13, 32, 33, 37, 39, 44, 45, 
	46, 59, 126, 42, 43, 48, 57, 65, 
	90, 95, 96, 97, 122, 9, 13, 32, 
	33, 37, 39, 44, 45, 46, 59, 126, 
	42, 43, 48, 57, 65, 90, 95, 96, 
	97, 122, 9, 13, 32, 33, 37, 39, 
	44, 45, 46, 59, 126, 42, 43, 48, 
	57, 65, 90, 95, 96, 97, 122, 9, 
	13, 32, 33, 37, 39, 44, 45, 46, 
	59, 126, 42, 43, 48, 57, 65, 90, 
	95, 96, 97, 122, 9, 13, 32, 33, 
	37, 39, 44, 45, 46, 59, 126, 42, 
	43, 48, 57, 65, 90, 95, 96, 97, 
	122, 58, 48, 57, 65, 70, 97, 102, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	58, 93, 48, 57, 65, 70, 97, 102, 
	58, 93, 58, 48, 57, 65, 70, 97, 
	102, 46, 58, 93, 48, 57, 65, 70, 
	97, 102, 48, 57, 46, 48, 57, 48, 
	57, 46, 48, 57, 48, 57, 93, 48, 
	57, 93, 48, 57, 93, 9, 13, 32, 
	44, 59, 46, 48, 57, 46, 46, 48, 
	57, 46, 46, 58, 93, 48, 57, 65, 
	70, 97, 102, 46, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 46, 58, 93, 48, 
	57, 65, 70, 97, 102, 46, 58, 93, 
	48, 57, 65, 70, 97, 102, 46, 58, 
	93, 48, 57, 65, 70, 97, 102, 48, 
	57, 46, 48, 57, 46, 48, 57, 46, 
	58, 9, 13, 32, 33, 37, 39, 44, 
	59, 61, 69, 80, 101, 112, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	67, 99, 126, 42, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 44, 59, 61, 69, 101, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	73, 105, 126, 42, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 44, 59, 61, 86, 118, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	69, 101, 126, 42, 46, 48, 57, 65, 
	90, 95, 122, 9, 13, 32, 33, 37, 
	39, 44, 59, 61, 68, 100, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 33, 37, 39, 44, 59, 61, 
	126, 42, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 44, 59, 61, 10, 
	9, 32, 9, 32, 44, 59, 61, 9, 
	13, 32, 33, 34, 37, 39, 58, 91, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	70, 71, 90, 95, 96, 97, 102, 103, 
	122, 10, 9, 32, 9, 13, 32, 33, 
	34, 37, 39, 58, 91, 126, 42, 43, 
	45, 46, 48, 57, 65, 70, 71, 90, 
	95, 96, 97, 102, 103, 122, 9, 13, 
	32, 44, 46, 58, 59, 48, 57, 65, 
	70, 97, 102, 48, 57, 46, 48, 57, 
	48, 57, 46, 48, 57, 48, 57, 9, 
	13, 32, 44, 59, 48, 57, 9, 13, 
	32, 44, 59, 48, 57, 9, 13, 32, 
	44, 59, 46, 48, 57, 46, 46, 48, 
	57, 46, 9, 13, 32, 44, 46, 58, 
	59, 48, 57, 65, 70, 97, 102, 9, 
	13, 32, 44, 46, 58, 59, 48, 57, 
	65, 70, 97, 102, 9, 13, 32, 44, 
	58, 59, 58, 48, 57, 65, 70, 97, 
	102, 9, 13, 32, 44, 58, 59, 48, 
	57, 65, 70, 97, 102, 9, 13, 32, 
	44, 58, 59, 48, 57, 65, 70, 97, 
	102, 9, 13, 32, 44, 58, 59, 48, 
	57, 65, 70, 97, 102, 9, 13, 32, 
	44, 58, 59, 48, 57, 65, 70, 97, 
	102, 9, 13, 32, 44, 58, 59, 48, 
	57, 65, 70, 97, 102, 9, 13, 32, 
	44, 46, 58, 59, 48, 57, 65, 70, 
	97, 102, 9, 13, 32, 44, 46, 58, 
	59, 48, 57, 65, 70, 97, 102, 9, 
	13, 32, 44, 46, 58, 59, 48, 57, 
	65, 70, 97, 102, 48, 57, 46, 48, 
	57, 46, 48, 57, 46, 9, 13, 32, 
	44, 58, 59, 48, 57, 65, 70, 97, 
	102, 9, 13, 32, 44, 58, 59, 48, 
	57, 65, 70, 97, 102, 9, 13, 32, 
	44, 58, 59, 48, 57, 65, 70, 97, 
	102, 58, 9, 13, 32, 33, 37, 39, 
	44, 59, 61, 79, 111, 126, 42, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 33, 37, 39, 44, 59, 61, 82, 
	114, 126, 42, 46, 48, 57, 65, 90, 
	95, 122, 9, 13, 32, 33, 37, 39, 
	44, 59, 61, 84, 116, 126, 42, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 44, 59, 61, 9, 13, 32, 44, 
	59, 61, 10, 9, 32, 9, 32, 44, 
	59, 61, 9, 13, 32, 48, 57, 10, 
	9, 32, 9, 32, 48, 57, 9, 13, 
	32, 44, 59, 48, 57, 9, 13, 32, 
	33, 37, 39, 44, 59, 61, 84, 116, 
	126, 42, 46, 48, 57, 65, 90, 95, 
	122, 9, 13, 32, 33, 37, 39, 44, 
	59, 61, 76, 108, 126, 42, 46, 48, 
	57, 65, 90, 95, 122, 9, 13, 32, 
	33, 37, 39, 44, 59, 61, 126, 42, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	13, 32, 44, 59, 61, 10, 9, 32, 
	9, 32, 44, 59, 61, 9, 13, 32, 
	33, 34, 37, 39, 91, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	10, 9, 32, 9, 13, 32, 33, 34, 
	37, 39, 91, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 13, 
	32, 44, 59, 48, 57, 9, 13, 32, 
	44, 59, 48, 57, 9, 13, 32, 44, 
	59, 45, 48, 57, 65, 90, 97, 122, 
	9, 13, 32, 44, 58, 59, 48, 57, 
	65, 90, 97, 122, 48, 57, 65, 90, 
	97, 122, 45, 46, 48, 57, 65, 90, 
	97, 122, 48, 57, 65, 90, 97, 122, 
	45, 46, 48, 57, 65, 90, 97, 122, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 44, 45, 46, 58, 59, 48, 57, 
	65, 90, 97, 122, 9, 13, 32, 44, 
	45, 46, 58, 59, 48, 57, 65, 90, 
	97, 122, 9, 13, 32, 44, 45, 46, 
	58, 59, 48, 57, 65, 90, 97, 122, 
	45, 46, 48, 57, 65, 90, 97, 122, 
	45, 46, 48, 57, 65, 90, 97, 122, 
	45, 46, 48, 57, 65, 90, 97, 122, 
	45, 46, 48, 57, 65, 90, 97, 122, 
	45, 46, 48, 57, 65, 90, 97, 122, 
	45, 46, 48, 57, 65, 90, 97, 122, 
	58, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 48, 57, 65, 70, 97, 102, 58, 
	93, 58, 48, 57, 65, 70, 97, 102, 
	46, 58, 93, 48, 57, 65, 70, 97, 
	102, 48, 57, 46, 48, 57, 48, 57, 
	46, 48, 57, 48, 57, 93, 48, 57, 
	93, 48, 57, 93, 9, 13, 32, 44, 
	58, 59, 46, 48, 57, 46, 46, 48, 
	57, 46, 46, 58, 93, 48, 57, 65, 
	70, 97, 102, 46, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 58, 93, 48, 57, 
	65, 70, 97, 102, 46, 58, 93, 48, 
	57, 65, 70, 97, 102, 46, 58, 93, 
	48, 57, 65, 70, 97, 102, 46, 58, 
	93, 48, 57, 65, 70, 97, 102, 48, 
	57, 46, 48, 57, 46, 48, 57, 46, 
	58, 65, 97, 0
];

_tsip_machine_parser_header_Via_single_lengths = [
	0, 2, 5, 3, 7, 1, 2, 6, 
	8, 4, 1, 2, 3, 7, 1, 2, 
	6, 8, 4, 1, 2, 3, 7, 1, 
	2, 6, 7, 4, 1, 2, 3, 2, 
	1, 2, 0, 8, 6, 1, 2, 5, 
	3, 1, 2, 2, 5, 5, 1, 2, 
	4, 17, 1, 2, 16, 10, 6, 1, 
	2, 5, 9, 1, 2, 9, 1, 2, 
	3, 4, 1, 2, 5, 1, 0, 9, 
	1, 2, 2, 2, 2, 1, 3, 0, 
	1, 0, 1, 0, 1, 1, 1, 1, 
	1, 1, 1, 3, 3, 2, 2, 2, 
	2, 2, 0, 3, 3, 3, 0, 1, 
	1, 1, 1, 12, 12, 12, 12, 12, 
	10, 6, 1, 2, 5, 9, 1, 2, 
	9, 9, 12, 12, 12, 10, 6, 1, 
	2, 5, 9, 1, 2, 9, 9, 12, 
	12, 12, 12, 10, 6, 1, 2, 5, 
	9, 1, 2, 9, 11, 10, 11, 9, 
	7, 1, 5, 2, 1, 0, 9, 11, 
	9, 11, 9, 7, 7, 7, 11, 11, 
	11, 11, 11, 11, 1, 2, 2, 2, 
	2, 1, 3, 0, 1, 0, 1, 0, 
	1, 1, 1, 5, 1, 1, 1, 1, 
	3, 3, 2, 2, 2, 2, 2, 0, 
	3, 3, 3, 0, 1, 1, 1, 1, 
	14, 12, 12, 12, 12, 12, 12, 10, 
	6, 1, 2, 5, 10, 1, 2, 10, 
	7, 0, 1, 0, 1, 0, 5, 5, 
	5, 1, 1, 1, 1, 7, 7, 6, 
	1, 6, 6, 6, 6, 6, 0, 7, 
	7, 7, 0, 1, 1, 1, 6, 6, 
	6, 1, 12, 12, 12, 6, 6, 1, 
	2, 5, 3, 1, 2, 2, 5, 12, 
	12, 10, 6, 1, 2, 5, 9, 1, 
	2, 9, 5, 5, 5, 1, 6, 0, 
	2, 0, 2, 0, 8, 8, 8, 2, 
	2, 2, 2, 2, 2, 1, 2, 2, 
	2, 2, 1, 3, 0, 1, 0, 1, 
	0, 1, 1, 1, 6, 1, 1, 1, 
	1, 3, 3, 2, 2, 2, 2, 2, 
	0, 3, 3, 3, 0, 1, 1, 1, 
	1, 2, 0
];

_tsip_machine_parser_header_Via_range_lengths = [
	0, 0, 0, 0, 5, 0, 0, 5, 
	4, 0, 0, 0, 0, 5, 0, 0, 
	5, 4, 0, 0, 0, 0, 5, 0, 
	0, 5, 5, 3, 0, 0, 3, 3, 
	3, 3, 3, 3, 0, 0, 0, 0, 
	1, 0, 0, 1, 1, 0, 0, 0, 
	0, 5, 0, 0, 5, 4, 0, 0, 
	0, 0, 5, 0, 0, 5, 0, 0, 
	0, 2, 0, 0, 0, 0, 3, 4, 
	3, 3, 3, 3, 0, 3, 3, 1, 
	1, 1, 1, 1, 1, 1, 0, 1, 
	0, 1, 0, 3, 3, 3, 3, 3, 
	3, 0, 3, 3, 3, 3, 1, 1, 
	1, 0, 0, 4, 4, 4, 4, 4, 
	4, 0, 0, 0, 0, 5, 0, 0, 
	5, 4, 4, 4, 4, 4, 0, 0, 
	0, 0, 5, 0, 0, 5, 4, 4, 
	4, 4, 4, 4, 0, 0, 0, 0, 
	6, 0, 0, 6, 5, 5, 5, 5, 
	3, 3, 3, 3, 3, 3, 5, 5, 
	5, 5, 5, 3, 3, 3, 5, 5, 
	5, 5, 5, 5, 3, 3, 3, 3, 
	0, 3, 3, 1, 1, 1, 1, 1, 
	1, 1, 0, 0, 1, 0, 1, 0, 
	3, 3, 3, 3, 3, 3, 0, 3, 
	3, 3, 3, 1, 1, 1, 0, 0, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	0, 0, 0, 0, 8, 0, 0, 8, 
	3, 1, 1, 1, 1, 1, 1, 1, 
	0, 1, 0, 1, 0, 3, 3, 0, 
	3, 3, 3, 3, 3, 0, 3, 3, 
	3, 3, 1, 1, 1, 0, 3, 3, 
	3, 0, 4, 4, 4, 0, 0, 0, 
	0, 0, 1, 0, 0, 1, 1, 4, 
	4, 4, 0, 0, 0, 0, 5, 0, 
	0, 5, 1, 1, 0, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 0, 3, 3, 1, 1, 1, 1, 
	1, 1, 1, 0, 0, 1, 0, 1, 
	0, 3, 3, 3, 3, 3, 3, 0, 
	3, 3, 3, 3, 1, 1, 1, 0, 
	0, 0, 0
];

_tsip_machine_parser_header_Via_index_offsets = [
	0, 0, 3, 9, 13, 26, 28, 31, 
	43, 56, 61, 63, 66, 70, 83, 85, 
	88, 100, 113, 118, 120, 123, 127, 140, 
	142, 145, 157, 170, 178, 180, 183, 190, 
	196, 201, 207, 211, 223, 230, 232, 235, 
	241, 246, 248, 251, 255, 262, 268, 270, 
	273, 278, 301, 303, 306, 328, 343, 350, 
	352, 355, 361, 376, 378, 381, 396, 398, 
	401, 405, 412, 414, 417, 423, 425, 429, 
	443, 448, 454, 460, 466, 469, 474, 481, 
	483, 486, 488, 491, 493, 496, 499, 501, 
	504, 506, 509, 511, 518, 525, 531, 537, 
	543, 549, 552, 556, 563, 570, 577, 579, 
	582, 585, 587, 589, 606, 623, 640, 657, 
	674, 689, 696, 698, 701, 707, 722, 724, 
	727, 742, 756, 773, 790, 807, 822, 829, 
	831, 834, 840, 855, 857, 860, 875, 889, 
	906, 923, 940, 957, 972, 979, 981, 984, 
	990, 1006, 1008, 1011, 1027, 1044, 1060, 1077, 
	1092, 1103, 1108, 1117, 1123, 1128, 1132, 1147, 
	1164, 1179, 1196, 1211, 1222, 1233, 1244, 1261, 
	1278, 1295, 1312, 1329, 1346, 1351, 1357, 1363, 
	1369, 1372, 1377, 1384, 1386, 1389, 1391, 1394, 
	1396, 1399, 1402, 1404, 1410, 1413, 1415, 1418, 
	1420, 1427, 1434, 1440, 1446, 1452, 1458, 1461, 
	1465, 1472, 1479, 1486, 1488, 1491, 1494, 1496, 
	1498, 1517, 1534, 1551, 1568, 1585, 1602, 1619, 
	1634, 1641, 1643, 1646, 1652, 1671, 1673, 1676, 
	1695, 1706, 1708, 1711, 1713, 1716, 1718, 1725, 
	1732, 1738, 1741, 1743, 1746, 1748, 1759, 1770, 
	1777, 1782, 1792, 1802, 1812, 1822, 1829, 1833, 
	1844, 1855, 1866, 1868, 1871, 1874, 1876, 1886, 
	1896, 1906, 1908, 1925, 1942, 1959, 1966, 1973, 
	1975, 1978, 1984, 1989, 1991, 1994, 1998, 2005, 
	2022, 2039, 2054, 2061, 2063, 2066, 2072, 2087, 
	2089, 2092, 2107, 2114, 2121, 2127, 2132, 2142, 
	2146, 2152, 2156, 2162, 2166, 2178, 2190, 2202, 
	2208, 2214, 2220, 2226, 2232, 2238, 2243, 2249, 
	2255, 2261, 2264, 2269, 2276, 2278, 2281, 2283, 
	2286, 2288, 2291, 2294, 2296, 2303, 2306, 2308, 
	2311, 2313, 2320, 2327, 2333, 2339, 2345, 2351, 
	2354, 2358, 2365, 2372, 2379, 2381, 2384, 2387, 
	2389, 2391, 2394
];

_tsip_machine_parser_header_Via_indicies = [
	0, 0, 1, 2, 2, 3, 4, 4, 
	1, 2, 2, 3, 1, 3, 5, 3, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 1, 7, 1, 8, 8, 1, 8, 
	8, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 1, 9, 10, 9, 11, 11, 
	11, 12, 11, 11, 11, 11, 11, 1, 
	13, 14, 13, 15, 1, 16, 1, 17, 
	17, 1, 17, 17, 15, 1, 15, 18, 
	15, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 1, 20, 1, 21, 21, 1, 
	21, 21, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 1, 22, 23, 22, 24, 
	24, 24, 25, 24, 24, 24, 24, 24, 
	1, 26, 27, 26, 28, 1, 29, 1, 
	30, 30, 1, 30, 30, 28, 1, 28, 
	31, 28, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 1, 33, 1, 34, 34, 
	1, 34, 34, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 1, 35, 36, 35, 
	37, 37, 37, 37, 37, 37, 37, 37, 
	37, 1, 38, 39, 38, 42, 40, 41, 
	41, 1, 43, 1, 44, 44, 1, 44, 
	44, 42, 40, 41, 41, 1, 45, 46, 
	47, 48, 48, 1, 45, 48, 48, 48, 
	1, 45, 49, 48, 48, 48, 1, 48, 
	50, 50, 1, 51, 52, 51, 53, 54, 
	55, 56, 57, 50, 50, 50, 1, 58, 
	59, 58, 3, 60, 61, 1, 62, 1, 
	63, 63, 1, 63, 63, 3, 60, 61, 
	1, 60, 64, 60, 65, 1, 66, 1, 
	67, 67, 1, 67, 67, 65, 1, 68, 
	69, 68, 70, 72, 71, 1, 73, 74, 
	73, 3, 61, 1, 75, 1, 76, 76, 
	1, 76, 76, 3, 61, 1, 61, 77, 
	61, 78, 78, 78, 79, 80, 81, 82, 
	83, 79, 80, 81, 82, 83, 78, 78, 
	78, 78, 78, 78, 1, 84, 1, 85, 
	85, 1, 85, 85, 78, 78, 78, 79, 
	80, 81, 82, 83, 79, 80, 81, 82, 
	83, 78, 78, 78, 78, 78, 78, 1, 
	86, 87, 86, 88, 88, 88, 89, 90, 
	91, 88, 88, 88, 88, 88, 1, 92, 
	93, 92, 3, 61, 91, 1, 94, 1, 
	95, 95, 1, 95, 95, 3, 61, 91, 
	1, 91, 96, 91, 97, 98, 97, 97, 
	99, 97, 97, 97, 97, 97, 97, 1, 
	100, 1, 101, 101, 1, 101, 102, 101, 
	97, 98, 97, 97, 99, 97, 97, 97, 
	97, 97, 97, 1, 103, 1, 104, 104, 
	1, 104, 104, 98, 1, 98, 105, 106, 
	107, 98, 98, 1, 108, 1, 98, 98, 
	1, 109, 87, 109, 89, 90, 1, 110, 
	1, 98, 98, 98, 1, 109, 87, 109, 
	97, 97, 97, 89, 90, 97, 97, 97, 
	97, 97, 1, 112, 111, 111, 111, 1, 
	114, 106, 113, 113, 113, 1, 114, 106, 
	115, 115, 115, 1, 114, 106, 116, 116, 
	116, 1, 114, 106, 1, 118, 117, 111, 
	111, 1, 119, 114, 106, 120, 113, 113, 
	1, 121, 1, 122, 123, 1, 124, 1, 
	125, 126, 1, 127, 1, 106, 128, 1, 
	106, 129, 1, 106, 1, 125, 130, 1, 
	125, 1, 122, 131, 1, 122, 1, 119, 
	114, 106, 132, 115, 115, 1, 119, 114, 
	106, 116, 116, 116, 1, 134, 106, 133, 
	133, 133, 1, 136, 106, 135, 135, 135, 
	1, 136, 106, 137, 137, 137, 1, 136, 
	106, 138, 138, 138, 1, 136, 106, 1, 
	139, 133, 133, 1, 119, 136, 106, 140, 
	135, 135, 1, 119, 136, 106, 141, 137, 
	137, 1, 119, 136, 106, 138, 138, 138, 
	1, 142, 1, 119, 143, 1, 119, 144, 
	1, 119, 1, 118, 1, 86, 87, 86, 
	88, 88, 88, 89, 90, 91, 145, 145, 
	88, 88, 88, 88, 88, 1, 86, 87, 
	86, 88, 88, 88, 89, 90, 91, 146, 
	146, 88, 88, 88, 88, 88, 1, 86, 
	87, 86, 88, 88, 88, 89, 90, 91, 
	147, 147, 88, 88, 88, 88, 88, 1, 
	86, 87, 86, 88, 88, 88, 89, 90, 
	91, 148, 148, 88, 88, 88, 88, 88, 
	1, 86, 87, 86, 88, 88, 88, 89, 
	90, 91, 149, 149, 88, 88, 88, 88, 
	88, 1, 150, 87, 150, 88, 88, 88, 
	89, 90, 151, 88, 88, 88, 88, 88, 
	1, 152, 153, 152, 3, 61, 151, 1, 
	154, 1, 155, 155, 1, 155, 155, 3, 
	61, 151, 1, 151, 156, 151, 157, 98, 
	157, 157, 99, 157, 157, 157, 157, 157, 
	157, 1, 158, 1, 159, 159, 1, 159, 
	102, 159, 157, 98, 157, 157, 99, 157, 
	157, 157, 157, 157, 157, 1, 160, 161, 
	160, 162, 162, 162, 163, 164, 162, 162, 
	162, 162, 162, 1, 86, 87, 86, 88, 
	88, 88, 89, 90, 91, 165, 165, 88, 
	88, 88, 88, 88, 1, 86, 87, 86, 
	88, 88, 88, 89, 90, 91, 166, 166, 
	88, 88, 88, 88, 88, 1, 86, 87, 
	86, 88, 88, 88, 89, 90, 91, 167, 
	167, 88, 88, 88, 88, 88, 1, 168, 
	87, 168, 88, 88, 88, 89, 90, 169, 
	88, 88, 88, 88, 88, 1, 170, 171, 
	170, 3, 61, 169, 1, 172, 1, 173, 
	173, 1, 173, 173, 3, 61, 169, 1, 
	169, 174, 169, 175, 98, 175, 175, 99, 
	175, 175, 175, 175, 175, 175, 1, 176, 
	1, 177, 177, 1, 177, 102, 177, 175, 
	98, 175, 175, 99, 175, 175, 175, 175, 
	175, 175, 1, 178, 179, 178, 180, 180, 
	180, 181, 182, 180, 180, 180, 180, 180, 
	1, 86, 87, 86, 88, 88, 88, 89, 
	90, 91, 183, 183, 88, 88, 88, 88, 
	88, 1, 86, 87, 86, 88, 88, 88, 
	89, 90, 91, 184, 184, 88, 88, 88, 
	88, 88, 1, 86, 87, 86, 88, 88, 
	88, 89, 90, 91, 185, 185, 88, 88, 
	88, 88, 88, 1, 86, 87, 86, 88, 
	88, 88, 89, 90, 91, 186, 186, 88, 
	88, 88, 88, 88, 1, 187, 87, 187, 
	88, 88, 88, 89, 90, 188, 88, 88, 
	88, 88, 88, 1, 189, 190, 189, 3, 
	61, 188, 1, 191, 1, 192, 192, 1, 
	192, 192, 3, 61, 188, 1, 188, 193, 
	188, 97, 98, 97, 97, 196, 97, 97, 
	97, 194, 195, 97, 195, 1, 197, 1, 
	198, 198, 1, 198, 102, 198, 97, 98, 
	97, 97, 196, 97, 97, 97, 194, 195, 
	97, 195, 1, 109, 87, 109, 97, 97, 
	97, 89, 199, 200, 90, 97, 97, 201, 
	202, 97, 202, 1, 109, 87, 109, 97, 
	97, 97, 89, 199, 90, 97, 97, 202, 
	202, 97, 202, 1, 109, 87, 109, 97, 
	97, 97, 89, 199, 203, 90, 97, 97, 
	202, 202, 97, 202, 1, 109, 87, 109, 
	97, 97, 97, 89, 90, 97, 97, 202, 
	204, 97, 204, 1, 205, 206, 205, 207, 
	208, 209, 210, 204, 204, 204, 1, 208, 
	204, 204, 204, 1, 205, 206, 205, 207, 
	210, 211, 204, 204, 1, 212, 213, 211, 
	211, 211, 1, 212, 211, 211, 211, 1, 
	211, 204, 204, 1, 109, 87, 109, 97, 
	97, 97, 89, 90, 97, 97, 214, 204, 
	97, 204, 1, 109, 87, 109, 97, 97, 
	97, 89, 199, 215, 90, 97, 97, 216, 
	202, 97, 202, 1, 109, 87, 109, 97, 
	97, 97, 89, 90, 97, 97, 217, 204, 
	97, 204, 1, 109, 87, 109, 97, 97, 
	97, 89, 199, 218, 90, 97, 97, 219, 
	202, 97, 202, 1, 109, 87, 109, 97, 
	97, 97, 89, 90, 97, 97, 220, 204, 
	97, 204, 1, 205, 206, 205, 207, 212, 
	213, 210, 221, 211, 211, 1, 205, 206, 
	205, 207, 212, 213, 210, 222, 211, 211, 
	1, 205, 206, 205, 207, 212, 213, 210, 
	211, 211, 211, 1, 109, 87, 109, 97, 
	97, 97, 89, 199, 218, 90, 97, 97, 
	223, 202, 97, 202, 1, 109, 87, 109, 
	97, 97, 97, 89, 199, 218, 90, 97, 
	97, 202, 202, 97, 202, 1, 109, 87, 
	109, 97, 97, 97, 89, 199, 215, 90, 
	97, 97, 224, 202, 97, 202, 1, 109, 
	87, 109, 97, 97, 97, 89, 199, 215, 
	90, 97, 97, 202, 202, 97, 202, 1, 
	109, 87, 109, 97, 97, 97, 89, 199, 
	200, 90, 97, 97, 225, 202, 97, 202, 
	1, 109, 87, 109, 97, 97, 97, 89, 
	199, 200, 90, 97, 97, 202, 202, 97, 
	202, 1, 227, 226, 226, 226, 1, 229, 
	230, 228, 228, 228, 1, 229, 230, 231, 
	231, 231, 1, 229, 230, 232, 232, 232, 
	1, 229, 230, 1, 234, 233, 226, 226, 
	1, 235, 229, 230, 236, 228, 228, 1, 
	237, 1, 238, 239, 1, 240, 1, 241, 
	242, 1, 243, 1, 230, 244, 1, 230, 
	245, 1, 230, 1, 205, 206, 205, 207, 
	210, 1, 241, 246, 1, 241, 1, 238, 
	247, 1, 238, 1, 235, 229, 230, 248, 
	231, 231, 1, 235, 229, 230, 232, 232, 
	232, 1, 250, 230, 249, 249, 249, 1, 
	252, 230, 251, 251, 251, 1, 252, 230, 
	253, 253, 253, 1, 252, 230, 254, 254, 
	254, 1, 252, 230, 1, 255, 249, 249, 
	1, 235, 252, 230, 256, 251, 251, 1, 
	235, 252, 230, 257, 253, 253, 1, 235, 
	252, 230, 254, 254, 254, 1, 258, 1, 
	235, 259, 1, 235, 260, 1, 235, 1, 
	234, 1, 86, 87, 86, 88, 88, 88, 
	89, 90, 91, 261, 262, 261, 262, 88, 
	88, 88, 88, 88, 1, 86, 87, 86, 
	88, 88, 88, 89, 90, 91, 263, 263, 
	88, 88, 88, 88, 88, 1, 86, 87, 
	86, 88, 88, 88, 89, 90, 91, 264, 
	264, 88, 88, 88, 88, 88, 1, 86, 
	87, 86, 88, 88, 88, 89, 90, 91, 
	265, 265, 88, 88, 88, 88, 88, 1, 
	86, 87, 86, 88, 88, 88, 89, 90, 
	91, 266, 266, 88, 88, 88, 88, 88, 
	1, 86, 87, 86, 88, 88, 88, 89, 
	90, 91, 267, 267, 88, 88, 88, 88, 
	88, 1, 86, 87, 86, 88, 88, 88, 
	89, 90, 91, 268, 268, 88, 88, 88, 
	88, 88, 1, 269, 87, 269, 88, 88, 
	88, 89, 90, 270, 88, 88, 88, 88, 
	88, 1, 271, 272, 271, 3, 61, 270, 
	1, 273, 1, 274, 274, 1, 274, 274, 
	3, 61, 270, 1, 270, 275, 270, 97, 
	98, 97, 97, 277, 99, 97, 97, 97, 
	276, 278, 97, 97, 278, 97, 1, 279, 
	1, 280, 280, 1, 280, 102, 280, 97, 
	98, 97, 97, 277, 99, 97, 97, 97, 
	276, 278, 97, 97, 278, 97, 1, 281, 
	282, 281, 283, 284, 286, 287, 285, 288, 
	288, 1, 289, 1, 290, 291, 1, 292, 
	1, 293, 294, 1, 295, 1, 281, 282, 
	281, 283, 287, 296, 1, 281, 282, 281, 
	283, 287, 297, 1, 281, 282, 281, 283, 
	287, 1, 293, 298, 1, 293, 1, 290, 
	299, 1, 290, 1, 281, 282, 281, 283, 
	284, 286, 287, 300, 301, 301, 1, 281, 
	282, 281, 283, 284, 286, 287, 302, 302, 
	302, 1, 281, 282, 281, 283, 286, 287, 
	1, 304, 303, 305, 305, 1, 281, 282, 
	281, 283, 307, 287, 306, 306, 306, 1, 
	281, 282, 281, 283, 309, 287, 308, 308, 
	308, 1, 281, 282, 281, 283, 309, 287, 
	310, 310, 310, 1, 281, 282, 281, 283, 
	309, 287, 311, 311, 311, 1, 281, 282, 
	281, 283, 309, 287, 1, 312, 306, 306, 
	1, 281, 282, 281, 283, 284, 309, 287, 
	313, 308, 308, 1, 281, 282, 281, 283, 
	284, 309, 287, 314, 310, 310, 1, 281, 
	282, 281, 283, 284, 309, 287, 311, 311, 
	311, 1, 315, 1, 284, 316, 1, 284, 
	317, 1, 284, 1, 281, 282, 281, 283, 
	286, 287, 288, 288, 288, 1, 281, 282, 
	281, 283, 286, 287, 301, 301, 301, 1, 
	281, 282, 281, 283, 286, 287, 302, 302, 
	302, 1, 304, 1, 86, 87, 86, 88, 
	88, 88, 89, 90, 91, 318, 318, 88, 
	88, 88, 88, 88, 1, 86, 87, 86, 
	88, 88, 88, 89, 90, 91, 319, 319, 
	88, 88, 88, 88, 88, 1, 86, 87, 
	86, 88, 88, 88, 89, 90, 91, 320, 
	320, 88, 88, 88, 88, 88, 1, 321, 
	322, 321, 323, 324, 325, 1, 326, 327, 
	326, 3, 61, 325, 1, 328, 1, 329, 
	329, 1, 329, 329, 3, 61, 325, 1, 
	325, 330, 325, 331, 1, 332, 1, 333, 
	333, 1, 333, 333, 331, 1, 334, 335, 
	334, 336, 338, 337, 1, 86, 87, 86, 
	88, 88, 88, 89, 90, 91, 339, 339, 
	88, 88, 88, 88, 88, 1, 86, 87, 
	86, 88, 88, 88, 89, 90, 91, 340, 
	340, 88, 88, 88, 88, 88, 1, 341, 
	87, 341, 88, 88, 88, 89, 90, 342, 
	88, 88, 88, 88, 88, 1, 343, 344, 
	343, 3, 61, 342, 1, 345, 1, 346, 
	346, 1, 346, 346, 3, 61, 342, 1, 
	342, 347, 342, 97, 98, 97, 97, 99, 
	97, 97, 97, 348, 97, 97, 1, 349, 
	1, 350, 350, 1, 350, 102, 350, 97, 
	98, 97, 97, 99, 97, 97, 97, 348, 
	97, 97, 1, 351, 352, 351, 353, 355, 
	354, 1, 351, 352, 351, 353, 355, 356, 
	1, 351, 352, 351, 353, 355, 1, 54, 
	50, 50, 50, 1, 51, 52, 51, 53, 
	56, 57, 48, 50, 50, 1, 357, 50, 
	50, 1, 45, 358, 359, 48, 48, 1, 
	360, 50, 50, 1, 45, 361, 362, 48, 
	48, 1, 363, 50, 50, 1, 51, 52, 
	51, 53, 45, 49, 56, 57, 364, 48, 
	48, 1, 51, 52, 51, 53, 45, 49, 
	56, 57, 365, 48, 48, 1, 51, 52, 
	51, 53, 45, 49, 56, 57, 48, 48, 
	48, 1, 45, 361, 366, 48, 48, 1, 
	45, 361, 48, 48, 48, 1, 45, 358, 
	367, 48, 48, 1, 45, 358, 48, 48, 
	48, 1, 45, 46, 368, 48, 48, 1, 
	45, 46, 48, 48, 48, 1, 370, 369, 
	369, 369, 1, 372, 373, 371, 371, 371, 
	1, 372, 373, 374, 374, 374, 1, 372, 
	373, 375, 375, 375, 1, 372, 373, 1, 
	377, 376, 369, 369, 1, 378, 372, 373, 
	379, 371, 371, 1, 380, 1, 381, 382, 
	1, 383, 1, 384, 385, 1, 386, 1, 
	373, 387, 1, 373, 388, 1, 373, 1, 
	51, 52, 51, 53, 56, 57, 1, 384, 
	389, 1, 384, 1, 381, 390, 1, 381, 
	1, 378, 372, 373, 391, 374, 374, 1, 
	378, 372, 373, 375, 375, 375, 1, 393, 
	373, 392, 392, 392, 1, 395, 373, 394, 
	394, 394, 1, 395, 373, 396, 396, 396, 
	1, 395, 373, 397, 397, 397, 1, 395, 
	373, 1, 398, 392, 392, 1, 378, 395, 
	373, 399, 394, 394, 1, 378, 395, 373, 
	400, 396, 396, 1, 378, 395, 373, 397, 
	397, 397, 1, 401, 1, 378, 402, 1, 
	378, 403, 1, 378, 1, 377, 1, 2, 
	2, 1, 1, 0
];

_tsip_machine_parser_header_Via_trans_targs = [
	2, 0, 3, 4, 337, 5, 8, 6, 
	7, 9, 10, 8, 13, 9, 10, 13, 
	11, 12, 14, 17, 15, 16, 18, 19, 
	17, 22, 18, 19, 22, 20, 21, 23, 
	26, 24, 25, 27, 28, 26, 27, 28, 
	31, 35, 301, 29, 30, 32, 287, 299, 
	33, 34, 35, 36, 69, 4, 285, 286, 
	40, 49, 36, 37, 40, 49, 38, 39, 
	41, 44, 42, 43, 45, 69, 4, 44, 
	49, 45, 46, 47, 48, 50, 53, 107, 
	122, 135, 208, 271, 51, 52, 54, 69, 
	53, 4, 49, 58, 54, 55, 56, 57, 
	59, 71, 65, 72, 60, 61, 62, 63, 
	64, 66, 68, 70, 67, 45, 338, 73, 
	106, 74, 77, 75, 76, 78, 93, 79, 
	91, 80, 81, 89, 82, 83, 87, 84, 
	85, 86, 88, 90, 92, 94, 102, 95, 
	98, 96, 97, 99, 100, 101, 103, 104, 
	105, 108, 109, 110, 111, 112, 113, 117, 
	113, 114, 115, 116, 118, 121, 119, 120, 
	45, 69, 121, 4, 49, 123, 124, 125, 
	126, 130, 126, 127, 128, 129, 131, 134, 
	132, 133, 45, 69, 134, 4, 49, 136, 
	137, 138, 139, 140, 144, 140, 141, 142, 
	143, 145, 148, 152, 172, 146, 147, 149, 
	158, 170, 150, 151, 152, 45, 69, 4, 
	153, 154, 49, 155, 156, 157, 159, 160, 
	168, 161, 162, 166, 163, 164, 165, 167, 
	169, 171, 173, 207, 174, 177, 187, 175, 
	176, 178, 194, 179, 192, 180, 181, 190, 
	182, 183, 188, 184, 185, 186, 189, 191, 
	193, 195, 203, 196, 199, 197, 198, 200, 
	201, 202, 204, 205, 206, 209, 258, 210, 
	211, 212, 213, 214, 215, 216, 220, 216, 
	217, 218, 219, 221, 224, 257, 254, 222, 
	223, 45, 69, 4, 225, 237, 240, 49, 
	255, 226, 227, 235, 228, 229, 233, 230, 
	231, 232, 234, 236, 238, 256, 239, 224, 
	241, 254, 242, 250, 243, 246, 244, 245, 
	247, 248, 249, 251, 252, 253, 259, 260, 
	261, 262, 69, 4, 49, 266, 262, 263, 
	264, 265, 267, 270, 268, 269, 45, 69, 
	4, 270, 49, 272, 273, 274, 278, 274, 
	275, 276, 277, 279, 282, 280, 281, 45, 
	69, 4, 283, 49, 284, 288, 289, 297, 
	290, 291, 295, 292, 293, 294, 296, 298, 
	300, 302, 336, 303, 306, 316, 304, 305, 
	307, 323, 308, 321, 309, 310, 319, 311, 
	312, 317, 313, 314, 315, 318, 320, 322, 
	324, 332, 325, 328, 326, 327, 329, 330, 
	331, 333, 334, 335
];

_tsip_machine_parser_header_Via_trans_actions = [
	0, 0, 0, 0, 0, 0, 29, 0, 
	0, 3, 3, 0, 3, 0, 0, 0, 
	0, 0, 0, 1, 0, 0, 5, 5, 
	0, 5, 0, 0, 0, 0, 0, 0, 
	1, 0, 0, 11, 11, 0, 0, 0, 
	1, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 32, 32, 32, 0, 0, 
	7, 7, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 35, 35, 35, 0, 
	9, 0, 0, 0, 0, 0, 1, 1, 
	1, 1, 1, 1, 0, 0, 59, 59, 
	0, 59, 25, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 59, 27, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 59, 0, 
	0, 0, 0, 0, 0, 1, 0, 0, 
	47, 47, 0, 47, 19, 0, 0, 0, 
	59, 0, 0, 0, 0, 0, 0, 1, 
	0, 0, 50, 50, 0, 50, 21, 0, 
	0, 0, 0, 59, 0, 0, 0, 0, 
	0, 0, 1, 1, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 41, 41, 41, 
	0, 0, 15, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 59, 0, 0, 
	0, 0, 0, 0, 1, 1, 1, 0, 
	0, 44, 44, 44, 0, 0, 0, 17, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 56, 56, 56, 23, 0, 0, 0, 
	0, 0, 0, 1, 0, 0, 62, 62, 
	62, 0, 53, 0, 0, 59, 0, 0, 
	0, 0, 0, 0, 1, 0, 0, 38, 
	38, 38, 0, 13, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0
];

tsip_machine_parser_header_Via_start = 1;
tsip_machine_parser_header_Via_first_final = 338;
tsip_machine_parser_header_Via_error = 0;

tsip_machine_parser_header_Via_en_main = 1;


/* line 117 "./ragel/tsip_parser_header_Via.jrl" */

function tsip_header_Via(s_proto_name, s_proto_version, s_transport, s_host, i_port){
	tsip_header.call(this, tsip_header_type_e.Via);
    this.s_branch = null;
	this.s_host = s_host;
	this.i_port = i_port;
	this.s_comp = null;
	this.s_sigcomp_id = null;
	this.s_received = null;
	this.s_maddr = null;
	this.s_proto_name = s_proto_name;
	this.s_proto_version = s_proto_version;
	this.s_transport = s_transport;
	this.i_rport = -1;
	this.i_ttl = -1;
	this.is_transport_reliable = function(){
		return tsk_string_iequals(this.s_transport, "UDP");
	};
	this.is_transport_unreliable = function(){
		return !this.is_transport_reliable();
	};
}

tsip_header_Via.prototype.toString = function(){
	var b_ipv6 = (this.s_host && tsk_string_contains(this.s_host, this.s_host.length, ":"));

	// SIP/2.0/UDP [::]:1988;test=1234;comp=sigcomp;rport=254;ttl=457;received=192.0.2.101;branch=z9hG4bK1245420841406\r\n"
	return tsk_string_format("{0}/{1}/{2} {3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}{16}{17}{18}{19}{20}{21}",

			this.s_proto_name ? this.s_proto_name : "SIP",

			this.s_proto_version ? this.s_proto_version : "2.0",

			this.s_transport ? this.s_transport : "UDP",

			b_ipv6 ? "[" : "",
			this.s_host ? this.s_host : "127.0.0.1",
			b_ipv6 ? "]" : "",

			this.i_port > 0 ? ":" : "",
			this.i_port > 0 ? this.i_port : "",

			this.s_maddr ? ";maddr=" : "",
			this.s_maddr ? this.s_maddr : "",

			this.s_sigcomp_id ? ";sigcomp-id=" : "",
			this.s_sigcomp_id ? this.s_sigcomp_id : "",

			this.s_comp ? ";comp=" : "",
			this.s_comp ? this.s_comp : "",

			this.i_rport>=0 ? (this.i_rport>0?";rport=":";rport") : "",
			this.i_rport>0 ? this.i_rport : "",

			this.i_ttl>=0 ? (this.i_ttl>0?";ttl=":";ttl") : "",
			this.i_ttl>0 ? this.i_ttl : "",

			this.s_received ? ";received=" : "",
			this.s_received ? this.s_received : "",

			this.s_branch ? ";branch=" : "",
			this.s_branch ? this.s_branch : ""
		);
}

// returns an array of 'Via' headers
tsip_header_Via.prototype.Parse = function(s_str){
    var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;
	var hdr_vias = new Array();
	var curr_via = null;
	
	
/* line 1057 "./src/headers/tsip_header_Via.js" */
{
	 cs = tsip_machine_parser_header_Via_start;
} /* JSCodeGen::writeInit */

/* line 194 "./ragel/tsip_parser_header_Via.jrl" */
	
/* line 1064 "./src/headers/tsip_header_Via.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_Via_key_offsets[cs];
	_trans = _tsip_machine_parser_header_Via_index_offsets[cs];
	_klen = _tsip_machine_parser_header_Via_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_Via_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_Via_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_Via_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_Via_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_Via_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_Via_indicies[_trans];
	cs = _tsip_machine_parser_header_Via_trans_targs[_trans];
	if (_tsip_machine_parser_header_Via_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_Via_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_Via_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_Via_actions[_acts - 1]) {
case 0:
/* line 17 "./ragel/tsip_parser_header_Via.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 21 "./ragel/tsip_parser_header_Via.jrl" */

		if(!curr_via){
			curr_via = new tsip_header_Via(null, null, null, null, 0);
		}
			break;
case 2:
/* line 27 "./ragel/tsip_parser_header_Via.jrl" */

	    curr_via.s_proto_name = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 3:
/* line 31 "./ragel/tsip_parser_header_Via.jrl" */

		curr_via.s_proto_version = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 4:
/* line 35 "./ragel/tsip_parser_header_Via.jrl" */

		curr_via.s_host = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
		curr_via.s_host = tsk_string_unquote(curr_via.s_host, '[', ']');
			break;
case 5:
/* line 40 "./ragel/tsip_parser_header_Via.jrl" */

	    curr_via.i_port = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 6:
/* line 44 "./ragel/tsip_parser_header_Via.jrl" */

	    curr_via.s_transport = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 7:
/* line 48 "./ragel/tsip_parser_header_Via.jrl" */

	    curr_via.i_ttl = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 8:
/* line 52 "./ragel/tsip_parser_header_Via.jrl" */

	    curr_via.s_maddr = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 9:
/* line 56 "./ragel/tsip_parser_header_Via.jrl" */

	    curr_via.s_received = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 10:
/* line 60 "./ragel/tsip_parser_header_Via.jrl" */

	    curr_via.s_branch = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 11:
/* line 64 "./ragel/tsip_parser_header_Via.jrl" */

	    curr_via.s_comp = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 12:
/* line 68 "./ragel/tsip_parser_header_Via.jrl" */

	    curr_via.i_rport = tsk_ragel_parser_get_int(s_str, p, i_tag_start);
			break;
case 13:
/* line 72 "./ragel/tsip_parser_header_Via.jrl" */

		if(curr_via.i_rport < 0){
			curr_via.i_rport = 0;
		}
			break;
case 14:
/* line 78 "./ragel/tsip_parser_header_Via.jrl" */

	    if(curr_via){
	        tsk_ragel_add_param(s_str, p, i_tag_start, curr_via.ao_params);
	    }
			break;
case 15:
/* line 84 "./ragel/tsip_parser_header_Via.jrl" */

		if(curr_via){
		    hdr_vias.push(curr_via);
		    curr_via = null;
		}
			break;
case 16:
/* line 91 "./ragel/tsip_parser_header_Via.jrl" */

		
			break;
/* line 1243 "./src/headers/tsip_header_Via.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 195 "./ragel/tsip_parser_header_Via.jrl" */
	
	if( cs < 
/* line 1273 "./src/headers/tsip_header_Via.js" */
338
/* line 196 "./ragel/tsip_parser_header_Via.jrl" */
 ){
		tsk_utils_log_error("Failed to parse 'Via' header: " + s_str);
		return null;
	}
	
	return hdr_vias;
}

/* line 1 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_header_WWW_Authenticate.prototype = Object.create(tsip_header.prototype);

/* line 95 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */



/* line 15 "./src/headers/tsip_header_WWW_Authenticate.js" */
_tsip_machine_parser_header_WWW_Authenticate_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7
];

_tsip_machine_parser_header_WWW_Authenticate_key_offsets = [
	0, 0, 2, 4, 6, 7, 9, 11, 
	13, 15, 17, 19, 21, 23, 25, 27, 
	29, 31, 34, 41, 44, 48, 55, 59, 
	66, 71, 76, 81, 86, 91, 96, 125, 
	129, 158, 182, 189, 193, 200, 225, 229, 
	254, 258, 264, 275, 279, 285, 291, 295, 
	301, 305, 331, 335, 361, 387, 413, 439, 
	463, 470, 474, 481, 506, 510, 535, 539, 
	545, 556, 560, 566, 572, 595, 611, 628, 
	645, 662, 667, 683, 701, 708, 716, 723, 
	731, 738, 746, 754, 758, 766, 770, 778, 
	782, 800, 818, 835, 852, 869, 886, 891, 
	906, 924, 942, 960, 967, 975, 983, 987, 
	991, 995, 1021, 1047, 1073, 1099, 1123, 1130, 
	1134, 1141, 1166, 1170, 1195, 1199, 1205, 1216, 
	1220, 1226, 1232, 1236, 1262, 1288, 1314, 1340, 
	1366, 1392, 1418, 1442, 1449, 1453, 1460, 1485, 
	1489, 1514, 1537, 1541, 1547, 1551, 1556, 1559, 
	1564, 1569, 1574, 1579, 1584, 1589, 1594, 1623, 
	1652, 1657, 1662, 1667, 1672, 1701, 1706, 1711, 
	1716, 1721, 1750, 1755, 1760
];

_tsip_machine_parser_header_WWW_Authenticate_trans_keys = [
	87, 119, 87, 119, 87, 119, 45, 65, 
	97, 85, 117, 84, 116, 72, 104, 69, 
	101, 78, 110, 84, 116, 73, 105, 67, 
	99, 65, 97, 84, 116, 69, 101, 9, 
	32, 58, 9, 13, 32, 68, 100, 0, 
	65535, 13, 0, 65535, 10, 13, 0, 65535, 
	9, 13, 32, 68, 100, 0, 65535, 10, 
	13, 0, 65535, 9, 13, 32, 68, 100, 
	0, 65535, 13, 73, 105, 0, 65535, 13, 
	71, 103, 0, 65535, 13, 69, 101, 0, 
	65535, 13, 83, 115, 0, 65535, 13, 84, 
	116, 0, 65535, 9, 13, 32, 0, 65535, 
	9, 13, 32, 33, 37, 39, 44, 47, 
	65, 78, 82, 97, 110, 114, 126, 0, 
	41, 42, 57, 58, 64, 66, 90, 91, 
	94, 95, 122, 123, 65535, 10, 13, 0, 
	65535, 9, 13, 32, 33, 37, 39, 44, 
	47, 65, 78, 82, 97, 110, 114, 126, 
	0, 41, 42, 57, 58, 64, 66, 90, 
	91, 94, 95, 122, 123, 65535, 9, 13, 
	32, 33, 37, 39, 44, 47, 61, 126, 
	0, 41, 42, 57, 58, 64, 65, 90, 
	91, 94, 95, 122, 123, 65535, 9, 13, 
	32, 44, 61, 0, 65535, 10, 13, 0, 
	65535, 9, 13, 32, 44, 61, 0, 65535, 
	9, 13, 32, 33, 34, 37, 39, 44, 
	47, 91, 126, 0, 41, 42, 57, 58, 
	64, 65, 90, 92, 94, 95, 122, 123, 
	65535, 10, 13, 0, 65535, 9, 13, 32, 
	33, 34, 37, 39, 44, 47, 91, 126, 
	0, 41, 42, 57, 58, 64, 65, 90, 
	92, 94, 95, 122, 123, 65535, 10, 13, 
	0, 65535, 9, 13, 32, 34, 0, 65535, 
	9, 13, 34, 92, 127, 0, 31, 32, 
	255, 256, 65535, 10, 13, 0, 65535, 9, 
	13, 32, 44, 0, 65535, 9, 13, 32, 
	44, 0, 65535, 10, 13, 0, 65535, 9, 
	13, 32, 44, 0, 65535, 10, 13, 0, 
	65535, 9, 13, 32, 33, 37, 39, 44, 
	47, 61, 76, 108, 126, 0, 41, 42, 
	57, 58, 64, 65, 90, 91, 94, 95, 
	122, 123, 65535, 10, 13, 0, 65535, 9, 
	13, 32, 33, 37, 39, 44, 47, 61, 
	79, 111, 126, 0, 41, 42, 57, 58, 
	64, 65, 90, 91, 94, 95, 122, 123, 
	65535, 9, 13, 32, 33, 37, 39, 44, 
	47, 61, 78, 110, 126, 0, 41, 42, 
	57, 58, 64, 65, 90, 91, 94, 95, 
	122, 123, 65535, 9, 13, 32, 33, 37, 
	39, 44, 47, 61, 67, 99, 126, 0, 
	41, 42, 57, 58, 64, 65, 90, 91, 
	94, 95, 122, 123, 65535, 9, 13, 32, 
	33, 37, 39, 44, 47, 61, 69, 101, 
	126, 0, 41, 42, 57, 58, 64, 65, 
	90, 91, 94, 95, 122, 123, 65535, 9, 
	13, 32, 33, 37, 39, 44, 47, 61, 
	126, 0, 41, 42, 57, 58, 64, 65, 
	90, 91, 94, 95, 122, 123, 65535, 9, 
	13, 32, 44, 61, 0, 65535, 10, 13, 
	0, 65535, 9, 13, 32, 44, 61, 0, 
	65535, 9, 13, 32, 33, 34, 37, 39, 
	44, 47, 91, 126, 0, 41, 42, 57, 
	58, 64, 65, 90, 92, 94, 95, 122, 
	123, 65535, 10, 13, 0, 65535, 9, 13, 
	32, 33, 34, 37, 39, 44, 47, 91, 
	126, 0, 41, 42, 57, 58, 64, 65, 
	90, 92, 94, 95, 122, 123, 65535, 10, 
	13, 0, 65535, 9, 13, 32, 34, 0, 
	65535, 9, 13, 34, 92, 127, 0, 31, 
	32, 255, 256, 65535, 10, 13, 0, 65535, 
	9, 13, 32, 44, 0, 65535, 10, 13, 
	0, 127, 128, 65535, 9, 13, 32, 33, 
	37, 39, 44, 47, 126, 0, 41, 42, 
	57, 58, 64, 65, 90, 91, 94, 95, 
	122, 123, 65535, 13, 58, 0, 47, 48, 
	57, 59, 64, 65, 70, 71, 96, 97, 
	102, 103, 65535, 13, 58, 93, 0, 47, 
	48, 57, 59, 64, 65, 70, 71, 96, 
	97, 102, 103, 65535, 13, 58, 93, 0, 
	47, 48, 57, 59, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 13, 58, 93, 
	0, 47, 48, 57, 59, 64, 65, 70, 
	71, 96, 97, 102, 103, 65535, 13, 58, 
	93, 0, 65535, 13, 58, 0, 47, 48, 
	57, 59, 64, 65, 70, 71, 96, 97, 
	102, 103, 65535, 13, 46, 58, 93, 0, 
	47, 48, 57, 59, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 13, 0, 47, 
	48, 57, 58, 65535, 13, 46, 0, 47, 
	48, 57, 58, 65535, 13, 0, 47, 48, 
	57, 58, 65535, 13, 46, 0, 47, 48, 
	57, 58, 65535, 13, 0, 47, 48, 57, 
	58, 65535, 13, 93, 0, 47, 48, 57, 
	58, 65535, 13, 93, 0, 47, 48, 57, 
	58, 65535, 13, 93, 0, 65535, 13, 46, 
	0, 47, 48, 57, 58, 65535, 13, 46, 
	0, 65535, 13, 46, 0, 47, 48, 57, 
	58, 65535, 13, 46, 0, 65535, 13, 46, 
	58, 93, 0, 47, 48, 57, 59, 64, 
	65, 70, 71, 96, 97, 102, 103, 65535, 
	13, 46, 58, 93, 0, 47, 48, 57, 
	59, 64, 65, 70, 71, 96, 97, 102, 
	103, 65535, 13, 58, 93, 0, 47, 48, 
	57, 59, 64, 65, 70, 71, 96, 97, 
	102, 103, 65535, 13, 58, 93, 0, 47, 
	48, 57, 59, 64, 65, 70, 71, 96, 
	97, 102, 103, 65535, 13, 58, 93, 0, 
	47, 48, 57, 59, 64, 65, 70, 71, 
	96, 97, 102, 103, 65535, 13, 58, 93, 
	0, 47, 48, 57, 59, 64, 65, 70, 
	71, 96, 97, 102, 103, 65535, 13, 58, 
	93, 0, 65535, 13, 0, 47, 48, 57, 
	58, 64, 65, 70, 71, 96, 97, 102, 
	103, 65535, 13, 46, 58, 93, 0, 47, 
	48, 57, 59, 64, 65, 70, 71, 96, 
	97, 102, 103, 65535, 13, 46, 58, 93, 
	0, 47, 48, 57, 59, 64, 65, 70, 
	71, 96, 97, 102, 103, 65535, 13, 46, 
	58, 93, 0, 47, 48, 57, 59, 64, 
	65, 70, 71, 96, 97, 102, 103, 65535, 
	13, 0, 47, 48, 57, 58, 65535, 13, 
	46, 0, 47, 48, 57, 58, 65535, 13, 
	46, 0, 47, 48, 57, 58, 65535, 13, 
	46, 0, 65535, 13, 58, 0, 65535, 10, 
	13, 0, 65535, 9, 13, 32, 33, 37, 
	39, 44, 47, 61, 69, 101, 126, 0, 
	41, 42, 57, 58, 64, 65, 90, 91, 
	94, 95, 122, 123, 65535, 9, 13, 32, 
	33, 37, 39, 44, 47, 61, 65, 97, 
	126, 0, 41, 42, 57, 58, 64, 66, 
	90, 91, 94, 95, 122, 123, 65535, 9, 
	13, 32, 33, 37, 39, 44, 47, 61, 
	76, 108, 126, 0, 41, 42, 57, 58, 
	64, 65, 90, 91, 94, 95, 122, 123, 
	65535, 9, 13, 32, 33, 37, 39, 44, 
	47, 61, 77, 109, 126, 0, 41, 42, 
	57, 58, 64, 65, 90, 91, 94, 95, 
	122, 123, 65535, 9, 13, 32, 33, 37, 
	39, 44, 47, 61, 126, 0, 41, 42, 
	57, 58, 64, 65, 90, 91, 94, 95, 
	122, 123, 65535, 9, 13, 32, 44, 61, 
	0, 65535, 10, 13, 0, 65535, 9, 13, 
	32, 44, 61, 0, 65535, 9, 13, 32, 
	33, 34, 37, 39, 44, 47, 91, 126, 
	0, 41, 42, 57, 58, 64, 65, 90, 
	92, 94, 95, 122, 123, 65535, 10, 13, 
	0, 65535, 9, 13, 32, 33, 34, 37, 
	39, 44, 47, 91, 126, 0, 41, 42, 
	57, 58, 64, 65, 90, 92, 94, 95, 
	122, 123, 65535, 10, 13, 0, 65535, 9, 
	13, 32, 34, 0, 65535, 9, 13, 34, 
	92, 127, 0, 31, 32, 255, 256, 65535, 
	10, 13, 0, 65535, 9, 13, 32, 44, 
	0, 65535, 10, 13, 0, 127, 128, 65535, 
	10, 13, 0, 65535, 9, 13, 32, 33, 
	37, 39, 44, 47, 61, 71, 103, 126, 
	0, 41, 42, 57, 58, 64, 65, 90, 
	91, 94, 95, 122, 123, 65535, 9, 13, 
	32, 33, 37, 39, 44, 47, 61, 79, 
	111, 126, 0, 41, 42, 57, 58, 64, 
	65, 90, 91, 94, 95, 122, 123, 65535, 
	9, 13, 32, 33, 37, 39, 44, 47, 
	61, 82, 114, 126, 0, 41, 42, 57, 
	58, 64, 65, 90, 91, 94, 95, 122, 
	123, 65535, 9, 13, 32, 33, 37, 39, 
	44, 47, 61, 73, 105, 126, 0, 41, 
	42, 57, 58, 64, 65, 90, 91, 94, 
	95, 122, 123, 65535, 9, 13, 32, 33, 
	37, 39, 44, 47, 61, 84, 116, 126, 
	0, 41, 42, 57, 58, 64, 65, 90, 
	91, 94, 95, 122, 123, 65535, 9, 13, 
	32, 33, 37, 39, 44, 47, 61, 72, 
	104, 126, 0, 41, 42, 57, 58, 64, 
	65, 90, 91, 94, 95, 122, 123, 65535, 
	9, 13, 32, 33, 37, 39, 44, 47, 
	61, 77, 109, 126, 0, 41, 42, 57, 
	58, 64, 65, 90, 91, 94, 95, 122, 
	123, 65535, 9, 13, 32, 33, 37, 39, 
	44, 47, 61, 126, 0, 41, 42, 57, 
	58, 64, 65, 90, 91, 94, 95, 122, 
	123, 65535, 9, 13, 32, 44, 61, 0, 
	65535, 10, 13, 0, 65535, 9, 13, 32, 
	44, 61, 0, 65535, 9, 13, 32, 33, 
	34, 37, 39, 44, 47, 91, 126, 0, 
	41, 42, 57, 58, 64, 65, 90, 92, 
	94, 95, 122, 123, 65535, 10, 13, 0, 
	65535, 9, 13, 32, 33, 34, 37, 39, 
	44, 47, 91, 126, 0, 41, 42, 57, 
	58, 64, 65, 90, 92, 94, 95, 122, 
	123, 65535, 9, 13, 32, 33, 37, 39, 
	44, 47, 126, 0, 41, 42, 57, 58, 
	64, 65, 90, 91, 94, 95, 122, 123, 
	65535, 10, 13, 0, 65535, 10, 13, 0, 
	127, 128, 65535, 10, 13, 0, 65535, 9, 
	13, 32, 0, 65535, 13, 0, 65535, 9, 
	13, 32, 0, 65535, 9, 13, 32, 0, 
	65535, 9, 13, 32, 0, 65535, 9, 13, 
	32, 0, 65535, 9, 13, 32, 0, 65535, 
	9, 13, 32, 0, 65535, 9, 13, 32, 
	0, 65535, 9, 13, 32, 33, 37, 39, 
	44, 47, 65, 78, 82, 97, 110, 114, 
	126, 0, 41, 42, 57, 58, 64, 66, 
	90, 91, 94, 95, 122, 123, 65535, 9, 
	13, 32, 33, 37, 39, 44, 47, 65, 
	78, 82, 97, 110, 114, 126, 0, 41, 
	42, 57, 58, 64, 66, 90, 91, 94, 
	95, 122, 123, 65535, 9, 13, 32, 0, 
	65535, 9, 13, 32, 0, 65535, 9, 13, 
	32, 0, 65535, 9, 13, 32, 0, 65535, 
	9, 13, 32, 33, 37, 39, 44, 47, 
	65, 78, 82, 97, 110, 114, 126, 0, 
	41, 42, 57, 58, 64, 66, 90, 91, 
	94, 95, 122, 123, 65535, 9, 13, 32, 
	0, 65535, 9, 13, 32, 0, 65535, 9, 
	13, 32, 0, 65535, 9, 13, 32, 0, 
	65535, 9, 13, 32, 33, 37, 39, 44, 
	47, 65, 78, 82, 97, 110, 114, 126, 
	0, 41, 42, 57, 58, 64, 66, 90, 
	91, 94, 95, 122, 123, 65535, 9, 13, 
	32, 0, 65535, 9, 13, 32, 0, 65535, 
	9, 13, 32, 33, 37, 39, 44, 47, 
	65, 78, 82, 97, 110, 114, 126, 0, 
	41, 42, 57, 58, 64, 66, 90, 91, 
	94, 95, 122, 123, 65535, 0
];

_tsip_machine_parser_header_WWW_Authenticate_single_lengths = [
	0, 2, 2, 2, 1, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 3, 5, 1, 2, 5, 2, 5, 
	3, 3, 3, 3, 3, 3, 15, 2, 
	15, 10, 5, 2, 5, 11, 2, 11, 
	2, 4, 5, 2, 4, 4, 2, 4, 
	2, 12, 2, 12, 12, 12, 12, 10, 
	5, 2, 5, 11, 2, 11, 2, 4, 
	5, 2, 4, 2, 9, 2, 3, 3, 
	3, 3, 2, 4, 1, 2, 1, 2, 
	1, 2, 2, 2, 2, 2, 2, 2, 
	4, 4, 3, 3, 3, 3, 3, 1, 
	4, 4, 4, 1, 2, 2, 2, 2, 
	2, 12, 12, 12, 12, 10, 5, 2, 
	5, 11, 2, 11, 2, 4, 5, 2, 
	4, 2, 2, 12, 12, 12, 12, 12, 
	12, 12, 10, 5, 2, 5, 11, 2, 
	11, 9, 2, 2, 2, 3, 1, 3, 
	3, 3, 3, 3, 3, 3, 15, 15, 
	3, 3, 3, 3, 15, 3, 3, 3, 
	3, 15, 3, 3, 15
];

_tsip_machine_parser_header_WWW_Authenticate_range_lengths = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 7, 1, 
	7, 7, 1, 1, 1, 7, 1, 7, 
	1, 1, 3, 1, 1, 1, 1, 1, 
	1, 7, 1, 7, 7, 7, 7, 7, 
	1, 1, 1, 7, 1, 7, 1, 1, 
	3, 1, 1, 2, 7, 7, 7, 7, 
	7, 1, 7, 7, 3, 3, 3, 3, 
	3, 3, 3, 1, 3, 1, 3, 1, 
	7, 7, 7, 7, 7, 7, 1, 7, 
	7, 7, 7, 3, 3, 3, 1, 1, 
	1, 7, 7, 7, 7, 7, 1, 1, 
	1, 7, 1, 7, 1, 1, 3, 1, 
	1, 2, 1, 7, 7, 7, 7, 7, 
	7, 7, 7, 1, 1, 1, 7, 1, 
	7, 7, 1, 2, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 7, 7, 
	1, 1, 1, 1, 7, 1, 1, 1, 
	1, 7, 1, 1, 7
];

_tsip_machine_parser_header_WWW_Authenticate_index_offsets = [
	0, 0, 3, 6, 9, 11, 14, 17, 
	20, 23, 26, 29, 32, 35, 38, 41, 
	44, 47, 51, 58, 61, 65, 72, 76, 
	83, 88, 93, 98, 103, 108, 113, 136, 
	140, 163, 181, 188, 192, 199, 218, 222, 
	241, 245, 251, 260, 264, 270, 276, 280, 
	286, 290, 310, 314, 334, 354, 374, 394, 
	412, 419, 423, 430, 449, 453, 472, 476, 
	482, 491, 495, 501, 506, 523, 533, 544, 
	555, 566, 571, 581, 593, 598, 604, 609, 
	615, 620, 626, 632, 636, 642, 646, 652, 
	656, 668, 680, 691, 702, 713, 724, 729, 
	738, 750, 762, 774, 779, 785, 791, 795, 
	799, 803, 823, 843, 863, 883, 901, 908, 
	912, 919, 938, 942, 961, 965, 971, 980, 
	984, 990, 995, 999, 1019, 1039, 1059, 1079, 
	1099, 1119, 1139, 1157, 1164, 1168, 1175, 1194, 
	1198, 1217, 1234, 1238, 1243, 1247, 1252, 1255, 
	1260, 1265, 1270, 1275, 1280, 1285, 1290, 1313, 
	1336, 1341, 1346, 1351, 1356, 1379, 1384, 1389, 
	1394, 1399, 1422, 1427, 1432
];

_tsip_machine_parser_header_WWW_Authenticate_indicies = [
	0, 0, 1, 2, 2, 1, 3, 3, 
	1, 4, 1, 5, 5, 1, 6, 6, 
	1, 7, 7, 1, 8, 8, 1, 9, 
	9, 1, 10, 10, 1, 11, 11, 1, 
	12, 12, 1, 13, 13, 1, 14, 14, 
	1, 15, 15, 1, 16, 16, 1, 16, 
	16, 17, 1, 19, 20, 19, 21, 21, 
	18, 1, 22, 18, 1, 23, 22, 18, 
	1, 19, 24, 19, 21, 21, 18, 1, 
	25, 22, 18, 1, 26, 22, 26, 21, 
	21, 18, 1, 22, 27, 27, 18, 1, 
	22, 28, 28, 18, 1, 22, 29, 29, 
	18, 1, 22, 30, 30, 18, 1, 22, 
	31, 31, 18, 1, 32, 33, 32, 18, 
	1, 34, 35, 34, 36, 36, 36, 18, 
	18, 37, 38, 39, 37, 38, 39, 36, 
	18, 36, 18, 36, 18, 36, 18, 1, 
	40, 22, 18, 1, 41, 22, 41, 36, 
	36, 36, 18, 18, 37, 38, 39, 37, 
	38, 39, 36, 18, 36, 18, 36, 18, 
	36, 18, 1, 42, 43, 42, 44, 44, 
	44, 45, 18, 46, 44, 18, 44, 18, 
	44, 18, 44, 18, 1, 47, 48, 47, 
	34, 46, 18, 1, 49, 22, 18, 1, 
	50, 22, 50, 34, 46, 18, 1, 46, 
	51, 46, 52, 53, 52, 52, 18, 18, 
	54, 52, 18, 52, 18, 52, 18, 52, 
	18, 1, 55, 22, 18, 1, 56, 57, 
	56, 52, 53, 52, 52, 18, 18, 54, 
	52, 18, 52, 18, 52, 18, 52, 18, 
	1, 58, 22, 18, 1, 59, 22, 59, 
	53, 18, 1, 53, 60, 61, 62, 18, 
	18, 53, 18, 1, 63, 22, 18, 1, 
	64, 65, 64, 45, 18, 1, 66, 67, 
	66, 34, 18, 1, 68, 22, 18, 1, 
	69, 22, 69, 34, 18, 1, 70, 22, 
	18, 1, 42, 43, 42, 44, 44, 44, 
	45, 18, 46, 71, 71, 44, 18, 44, 
	18, 44, 18, 44, 18, 1, 72, 22, 
	18, 1, 42, 43, 42, 44, 44, 44, 
	45, 18, 46, 73, 73, 44, 18, 44, 
	18, 44, 18, 44, 18, 1, 42, 43, 
	42, 44, 44, 44, 45, 18, 46, 74, 
	74, 44, 18, 44, 18, 44, 18, 44, 
	18, 1, 42, 43, 42, 44, 44, 44, 
	45, 18, 46, 75, 75, 44, 18, 44, 
	18, 44, 18, 44, 18, 1, 42, 43, 
	42, 44, 44, 44, 45, 18, 46, 76, 
	76, 44, 18, 44, 18, 44, 18, 44, 
	18, 1, 77, 78, 77, 44, 44, 44, 
	45, 18, 79, 44, 18, 44, 18, 44, 
	18, 44, 18, 1, 80, 81, 80, 34, 
	79, 18, 1, 82, 22, 18, 1, 83, 
	22, 83, 34, 79, 18, 1, 84, 85, 
	84, 52, 86, 52, 52, 18, 18, 54, 
	52, 18, 52, 18, 52, 18, 52, 18, 
	1, 87, 22, 18, 1, 88, 89, 88, 
	52, 86, 52, 52, 18, 18, 54, 52, 
	18, 52, 18, 52, 18, 52, 18, 1, 
	90, 22, 18, 1, 91, 22, 91, 92, 
	18, 1, 92, 93, 94, 95, 18, 18, 
	92, 18, 1, 96, 22, 18, 1, 97, 
	98, 97, 99, 18, 1, 18, 22, 92, 
	18, 1, 64, 65, 64, 52, 52, 52, 
	45, 18, 52, 18, 52, 18, 52, 18, 
	52, 18, 1, 22, 101, 18, 100, 18, 
	100, 18, 100, 18, 1, 22, 103, 61, 
	18, 102, 18, 102, 18, 102, 18, 1, 
	22, 103, 61, 18, 104, 18, 104, 18, 
	104, 18, 1, 22, 103, 61, 18, 105, 
	18, 105, 18, 105, 18, 1, 22, 103, 
	61, 18, 1, 22, 107, 18, 106, 18, 
	100, 18, 100, 18, 1, 22, 108, 103, 
	61, 18, 109, 18, 102, 18, 102, 18, 
	1, 22, 18, 110, 18, 1, 22, 111, 
	18, 112, 18, 1, 22, 18, 113, 18, 
	1, 22, 114, 18, 115, 18, 1, 22, 
	18, 116, 18, 1, 22, 61, 18, 117, 
	18, 1, 22, 61, 18, 118, 18, 1, 
	22, 61, 18, 1, 22, 114, 18, 119, 
	18, 1, 22, 114, 18, 1, 22, 111, 
	18, 120, 18, 1, 22, 111, 18, 1, 
	22, 108, 103, 61, 18, 121, 18, 104, 
	18, 104, 18, 1, 22, 108, 103, 61, 
	18, 105, 18, 105, 18, 105, 18, 1, 
	22, 123, 61, 18, 122, 18, 122, 18, 
	122, 18, 1, 22, 125, 61, 18, 124, 
	18, 124, 18, 124, 18, 1, 22, 125, 
	61, 18, 126, 18, 126, 18, 126, 18, 
	1, 22, 125, 61, 18, 127, 18, 127, 
	18, 127, 18, 1, 22, 125, 61, 18, 
	1, 22, 18, 128, 18, 122, 18, 122, 
	18, 1, 22, 108, 125, 61, 18, 129, 
	18, 124, 18, 124, 18, 1, 22, 108, 
	125, 61, 18, 130, 18, 126, 18, 126, 
	18, 1, 22, 108, 125, 61, 18, 127, 
	18, 127, 18, 127, 18, 1, 22, 18, 
	131, 18, 1, 22, 108, 18, 132, 18, 
	1, 22, 108, 18, 133, 18, 1, 22, 
	108, 18, 1, 22, 107, 18, 1, 134, 
	22, 18, 1, 42, 43, 42, 44, 44, 
	44, 45, 18, 46, 135, 135, 44, 18, 
	44, 18, 44, 18, 44, 18, 1, 42, 
	43, 42, 44, 44, 44, 45, 18, 46, 
	136, 136, 44, 18, 44, 18, 44, 18, 
	44, 18, 1, 42, 43, 42, 44, 44, 
	44, 45, 18, 46, 137, 137, 44, 18, 
	44, 18, 44, 18, 44, 18, 1, 42, 
	43, 42, 44, 44, 44, 45, 18, 46, 
	138, 138, 44, 18, 44, 18, 44, 18, 
	44, 18, 1, 139, 140, 139, 44, 44, 
	44, 45, 18, 141, 44, 18, 44, 18, 
	44, 18, 44, 18, 1, 142, 143, 142, 
	34, 141, 18, 1, 144, 22, 18, 1, 
	145, 22, 145, 34, 141, 18, 1, 146, 
	147, 146, 52, 148, 52, 52, 18, 18, 
	54, 52, 18, 52, 18, 52, 18, 52, 
	18, 1, 149, 22, 18, 1, 150, 151, 
	150, 52, 148, 52, 52, 18, 18, 54, 
	52, 18, 52, 18, 52, 18, 52, 18, 
	1, 152, 22, 18, 1, 153, 22, 153, 
	154, 18, 1, 154, 155, 156, 157, 18, 
	18, 154, 18, 1, 158, 22, 18, 1, 
	159, 160, 159, 161, 18, 1, 18, 22, 
	154, 18, 1, 162, 22, 18, 1, 42, 
	43, 42, 44, 44, 44, 45, 18, 46, 
	163, 163, 44, 18, 44, 18, 44, 18, 
	44, 18, 1, 42, 43, 42, 44, 44, 
	44, 45, 18, 46, 164, 164, 44, 18, 
	44, 18, 44, 18, 44, 18, 1, 42, 
	43, 42, 44, 44, 44, 45, 18, 46, 
	165, 165, 44, 18, 44, 18, 44, 18, 
	44, 18, 1, 42, 43, 42, 44, 44, 
	44, 45, 18, 46, 166, 166, 44, 18, 
	44, 18, 44, 18, 44, 18, 1, 42, 
	43, 42, 44, 44, 44, 45, 18, 46, 
	167, 167, 44, 18, 44, 18, 44, 18, 
	44, 18, 1, 42, 43, 42, 44, 44, 
	44, 45, 18, 46, 168, 168, 44, 18, 
	44, 18, 44, 18, 44, 18, 1, 42, 
	43, 42, 44, 44, 44, 45, 18, 46, 
	169, 169, 44, 18, 44, 18, 44, 18, 
	44, 18, 1, 170, 171, 170, 44, 44, 
	44, 45, 18, 172, 44, 18, 44, 18, 
	44, 18, 44, 18, 1, 173, 174, 173, 
	34, 172, 18, 1, 175, 22, 18, 1, 
	176, 22, 176, 34, 172, 18, 1, 172, 
	177, 172, 178, 53, 178, 178, 18, 18, 
	54, 178, 18, 178, 18, 178, 18, 178, 
	18, 1, 179, 22, 18, 1, 180, 57, 
	180, 178, 53, 178, 178, 18, 18, 54, 
	178, 18, 178, 18, 178, 18, 178, 18, 
	1, 181, 182, 181, 183, 183, 183, 184, 
	18, 183, 18, 183, 18, 183, 18, 183, 
	18, 1, 185, 22, 18, 1, 18, 22, 
	53, 18, 1, 186, 22, 18, 1, 26, 
	22, 26, 18, 1, 22, 18, 1, 26, 
	22, 26, 18, 1, 41, 22, 41, 18, 
	1, 50, 22, 50, 18, 1, 56, 22, 
	56, 18, 1, 59, 22, 59, 18, 1, 
	53, 22, 53, 18, 1, 69, 22, 69, 
	18, 1, 69, 22, 69, 36, 36, 36, 
	18, 18, 37, 38, 39, 37, 38, 39, 
	36, 18, 36, 18, 36, 18, 36, 18, 
	1, 50, 22, 50, 36, 36, 36, 18, 
	18, 37, 38, 39, 37, 38, 39, 36, 
	18, 36, 18, 36, 18, 36, 18, 1, 
	83, 22, 83, 18, 1, 187, 22, 187, 
	18, 1, 91, 22, 91, 18, 1, 92, 
	22, 92, 18, 1, 83, 22, 83, 36, 
	36, 36, 18, 18, 37, 38, 39, 37, 
	38, 39, 36, 18, 36, 18, 36, 18, 
	36, 18, 1, 145, 22, 145, 18, 1, 
	188, 22, 188, 18, 1, 153, 22, 153, 
	18, 1, 154, 22, 154, 18, 1, 145, 
	22, 145, 36, 36, 36, 18, 18, 37, 
	38, 39, 37, 38, 39, 36, 18, 36, 
	18, 36, 18, 36, 18, 1, 176, 22, 
	176, 18, 1, 180, 22, 180, 18, 1, 
	176, 22, 176, 36, 36, 36, 18, 18, 
	37, 38, 39, 37, 38, 39, 36, 18, 
	36, 18, 36, 18, 36, 18, 1, 0
];

_tsip_machine_parser_header_WWW_Authenticate_trans_targs = [
	2, 0, 3, 4, 5, 6, 7, 8, 
	9, 10, 11, 12, 13, 14, 15, 16, 
	17, 18, 19, 21, 140, 24, 20, 142, 
	22, 143, 23, 25, 26, 27, 28, 29, 
	30, 31, 30, 31, 33, 49, 51, 105, 
	144, 32, 34, 50, 33, 30, 37, 34, 
	35, 145, 36, 38, 68, 42, 69, 146, 
	39, 40, 147, 41, 43, 44, 139, 148, 
	45, 48, 45, 46, 149, 47, 150, 123, 
	151, 52, 53, 54, 55, 56, 104, 59, 
	56, 57, 152, 58, 59, 60, 64, 153, 
	61, 62, 154, 63, 64, 65, 66, 67, 
	155, 45, 48, 30, 70, 103, 71, 74, 
	72, 73, 75, 90, 76, 88, 77, 78, 
	86, 79, 80, 84, 81, 82, 83, 85, 
	87, 89, 91, 99, 92, 95, 93, 94, 
	96, 97, 98, 100, 101, 102, 156, 106, 
	107, 108, 109, 110, 122, 113, 110, 111, 
	157, 112, 113, 114, 118, 158, 115, 116, 
	159, 117, 118, 119, 120, 121, 160, 45, 
	48, 30, 161, 124, 125, 126, 127, 128, 
	129, 130, 131, 138, 134, 131, 132, 162, 
	133, 135, 137, 163, 136, 45, 48, 137, 
	30, 164, 141, 61, 115
];

_tsip_machine_parser_header_WWW_Authenticate_trans_actions = [
	5, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 15, 
	0, 15, 0, 0, 0, 0, 0, 0, 
	3, 3, 0, 0, 1, 1, 1, 1, 
	15, 0, 13, 13, 0, 13, 0, 0, 
	0, 15, 0, 0, 0, 0, 0, 15, 
	0, 0, 15, 0, 0, 0, 0, 15, 
	13, 13, 0, 0, 15, 0, 15, 0, 
	15, 0, 0, 0, 0, 13, 13, 0, 
	0, 0, 15, 0, 1, 1, 1, 15, 
	1, 1, 15, 0, 0, 0, 0, 0, 
	15, 9, 9, 9, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 15, 0, 
	0, 0, 0, 13, 13, 0, 0, 0, 
	15, 0, 1, 1, 1, 15, 1, 1, 
	15, 0, 0, 0, 0, 0, 15, 7, 
	7, 7, 15, 0, 0, 0, 0, 0, 
	0, 0, 13, 13, 0, 0, 0, 15, 
	0, 0, 1, 15, 0, 11, 11, 0, 
	11, 15, 0, 0, 0
];

tsip_machine_parser_header_WWW_Authenticate_start = 1;
tsip_machine_parser_header_WWW_Authenticate_first_final = 142;
tsip_machine_parser_header_WWW_Authenticate_error = 0;

tsip_machine_parser_header_WWW_Authenticate_en_main = 1;


/* line 98 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */

function tsip_header_WWW_Authenticate(){
	tsip_header.call(this, tsip_header_type_e.WWW_Authenticate);
	this.s_scheme = null;
	this.s_realm = null;
	this.s_domain = null;
	this.s_nonce = null;
	this.s_opaque = null;
	this.b_stale = false;
	this.s_algorithm = null;
	this.s_qop = null;
}

tsip_header_WWW_Authenticate.prototype.toString = function(){
	return tsk_string_format("{0} realm=\"{1}\"{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13},stale={14}{15}{16}", 
		this.s_scheme,
		this.s_realm ? this.s_realm : "",
				
		this.s_domain ? ",domain=\"" : "",
		this.s_domain ? this.s_domain : "",
		this.s_domain ? "\"" : "",
				
				
		this.s_qop ? ",qop=\"" : "",
		this.s_qop ? this.s_qop : "",
		this.s_qop ? "\"" : "",


		this.s_nonce ? ",nonce=\"" : "",
		this.s_nonce ? this.s_nonce : "",
		this.s_nonce ? "\"" : "",

		this.s_opaque ? ",opaque=\"" : "",
		this.s_opaque ? this.s_opaque : "",
		this.s_opaque ? "\"" : "",

		this.b_stale ? "TRUE" : "FALSE",

		this.s_algorithm ? ",algorithm=" : "",
		this.s_algorithm ? this.s_algorithm : ""
		);
}

tsip_header_WWW_Authenticate.prototype.Parse = function(s_str){
	var cs = 0;
	var p = 0;
	var pe = s_str.length;
	var eof = pe;
	var data = tsk_buff_str2ib(s_str);
	var i_tag_start;	
	var hdr_WWW_Authenticate = new tsip_header_WWW_Authenticate();
	
	
/* line 645 "./src/headers/tsip_header_WWW_Authenticate.js" */
{
	 cs = tsip_machine_parser_header_WWW_Authenticate_start;
} /* JSCodeGen::writeInit */

/* line 151 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */
	
/* line 652 "./src/headers/tsip_header_WWW_Authenticate.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_header_WWW_Authenticate_key_offsets[cs];
	_trans = _tsip_machine_parser_header_WWW_Authenticate_index_offsets[cs];
	_klen = _tsip_machine_parser_header_WWW_Authenticate_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_header_WWW_Authenticate_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_header_WWW_Authenticate_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_header_WWW_Authenticate_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_header_WWW_Authenticate_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_header_WWW_Authenticate_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_header_WWW_Authenticate_indicies[_trans];
	cs = _tsip_machine_parser_header_WWW_Authenticate_trans_targs[_trans];
	if (_tsip_machine_parser_header_WWW_Authenticate_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_header_WWW_Authenticate_trans_actions[_trans];
		_nacts = _tsip_machine_parser_header_WWW_Authenticate_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_header_WWW_Authenticate_actions[_acts - 1]) {
case 0:
/* line 13 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */

		i_tag_start = p;
			break;
case 1:
/* line 17 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */

		hdr_WWW_Authenticate.s_scheme = "Digest";
			break;
case 2:
/* line 25 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */

		tsip_header.call(hdr_WWW_Authenticate, tsip_header_type_e.WWW_Authenticate);
			break;
case 3:
/* line 33 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */

		hdr_WWW_Authenticate.s_realm = tsk_string_unquote_2(tsk_ragel_parser_get_string(s_str, p, i_tag_start));
			break;
case 4:
/* line 41 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */

		hdr_WWW_Authenticate.s_nonce= tsk_string_unquote_2(tsk_ragel_parser_get_string(s_str, p, i_tag_start));
			break;
case 5:
/* line 54 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */

		hdr_WWW_Authenticate.s_algorithm = tsk_ragel_parser_get_string(s_str, p, i_tag_start);
			break;
case 6:
/* line 62 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */

		tsk_ragel_add_param(s_str, p, i_tag_start, hdr_WWW_Authenticate.ao_params);
			break;
case 7:
/* line 70 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */

			break;
/* line 775 "./src/headers/tsip_header_WWW_Authenticate.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 152 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */
	
	if( cs < 
/* line 805 "./src/headers/tsip_header_WWW_Authenticate.js" */
142
/* line 153 "./ragel/tsip_parser_header_WWW_Authenticate.jrl" */
 ){
		tsk_utils_log_error("Failed to parse 'WWW-Authenticate' header: " + s_str);
		return null;
	}
	
	return hdr_WWW_Authenticate;
}


/* line 1 "./ragel/tsip_parser_header.jrl" */
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
// Check if we have ",CRLF" ==> See WWW-Authenticate header
// As :>CRLF is preceded by any+ ==> p will be at least (start + 1)
// p point to CR
// #define prev_not_comma(p) !(p && p[-1] == ',')
function prev_not_comma(o_ragel_state, i_p){
	return (o_ragel_state.i_pe <= i_p) || (o_ragel_state.o_data[i_p - 1] != ',');
}


/* line 715 "./ragel/tsip_parser_header.jrl" */



/* line 22 "./src/parsers/tsip_parser_header.js" */
_tsip_machine_parser_headers_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 1, 8, 1, 9, 1, 10, 1, 
	11, 1, 12, 1, 13, 1, 14, 1, 
	15, 1, 16, 1, 17, 1, 18, 1, 
	19, 1, 20, 1, 21, 1, 22, 1, 
	23, 1, 24, 1, 25, 1, 26, 1, 
	27, 1, 28, 1, 29, 1, 30, 1, 
	31
];

_tsip_machine_parser_headers_key_offsets = [
	0, 0, 44, 61, 64, 69, 72, 73, 
	74, 76, 99, 118, 137, 156, 175, 192, 
	195, 200, 203, 204, 205, 207, 226, 245, 
	264, 281, 284, 289, 292, 293, 294, 296, 
	315, 334, 353, 372, 391, 410, 429, 448, 
	467, 486, 505, 522, 525, 530, 533, 534, 
	535, 537, 560, 579, 598, 615, 634, 655, 
	672, 675, 680, 683, 684, 685, 687, 706, 
	725, 742, 745, 750, 753, 754, 755, 757, 
	776, 795, 816, 835, 854, 871, 874, 879, 
	882, 883, 884, 886, 905, 924, 941, 962, 
	981, 1000, 1019, 1038, 1057, 1074, 1077, 1082, 
	1085, 1086, 1087, 1089, 1108, 1127, 1146, 1163, 
	1166, 1171, 1174, 1175, 1176, 1178, 1197, 1216, 
	1233, 1236, 1241, 1244, 1245, 1246, 1248, 1269, 
	1288, 1307, 1326, 1343, 1346, 1351, 1354, 1355, 
	1356, 1358, 1377, 1396, 1415, 1434, 1453, 1470, 
	1473, 1478, 1481, 1482, 1483, 1485, 1504, 1523, 
	1542, 1559, 1562, 1567, 1570, 1571, 1572, 1574, 
	1593, 1612, 1629, 1648, 1667, 1686, 1705, 1724, 
	1743, 1762, 1781, 1798, 1801, 1806, 1809, 1810, 
	1811, 1813, 1832, 1851, 1870, 1889, 1906, 1925, 
	1944, 1963, 1982, 2003, 2022, 2041, 2060, 2079, 
	2098, 2117, 2136, 2153, 2156, 2161, 2164, 2168, 
	2169, 2171, 2190, 2209, 2228, 2247, 2266, 2285, 
	2304, 2323, 2340, 2343, 2348, 2351, 2352, 2353, 
	2355, 2378, 2405, 2424, 2443, 2462, 2479, 2482, 
	2487, 2490, 2491, 2492, 2494, 2513, 2532, 2551, 
	2568, 2587, 2606, 2625, 2644, 2663, 2680, 2683, 
	2688, 2691, 2692, 2693, 2695, 2714, 2733, 2752, 
	2771, 2790, 2807, 2810, 2815, 2818, 2819, 2820, 
	2822, 2841, 2860, 2877, 2896, 2915, 2932, 2935, 
	2940, 2943, 2944, 2945, 2947, 2966, 2985, 3004, 
	3023, 3042, 3059, 3062, 3067, 3070, 3071, 3072, 
	3074, 3093, 3112, 3131, 3150, 3167, 3170, 3175, 
	3178, 3179, 3180, 3182, 3201, 3220, 3239, 3256, 
	3259, 3264, 3267, 3268, 3269, 3271, 3290, 3309, 
	3326, 3329, 3334, 3337, 3338, 3339, 3341, 3360, 
	3363, 3368, 3371, 3372, 3373, 3375, 3396, 3415, 
	3434, 3453, 3472, 3489, 3508, 3527, 3546, 3565, 
	3584, 3603, 3620, 3623, 3628, 3631, 3632, 3633, 
	3635, 3656, 3675, 3694, 3713, 3732, 3751, 3770, 
	3789, 3806, 3809, 3814, 3817, 3818, 3819, 3821, 
	3838, 3841, 3846, 3849, 3850, 3851, 3853, 3874, 
	3893, 3912, 3931, 3950, 3969, 3988, 4007, 4026, 
	4045, 4062, 4065, 4070, 4073, 4074, 4075, 4077, 
	4096, 4115, 4132, 4151, 4170, 4189, 4208, 4227, 
	4244, 4247, 4252, 4255, 4256, 4257, 4259, 4278, 
	4297, 4314, 4317, 4322, 4325, 4326, 4327, 4329, 
	4348, 4367, 4384, 4403, 4422, 4441, 4460, 4479, 
	4498, 4517, 4536, 4555, 4574, 4593, 4612, 4629, 
	4632, 4637, 4640, 4644, 4645, 4647, 4670, 4689, 
	4708, 4731, 4752, 4771, 4771, 4774
];

_tsip_machine_parser_headers_trans_keys = [
	33, 37, 39, 65, 67, 69, 70, 77, 
	79, 80, 82, 83, 84, 85, 86, 87, 
	97, 98, 99, 101, 102, 105, 107, 108, 
	109, 111, 112, 114, 115, 116, 117, 118, 
	119, 126, 42, 43, 45, 46, 48, 57, 
	66, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 58, 
	9, 13, 32, 0, 65535, 13, 0, 65535, 
	10, 10, 9, 32, 9, 32, 33, 37, 
	39, 58, 67, 76, 85, 99, 108, 117, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 67, 99, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 69, 101, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 80, 
	112, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 84, 116, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 58, 9, 13, 32, 0, 65535, 
	13, 0, 65535, 10, 10, 9, 32, 9, 
	32, 33, 37, 39, 58, 76, 108, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	79, 111, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 87, 119, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 58, 9, 13, 32, 0, 
	65535, 13, 0, 65535, 10, 10, 9, 32, 
	9, 32, 33, 37, 39, 58, 84, 116, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 72, 104, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 79, 111, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 82, 
	114, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 73, 105, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 90, 122, 126, 
	42, 43, 45, 46, 48, 57, 65, 89, 
	95, 121, 9, 32, 33, 37, 39, 58, 
	65, 97, 126, 42, 43, 45, 46, 48, 
	57, 66, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 84, 116, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 73, 105, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 79, 111, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 78, 110, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 58, 9, 13, 32, 
	0, 65535, 13, 0, 65535, 10, 10, 9, 
	32, 9, 32, 33, 37, 39, 58, 65, 
	79, 83, 97, 111, 115, 126, 42, 43, 
	45, 46, 48, 57, 66, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 76, 108, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 76, 108, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 45, 46, 58, 126, 42, 
	43, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 73, 105, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	68, 78, 100, 110, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 58, 9, 13, 32, 0, 65535, 
	13, 0, 65535, 10, 10, 9, 32, 9, 
	32, 33, 37, 39, 58, 70, 102, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	79, 111, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	58, 9, 13, 32, 0, 65535, 13, 0, 
	65535, 10, 10, 9, 32, 9, 32, 33, 
	37, 39, 58, 78, 110, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 84, 116, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 65, 69, 97, 101, 126, 42, 43, 
	45, 46, 48, 57, 66, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 67, 99, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 84, 116, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 58, 9, 13, 32, 0, 65535, 13, 
	0, 65535, 10, 10, 9, 32, 9, 32, 
	33, 37, 39, 58, 78, 110, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 84, 
	116, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 45, 46, 58, 126, 42, 43, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 76, 84, 108, 116, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	69, 101, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 78, 110, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 71, 103, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 84, 116, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 72, 104, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 58, 9, 13, 32, 
	0, 65535, 13, 0, 65535, 10, 10, 9, 
	32, 9, 32, 33, 37, 39, 58, 89, 
	121, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 80, 112, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 69, 101, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 58, 9, 13, 
	32, 0, 65535, 13, 0, 65535, 10, 10, 
	9, 32, 9, 32, 33, 37, 39, 58, 
	69, 101, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 81, 113, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 58, 9, 13, 32, 0, 
	65535, 13, 0, 65535, 10, 10, 9, 32, 
	9, 32, 33, 37, 39, 58, 86, 88, 
	118, 120, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 69, 101, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 78, 110, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 84, 116, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 58, 9, 13, 32, 0, 65535, 13, 
	0, 65535, 10, 10, 9, 32, 9, 32, 
	33, 37, 39, 58, 80, 112, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 73, 
	105, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 82, 114, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 69, 101, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	83, 115, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	58, 9, 13, 32, 0, 65535, 13, 0, 
	65535, 10, 10, 9, 32, 9, 32, 33, 
	37, 39, 58, 82, 114, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 79, 111, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 77, 109, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 58, 9, 13, 32, 0, 65535, 13, 
	0, 65535, 10, 10, 9, 32, 9, 32, 
	33, 37, 39, 58, 65, 97, 126, 42, 
	43, 45, 46, 48, 57, 66, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 88, 
	120, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 45, 46, 58, 126, 42, 43, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 70, 102, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 79, 111, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 82, 114, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 87, 119, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 65, 
	97, 126, 42, 43, 45, 46, 48, 57, 
	66, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 82, 114, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 68, 100, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	83, 115, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	58, 9, 13, 32, 0, 65535, 13, 0, 
	65535, 10, 10, 9, 32, 9, 32, 33, 
	37, 39, 58, 82, 114, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 79, 111, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 88, 120, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 89, 121, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 45, 46, 
	58, 126, 42, 43, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	65, 97, 126, 42, 43, 45, 46, 48, 
	57, 66, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 85, 117, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 84, 116, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 72, 104, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 69, 79, 101, 111, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 78, 110, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 84, 116, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 73, 
	105, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 67, 99, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 65, 97, 126, 
	42, 43, 45, 46, 48, 57, 66, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	84, 116, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 69, 101, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 58, 9, 13, 32, 0, 
	65535, 13, 0, 65535, 10, 13, 0, 65535, 
	10, 9, 32, 9, 32, 33, 37, 39, 
	58, 82, 114, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 73, 105, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 90, 
	122, 126, 42, 43, 45, 46, 48, 57, 
	65, 89, 95, 121, 9, 32, 33, 37, 
	39, 58, 65, 97, 126, 42, 43, 45, 
	46, 48, 57, 66, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 84, 116, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	73, 105, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 79, 111, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 78, 110, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 58, 9, 
	13, 32, 0, 65535, 13, 0, 65535, 10, 
	10, 9, 32, 9, 32, 33, 37, 39, 
	58, 69, 79, 83, 101, 111, 115, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	65, 67, 70, 80, 81, 97, 99, 102, 
	112, 113, 126, 42, 43, 45, 46, 48, 
	57, 66, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 83, 115, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 79, 111, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 78, 110, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 58, 9, 13, 32, 0, 65535, 13, 
	0, 65535, 10, 10, 9, 32, 9, 32, 
	33, 37, 39, 58, 79, 111, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 82, 
	114, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 68, 100, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 45, 46, 58, 126, 
	42, 43, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 82, 114, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 79, 111, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 85, 117, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 84, 
	116, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 69, 101, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 58, 9, 13, 32, 0, 65535, 
	13, 0, 65535, 10, 10, 9, 32, 9, 
	32, 33, 37, 39, 58, 69, 101, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	82, 114, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 45, 46, 58, 82, 114, 126, 
	42, 43, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 84, 116, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 79, 111, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 58, 9, 13, 32, 0, 65535, 13, 
	0, 65535, 10, 10, 9, 32, 9, 32, 
	33, 37, 39, 58, 69, 101, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 68, 
	100, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 45, 46, 58, 126, 42, 43, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 66, 98, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 89, 121, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 58, 9, 
	13, 32, 0, 65535, 13, 0, 65535, 10, 
	10, 9, 32, 9, 32, 33, 37, 39, 
	58, 76, 108, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 65, 97, 126, 42, 
	43, 45, 46, 48, 57, 66, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 67, 
	99, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 69, 101, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 83, 115, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 58, 9, 13, 
	32, 0, 65535, 13, 0, 65535, 10, 10, 
	9, 32, 9, 32, 33, 37, 39, 58, 
	85, 117, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 73, 105, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 82, 114, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 69, 101, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 58, 9, 13, 32, 0, 65535, 13, 
	0, 65535, 10, 10, 9, 32, 9, 32, 
	33, 37, 39, 58, 85, 117, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 84, 
	116, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 69, 101, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 58, 9, 13, 32, 0, 65535, 
	13, 0, 65535, 10, 10, 9, 32, 9, 
	32, 33, 37, 39, 58, 69, 101, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	81, 113, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	58, 9, 13, 32, 0, 65535, 13, 0, 
	65535, 10, 10, 9, 32, 9, 32, 33, 
	37, 39, 58, 85, 117, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 58, 9, 13, 32, 0, 65535, 
	13, 0, 65535, 10, 10, 9, 32, 9, 
	32, 33, 37, 39, 58, 66, 80, 98, 
	112, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 74, 106, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 69, 101, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	67, 99, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 84, 116, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 80, 
	112, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 79, 111, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 82, 114, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	84, 116, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 69, 101, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 68, 100, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 58, 9, 
	13, 32, 0, 65535, 13, 0, 65535, 10, 
	10, 9, 32, 9, 32, 33, 37, 39, 
	58, 73, 79, 105, 111, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 77, 109, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 69, 101, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 83, 115, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 84, 
	116, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 65, 97, 126, 42, 43, 45, 
	46, 48, 57, 66, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 77, 109, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	80, 112, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	58, 9, 13, 32, 0, 65535, 13, 0, 
	65535, 10, 10, 9, 32, 9, 32, 33, 
	37, 39, 58, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	58, 9, 13, 32, 0, 65535, 13, 0, 
	65535, 10, 10, 9, 32, 9, 32, 33, 
	37, 39, 58, 78, 83, 110, 115, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	83, 115, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 85, 117, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 80, 112, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 80, 112, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 79, 111, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 82, 
	114, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 84, 116, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 69, 101, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	68, 100, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	58, 9, 13, 32, 0, 65535, 13, 0, 
	65535, 10, 10, 9, 32, 9, 32, 33, 
	37, 39, 58, 69, 101, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 82, 114, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	45, 46, 58, 126, 42, 43, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 65, 97, 126, 42, 43, 45, 
	46, 48, 57, 66, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 71, 103, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	69, 101, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 78, 110, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 84, 116, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 58, 9, 
	13, 32, 0, 65535, 13, 0, 65535, 10, 
	10, 9, 32, 9, 32, 33, 37, 39, 
	58, 73, 105, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 65, 97, 126, 42, 
	43, 45, 46, 48, 57, 66, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 58, 9, 13, 32, 
	0, 65535, 13, 0, 65535, 10, 10, 9, 
	32, 9, 32, 33, 37, 39, 58, 87, 
	119, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 87, 119, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 45, 46, 58, 126, 
	42, 43, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 65, 97, 
	126, 42, 43, 45, 46, 48, 57, 66, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 85, 117, 126, 42, 43, 45, 46, 
	48, 57, 65, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 84, 116, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 72, 
	104, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 69, 101, 126, 42, 43, 45, 
	46, 48, 57, 65, 90, 95, 122, 9, 
	32, 33, 37, 39, 58, 78, 110, 126, 
	42, 43, 45, 46, 48, 57, 65, 90, 
	95, 122, 9, 32, 33, 37, 39, 58, 
	84, 116, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 33, 
	37, 39, 58, 73, 105, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 67, 99, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 65, 97, 126, 42, 43, 45, 46, 
	48, 57, 66, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 84, 116, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 69, 
	101, 126, 42, 43, 45, 46, 48, 57, 
	65, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 126, 42, 43, 45, 46, 48, 
	57, 65, 90, 95, 122, 9, 32, 58, 
	9, 13, 32, 0, 65535, 13, 0, 65535, 
	10, 13, 0, 65535, 10, 9, 32, 9, 
	32, 33, 37, 39, 58, 65, 79, 83, 
	97, 111, 115, 126, 42, 43, 45, 46, 
	48, 57, 66, 90, 95, 122, 9, 32, 
	33, 37, 39, 58, 82, 114, 126, 42, 
	43, 45, 46, 48, 57, 65, 90, 95, 
	122, 9, 32, 33, 37, 39, 58, 65, 
	97, 126, 42, 43, 45, 46, 48, 57, 
	66, 90, 95, 122, 9, 32, 33, 37, 
	39, 58, 69, 79, 83, 101, 111, 115, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 9, 32, 33, 37, 39, 
	58, 73, 79, 105, 111, 126, 42, 43, 
	45, 46, 48, 57, 65, 90, 95, 122, 
	9, 32, 33, 37, 39, 58, 73, 105, 
	126, 42, 43, 45, 46, 48, 57, 65, 
	90, 95, 122, 13, 0, 65535, 13, 0, 
	65535, 0
];

_tsip_machine_parser_headers_single_lengths = [
	0, 34, 7, 3, 3, 1, 1, 1, 
	2, 13, 9, 9, 9, 9, 7, 3, 
	3, 1, 1, 1, 2, 9, 9, 9, 
	7, 3, 3, 1, 1, 1, 2, 9, 
	9, 9, 9, 9, 9, 9, 9, 9, 
	9, 9, 7, 3, 3, 1, 1, 1, 
	2, 13, 9, 9, 9, 9, 11, 7, 
	3, 3, 1, 1, 1, 2, 9, 9, 
	7, 3, 3, 1, 1, 1, 2, 9, 
	9, 11, 9, 9, 7, 3, 3, 1, 
	1, 1, 2, 9, 9, 9, 11, 9, 
	9, 9, 9, 9, 7, 3, 3, 1, 
	1, 1, 2, 9, 9, 9, 7, 3, 
	3, 1, 1, 1, 2, 9, 9, 7, 
	3, 3, 1, 1, 1, 2, 11, 9, 
	9, 9, 7, 3, 3, 1, 1, 1, 
	2, 9, 9, 9, 9, 9, 7, 3, 
	3, 1, 1, 1, 2, 9, 9, 9, 
	7, 3, 3, 1, 1, 1, 2, 9, 
	9, 9, 9, 9, 9, 9, 9, 9, 
	9, 9, 7, 3, 3, 1, 1, 1, 
	2, 9, 9, 9, 9, 9, 9, 9, 
	9, 9, 11, 9, 9, 9, 9, 9, 
	9, 9, 7, 3, 3, 1, 2, 1, 
	2, 9, 9, 9, 9, 9, 9, 9, 
	9, 7, 3, 3, 1, 1, 1, 2, 
	13, 17, 9, 9, 9, 7, 3, 3, 
	1, 1, 1, 2, 9, 9, 9, 9, 
	9, 9, 9, 9, 9, 7, 3, 3, 
	1, 1, 1, 2, 9, 9, 11, 9, 
	9, 7, 3, 3, 1, 1, 1, 2, 
	9, 9, 9, 9, 9, 7, 3, 3, 
	1, 1, 1, 2, 9, 9, 9, 9, 
	9, 7, 3, 3, 1, 1, 1, 2, 
	9, 9, 9, 9, 7, 3, 3, 1, 
	1, 1, 2, 9, 9, 9, 7, 3, 
	3, 1, 1, 1, 2, 9, 9, 7, 
	3, 3, 1, 1, 1, 2, 9, 3, 
	3, 1, 1, 1, 2, 11, 9, 9, 
	9, 9, 7, 9, 9, 9, 9, 9, 
	9, 7, 3, 3, 1, 1, 1, 2, 
	11, 9, 9, 9, 9, 9, 9, 9, 
	7, 3, 3, 1, 1, 1, 2, 7, 
	3, 3, 1, 1, 1, 2, 11, 9, 
	9, 9, 9, 9, 9, 9, 9, 9, 
	7, 3, 3, 1, 1, 1, 2, 9, 
	9, 9, 9, 9, 9, 9, 9, 7, 
	3, 3, 1, 1, 1, 2, 9, 9, 
	7, 3, 3, 1, 1, 1, 2, 9, 
	9, 9, 9, 9, 9, 9, 9, 9, 
	9, 9, 9, 9, 9, 9, 7, 3, 
	3, 1, 2, 1, 2, 13, 9, 9, 
	13, 11, 9, 0, 1, 1
];

_tsip_machine_parser_headers_range_lengths = [
	0, 5, 5, 0, 1, 1, 0, 0, 
	0, 5, 5, 5, 5, 5, 5, 0, 
	1, 1, 0, 0, 0, 5, 5, 5, 
	5, 0, 1, 1, 0, 0, 0, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 0, 1, 1, 0, 0, 
	0, 5, 5, 5, 4, 5, 5, 5, 
	0, 1, 1, 0, 0, 0, 5, 5, 
	5, 0, 1, 1, 0, 0, 0, 5, 
	5, 5, 5, 5, 5, 0, 1, 1, 
	0, 0, 0, 5, 5, 4, 5, 5, 
	5, 5, 5, 5, 5, 0, 1, 1, 
	0, 0, 0, 5, 5, 5, 5, 0, 
	1, 1, 0, 0, 0, 5, 5, 5, 
	0, 1, 1, 0, 0, 0, 5, 5, 
	5, 5, 5, 0, 1, 1, 0, 0, 
	0, 5, 5, 5, 5, 5, 5, 0, 
	1, 1, 0, 0, 0, 5, 5, 5, 
	5, 0, 1, 1, 0, 0, 0, 5, 
	5, 4, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 0, 1, 1, 0, 0, 
	0, 5, 5, 5, 5, 4, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 0, 1, 1, 1, 0, 
	0, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 0, 1, 1, 0, 0, 0, 
	5, 5, 5, 5, 5, 5, 0, 1, 
	1, 0, 0, 0, 5, 5, 5, 4, 
	5, 5, 5, 5, 5, 5, 0, 1, 
	1, 0, 0, 0, 5, 5, 4, 5, 
	5, 5, 0, 1, 1, 0, 0, 0, 
	5, 5, 4, 5, 5, 5, 0, 1, 
	1, 0, 0, 0, 5, 5, 5, 5, 
	5, 5, 0, 1, 1, 0, 0, 0, 
	5, 5, 5, 5, 5, 0, 1, 1, 
	0, 0, 0, 5, 5, 5, 5, 0, 
	1, 1, 0, 0, 0, 5, 5, 5, 
	0, 1, 1, 0, 0, 0, 5, 0, 
	1, 1, 0, 0, 0, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 0, 1, 1, 0, 0, 0, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 0, 1, 1, 0, 0, 0, 5, 
	0, 1, 1, 0, 0, 0, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 0, 1, 1, 0, 0, 0, 5, 
	5, 4, 5, 5, 5, 5, 5, 5, 
	0, 1, 1, 0, 0, 0, 5, 5, 
	5, 0, 1, 1, 0, 0, 0, 5, 
	5, 4, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 0, 
	1, 1, 1, 0, 0, 5, 5, 5, 
	5, 5, 5, 0, 1, 1
];

_tsip_machine_parser_headers_index_offsets = [
	0, 0, 40, 53, 57, 62, 65, 67, 
	69, 72, 91, 106, 121, 136, 151, 164, 
	168, 173, 176, 178, 180, 183, 198, 213, 
	228, 241, 245, 250, 253, 255, 257, 260, 
	275, 290, 305, 320, 335, 350, 365, 380, 
	395, 410, 425, 438, 442, 447, 450, 452, 
	454, 457, 476, 491, 506, 520, 535, 552, 
	565, 569, 574, 577, 579, 581, 584, 599, 
	614, 627, 631, 636, 639, 641, 643, 646, 
	661, 676, 693, 708, 723, 736, 740, 745, 
	748, 750, 752, 755, 770, 785, 799, 816, 
	831, 846, 861, 876, 891, 904, 908, 913, 
	916, 918, 920, 923, 938, 953, 968, 981, 
	985, 990, 993, 995, 997, 1000, 1015, 1030, 
	1043, 1047, 1052, 1055, 1057, 1059, 1062, 1079, 
	1094, 1109, 1124, 1137, 1141, 1146, 1149, 1151, 
	1153, 1156, 1171, 1186, 1201, 1216, 1231, 1244, 
	1248, 1253, 1256, 1258, 1260, 1263, 1278, 1293, 
	1308, 1321, 1325, 1330, 1333, 1335, 1337, 1340, 
	1355, 1370, 1384, 1399, 1414, 1429, 1444, 1459, 
	1474, 1489, 1504, 1517, 1521, 1526, 1529, 1531, 
	1533, 1536, 1551, 1566, 1581, 1596, 1610, 1625, 
	1640, 1655, 1670, 1687, 1702, 1717, 1732, 1747, 
	1762, 1777, 1792, 1805, 1809, 1814, 1817, 1821, 
	1823, 1826, 1841, 1856, 1871, 1886, 1901, 1916, 
	1931, 1946, 1959, 1963, 1968, 1971, 1973, 1975, 
	1978, 1997, 2020, 2035, 2050, 2065, 2078, 2082, 
	2087, 2090, 2092, 2094, 2097, 2112, 2127, 2142, 
	2156, 2171, 2186, 2201, 2216, 2231, 2244, 2248, 
	2253, 2256, 2258, 2260, 2263, 2278, 2293, 2309, 
	2324, 2339, 2352, 2356, 2361, 2364, 2366, 2368, 
	2371, 2386, 2401, 2415, 2430, 2445, 2458, 2462, 
	2467, 2470, 2472, 2474, 2477, 2492, 2507, 2522, 
	2537, 2552, 2565, 2569, 2574, 2577, 2579, 2581, 
	2584, 2599, 2614, 2629, 2644, 2657, 2661, 2666, 
	2669, 2671, 2673, 2676, 2691, 2706, 2721, 2734, 
	2738, 2743, 2746, 2748, 2750, 2753, 2768, 2783, 
	2796, 2800, 2805, 2808, 2810, 2812, 2815, 2830, 
	2834, 2839, 2842, 2844, 2846, 2849, 2866, 2881, 
	2896, 2911, 2926, 2939, 2954, 2969, 2984, 2999, 
	3014, 3029, 3042, 3046, 3051, 3054, 3056, 3058, 
	3061, 3078, 3093, 3108, 3123, 3138, 3153, 3168, 
	3183, 3196, 3200, 3205, 3208, 3210, 3212, 3215, 
	3228, 3232, 3237, 3240, 3242, 3244, 3247, 3264, 
	3279, 3294, 3309, 3324, 3339, 3354, 3369, 3384, 
	3399, 3412, 3416, 3421, 3424, 3426, 3428, 3431, 
	3446, 3461, 3475, 3490, 3505, 3520, 3535, 3550, 
	3563, 3567, 3572, 3575, 3577, 3579, 3582, 3597, 
	3612, 3625, 3629, 3634, 3637, 3639, 3641, 3644, 
	3659, 3674, 3688, 3703, 3718, 3733, 3748, 3763, 
	3778, 3793, 3808, 3823, 3838, 3853, 3868, 3881, 
	3885, 3890, 3893, 3897, 3899, 3902, 3921, 3936, 
	3951, 3970, 3987, 4002, 4003, 4006
];

_tsip_machine_parser_headers_indicies = [
	0, 0, 0, 2, 3, 4, 5, 6, 
	7, 8, 9, 10, 11, 12, 13, 14, 
	2, 15, 16, 4, 17, 18, 19, 20, 
	21, 7, 8, 22, 10, 23, 12, 24, 
	14, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 26, 
	1, 26, 28, 26, 27, 1, 29, 27, 
	1, 30, 1, 31, 1, 27, 27, 1, 
	25, 25, 0, 0, 0, 26, 32, 33, 
	34, 32, 33, 34, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 35, 35, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	36, 36, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 37, 
	37, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 38, 38, 
	0, 0, 0, 0, 0, 0, 1, 39, 
	39, 0, 0, 0, 40, 0, 0, 0, 
	0, 0, 0, 1, 39, 39, 40, 1, 
	40, 42, 40, 41, 1, 43, 41, 1, 
	44, 1, 45, 1, 41, 41, 1, 25, 
	25, 0, 0, 0, 26, 46, 46, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 47, 47, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 48, 48, 0, 0, 0, 
	0, 0, 0, 1, 49, 49, 0, 0, 
	0, 50, 0, 0, 0, 0, 0, 0, 
	1, 49, 49, 50, 1, 50, 52, 50, 
	51, 1, 53, 51, 1, 54, 1, 55, 
	1, 51, 51, 1, 25, 25, 0, 0, 
	0, 26, 56, 56, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 57, 57, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	58, 58, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 59, 
	59, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 60, 60, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 61, 61, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 62, 62, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 63, 63, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 64, 64, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 65, 65, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	66, 66, 0, 0, 0, 0, 0, 0, 
	1, 67, 67, 0, 0, 0, 68, 0, 
	0, 0, 0, 0, 0, 1, 67, 67, 
	68, 1, 68, 70, 68, 69, 1, 71, 
	69, 1, 72, 1, 73, 1, 69, 69, 
	1, 25, 25, 0, 0, 0, 26, 74, 
	75, 76, 74, 75, 76, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 77, 77, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 78, 78, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 79, 
	0, 26, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 80, 80, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 18, 81, 18, 
	81, 0, 0, 0, 0, 0, 0, 1, 
	82, 82, 0, 0, 0, 83, 0, 0, 
	0, 0, 0, 0, 1, 82, 82, 83, 
	1, 83, 85, 83, 84, 1, 86, 84, 
	1, 87, 1, 88, 1, 84, 84, 1, 
	25, 25, 0, 0, 0, 26, 89, 89, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 90, 90, 0, 
	0, 0, 0, 0, 0, 1, 91, 91, 
	0, 0, 0, 92, 0, 0, 0, 0, 
	0, 0, 1, 91, 91, 92, 1, 92, 
	94, 92, 93, 1, 95, 93, 1, 96, 
	1, 97, 1, 93, 93, 1, 25, 25, 
	0, 0, 0, 26, 98, 98, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 99, 99, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 100, 101, 100, 101, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 102, 102, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 103, 103, 0, 0, 0, 0, 
	0, 0, 1, 104, 104, 0, 0, 0, 
	105, 0, 0, 0, 0, 0, 0, 1, 
	104, 104, 105, 1, 105, 107, 105, 106, 
	1, 108, 106, 1, 109, 1, 110, 1, 
	106, 106, 1, 25, 25, 0, 0, 0, 
	26, 111, 111, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	112, 112, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 113, 0, 
	26, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 114, 115, 114, 
	115, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 116, 116, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 117, 117, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 118, 118, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 119, 119, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 20, 20, 0, 0, 0, 0, 
	0, 0, 1, 120, 120, 0, 0, 0, 
	121, 0, 0, 0, 0, 0, 0, 1, 
	120, 120, 121, 1, 121, 123, 121, 122, 
	1, 124, 122, 1, 125, 1, 126, 1, 
	122, 122, 1, 25, 25, 0, 0, 0, 
	26, 127, 127, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	128, 128, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 129, 
	129, 0, 0, 0, 0, 0, 0, 1, 
	130, 130, 0, 0, 0, 131, 0, 0, 
	0, 0, 0, 0, 1, 130, 130, 131, 
	1, 131, 133, 131, 132, 1, 134, 132, 
	1, 135, 1, 136, 1, 132, 132, 1, 
	25, 25, 0, 0, 0, 26, 137, 137, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 138, 138, 0, 
	0, 0, 0, 0, 0, 1, 139, 139, 
	0, 0, 0, 140, 0, 0, 0, 0, 
	0, 0, 1, 139, 139, 140, 1, 140, 
	142, 140, 141, 1, 143, 141, 1, 144, 
	1, 145, 1, 141, 141, 1, 25, 25, 
	0, 0, 0, 26, 146, 147, 146, 147, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 148, 148, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 149, 149, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 7, 7, 0, 0, 0, 
	0, 0, 0, 1, 150, 150, 0, 0, 
	0, 151, 0, 0, 0, 0, 0, 0, 
	1, 150, 150, 151, 1, 151, 153, 151, 
	152, 1, 154, 152, 1, 155, 1, 156, 
	1, 152, 152, 1, 25, 25, 0, 0, 
	0, 26, 157, 157, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 158, 158, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	159, 159, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 160, 
	160, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 161, 161, 
	0, 0, 0, 0, 0, 0, 1, 162, 
	162, 0, 0, 0, 163, 0, 0, 0, 
	0, 0, 0, 1, 162, 162, 163, 1, 
	163, 165, 163, 164, 1, 166, 164, 1, 
	167, 1, 168, 1, 164, 164, 1, 25, 
	25, 0, 0, 0, 26, 169, 169, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 170, 170, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 171, 171, 0, 0, 0, 
	0, 0, 0, 1, 172, 172, 0, 0, 
	0, 173, 0, 0, 0, 0, 0, 0, 
	1, 172, 172, 173, 1, 173, 175, 173, 
	174, 1, 176, 174, 1, 177, 1, 178, 
	1, 174, 174, 1, 25, 25, 0, 0, 
	0, 26, 179, 179, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 180, 180, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 181, 
	0, 26, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 182, 182, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 183, 183, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 184, 184, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 185, 185, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 186, 186, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 187, 187, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	188, 188, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 189, 
	189, 0, 0, 0, 0, 0, 0, 1, 
	190, 190, 0, 0, 0, 191, 0, 0, 
	0, 0, 0, 0, 1, 190, 190, 191, 
	1, 191, 193, 191, 192, 1, 194, 192, 
	1, 195, 1, 196, 1, 192, 192, 1, 
	25, 25, 0, 0, 0, 26, 197, 197, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 198, 198, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 199, 199, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 200, 200, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 201, 0, 26, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	202, 202, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 203, 
	203, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 204, 204, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 205, 205, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 206, 207, 206, 207, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 208, 208, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 209, 209, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 210, 210, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 211, 211, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 212, 212, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	213, 213, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 214, 
	214, 0, 0, 0, 0, 0, 0, 1, 
	215, 215, 0, 0, 0, 216, 0, 0, 
	0, 0, 0, 0, 1, 215, 215, 216, 
	1, 216, 218, 216, 217, 1, 219, 217, 
	1, 220, 219, 217, 1, 221, 1, 217, 
	217, 1, 25, 25, 0, 0, 0, 26, 
	222, 222, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 223, 
	223, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 224, 224, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 225, 225, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 226, 226, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 227, 227, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 228, 228, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 229, 229, 0, 0, 0, 0, 0, 
	0, 1, 230, 230, 0, 0, 0, 231, 
	0, 0, 0, 0, 0, 0, 1, 230, 
	230, 231, 1, 231, 233, 231, 232, 1, 
	234, 232, 1, 235, 1, 236, 1, 232, 
	232, 1, 25, 25, 0, 0, 0, 26, 
	237, 238, 239, 237, 238, 239, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 240, 241, 242, 243, 244, 
	240, 241, 242, 243, 244, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 245, 245, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 246, 246, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	247, 247, 0, 0, 0, 0, 0, 0, 
	1, 248, 248, 0, 0, 0, 249, 0, 
	0, 0, 0, 0, 0, 1, 248, 248, 
	249, 1, 249, 251, 249, 250, 1, 252, 
	250, 1, 253, 1, 254, 1, 250, 250, 
	1, 25, 25, 0, 0, 0, 26, 255, 
	255, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 256, 256, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 257, 257, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 258, 0, 26, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 259, 259, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 260, 260, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	261, 261, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 262, 
	262, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 263, 263, 
	0, 0, 0, 0, 0, 0, 1, 264, 
	264, 0, 0, 0, 265, 0, 0, 0, 
	0, 0, 0, 1, 264, 264, 265, 1, 
	265, 267, 265, 266, 1, 268, 266, 1, 
	269, 1, 270, 1, 266, 266, 1, 25, 
	25, 0, 0, 0, 26, 271, 271, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 272, 272, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 273, 0, 26, 274, 274, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 275, 275, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 276, 276, 0, 0, 0, 0, 
	0, 0, 1, 277, 277, 0, 0, 0, 
	278, 0, 0, 0, 0, 0, 0, 1, 
	277, 277, 278, 1, 278, 280, 278, 279, 
	1, 281, 279, 1, 282, 1, 283, 1, 
	279, 279, 1, 25, 25, 0, 0, 0, 
	26, 284, 284, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	285, 285, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 286, 0, 
	26, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 287, 287, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 15, 15, 0, 0, 
	0, 0, 0, 0, 1, 288, 288, 0, 
	0, 0, 289, 0, 0, 0, 0, 0, 
	0, 1, 288, 288, 289, 1, 289, 291, 
	289, 290, 1, 292, 290, 1, 293, 1, 
	294, 1, 290, 290, 1, 25, 25, 0, 
	0, 0, 26, 295, 295, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 296, 296, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 297, 297, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	298, 298, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 299, 
	299, 0, 0, 0, 0, 0, 0, 1, 
	300, 300, 0, 0, 0, 301, 0, 0, 
	0, 0, 0, 0, 1, 300, 300, 301, 
	1, 301, 303, 301, 302, 1, 304, 302, 
	1, 305, 1, 306, 1, 302, 302, 1, 
	25, 25, 0, 0, 0, 26, 307, 307, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 308, 308, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 309, 309, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 310, 310, 0, 0, 0, 
	0, 0, 0, 1, 311, 311, 0, 0, 
	0, 312, 0, 0, 0, 0, 0, 0, 
	1, 311, 311, 312, 1, 312, 314, 312, 
	313, 1, 315, 313, 1, 316, 1, 317, 
	1, 313, 313, 1, 25, 25, 0, 0, 
	0, 26, 318, 318, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 319, 319, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	320, 320, 0, 0, 0, 0, 0, 0, 
	1, 321, 321, 0, 0, 0, 322, 0, 
	0, 0, 0, 0, 0, 1, 321, 321, 
	322, 1, 322, 324, 322, 323, 1, 325, 
	323, 1, 326, 1, 327, 1, 323, 323, 
	1, 25, 25, 0, 0, 0, 26, 328, 
	328, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 329, 329, 
	0, 0, 0, 0, 0, 0, 1, 330, 
	330, 0, 0, 0, 331, 0, 0, 0, 
	0, 0, 0, 1, 330, 330, 331, 1, 
	331, 333, 331, 332, 1, 334, 332, 1, 
	335, 1, 336, 1, 332, 332, 1, 337, 
	337, 0, 0, 0, 338, 339, 339, 0, 
	0, 0, 0, 0, 0, 1, 337, 337, 
	338, 1, 338, 341, 338, 340, 1, 342, 
	340, 1, 343, 1, 344, 1, 340, 340, 
	1, 25, 25, 0, 0, 0, 26, 345, 
	346, 345, 346, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	347, 347, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 348, 
	348, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 349, 349, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 350, 350, 0, 
	0, 0, 0, 0, 0, 1, 337, 337, 
	0, 0, 0, 338, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 351, 351, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	352, 352, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 353, 
	353, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 354, 354, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 355, 355, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 19, 19, 0, 0, 
	0, 0, 0, 0, 1, 356, 356, 0, 
	0, 0, 357, 0, 0, 0, 0, 0, 
	0, 1, 356, 356, 357, 1, 357, 359, 
	357, 358, 1, 360, 358, 1, 361, 1, 
	362, 1, 358, 358, 1, 25, 25, 0, 
	0, 0, 26, 363, 364, 363, 364, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 365, 365, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 366, 366, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 367, 367, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 368, 368, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	369, 369, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 370, 
	370, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 371, 371, 
	0, 0, 0, 0, 0, 0, 1, 372, 
	372, 0, 0, 0, 373, 0, 0, 0, 
	0, 0, 0, 1, 372, 372, 373, 1, 
	373, 375, 373, 374, 1, 376, 374, 1, 
	377, 1, 378, 1, 374, 374, 1, 379, 
	379, 0, 0, 0, 380, 0, 0, 0, 
	0, 0, 0, 1, 379, 379, 380, 1, 
	380, 382, 380, 381, 1, 383, 381, 1, 
	384, 1, 385, 1, 381, 381, 1, 25, 
	25, 0, 0, 0, 26, 386, 387, 386, 
	387, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 388, 388, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 389, 389, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 390, 390, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 391, 391, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 392, 392, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 393, 393, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	394, 394, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 395, 
	395, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 396, 396, 
	0, 0, 0, 0, 0, 0, 1, 397, 
	397, 0, 0, 0, 398, 0, 0, 0, 
	0, 0, 0, 1, 397, 397, 398, 1, 
	398, 400, 398, 399, 1, 401, 399, 1, 
	402, 1, 403, 1, 399, 399, 1, 25, 
	25, 0, 0, 0, 26, 404, 404, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 405, 405, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 406, 0, 26, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 407, 407, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	408, 408, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 409, 
	409, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 410, 410, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 411, 411, 0, 
	0, 0, 0, 0, 0, 1, 412, 412, 
	0, 0, 0, 413, 0, 0, 0, 0, 
	0, 0, 1, 412, 412, 413, 1, 413, 
	415, 413, 414, 1, 416, 414, 1, 417, 
	1, 418, 1, 414, 414, 1, 25, 25, 
	0, 0, 0, 26, 419, 419, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 420, 420, 0, 0, 0, 
	0, 0, 0, 1, 421, 421, 0, 0, 
	0, 422, 0, 0, 0, 0, 0, 0, 
	1, 421, 421, 422, 1, 422, 424, 422, 
	423, 1, 425, 423, 1, 426, 1, 427, 
	1, 423, 423, 1, 25, 25, 0, 0, 
	0, 26, 428, 428, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 429, 429, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 430, 
	0, 26, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 431, 431, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 432, 432, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 433, 433, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 434, 434, 0, 0, 0, 
	0, 0, 0, 1, 25, 25, 0, 0, 
	0, 26, 435, 435, 0, 0, 0, 0, 
	0, 0, 1, 25, 25, 0, 0, 0, 
	26, 436, 436, 0, 0, 0, 0, 0, 
	0, 1, 25, 25, 0, 0, 0, 26, 
	437, 437, 0, 0, 0, 0, 0, 0, 
	1, 25, 25, 0, 0, 0, 26, 438, 
	438, 0, 0, 0, 0, 0, 0, 1, 
	25, 25, 0, 0, 0, 26, 439, 439, 
	0, 0, 0, 0, 0, 0, 1, 25, 
	25, 0, 0, 0, 26, 440, 440, 0, 
	0, 0, 0, 0, 0, 1, 25, 25, 
	0, 0, 0, 26, 441, 441, 0, 0, 
	0, 0, 0, 0, 1, 25, 25, 0, 
	0, 0, 26, 442, 442, 0, 0, 0, 
	0, 0, 0, 1, 443, 443, 0, 0, 
	0, 444, 0, 0, 0, 0, 0, 0, 
	1, 443, 443, 444, 1, 444, 446, 444, 
	445, 1, 447, 445, 1, 448, 447, 445, 
	1, 449, 1, 445, 445, 1, 130, 130, 
	0, 0, 0, 131, 74, 75, 76, 74, 
	75, 76, 0, 0, 0, 0, 0, 0, 
	1, 172, 172, 0, 0, 0, 173, 169, 
	169, 0, 0, 0, 0, 0, 0, 1, 
	104, 104, 0, 0, 0, 105, 179, 179, 
	0, 0, 0, 0, 0, 0, 1, 277, 
	277, 0, 0, 0, 278, 237, 238, 239, 
	237, 238, 239, 0, 0, 0, 0, 0, 
	0, 1, 379, 379, 0, 0, 0, 380, 
	363, 364, 363, 364, 0, 0, 0, 0, 
	0, 0, 1, 421, 421, 0, 0, 0, 
	422, 419, 419, 0, 0, 0, 0, 0, 
	0, 1, 1, 219, 217, 1, 447, 445, 
	1, 0
];

_tsip_machine_parser_headers_trans_targs = [
	2, 0, 9, 49, 118, 141, 151, 122, 
	169, 208, 302, 328, 350, 382, 391, 253, 
	413, 414, 55, 321, 92, 415, 416, 417, 
	418, 3, 4, 5, 7, 6, 419, 8, 
	10, 21, 31, 11, 12, 13, 14, 15, 
	16, 17, 19, 18, 419, 20, 22, 23, 
	24, 25, 26, 27, 29, 28, 419, 30, 
	32, 33, 34, 35, 36, 37, 38, 39, 
	40, 41, 42, 43, 44, 45, 47, 46, 
	419, 48, 50, 71, 109, 51, 52, 53, 
	54, 62, 56, 57, 58, 60, 59, 419, 
	61, 63, 64, 65, 66, 67, 69, 68, 
	419, 70, 72, 73, 74, 83, 75, 76, 
	77, 78, 79, 81, 80, 419, 82, 84, 
	85, 86, 87, 99, 88, 89, 90, 91, 
	93, 94, 95, 97, 96, 419, 98, 100, 
	101, 102, 103, 104, 105, 107, 106, 419, 
	108, 110, 111, 112, 113, 114, 116, 115, 
	419, 117, 119, 129, 120, 121, 123, 124, 
	125, 127, 126, 419, 128, 130, 131, 132, 
	133, 134, 135, 136, 137, 139, 138, 419, 
	140, 142, 143, 144, 145, 146, 147, 149, 
	148, 419, 150, 152, 153, 154, 155, 156, 
	157, 158, 159, 160, 161, 162, 163, 164, 
	165, 167, 166, 419, 168, 170, 171, 172, 
	173, 174, 175, 176, 177, 178, 179, 193, 
	180, 181, 182, 183, 184, 185, 186, 187, 
	188, 189, 191, 190, 420, 192, 194, 195, 
	196, 197, 198, 199, 200, 201, 202, 203, 
	204, 206, 205, 419, 207, 209, 283, 293, 
	210, 220, 236, 260, 272, 211, 212, 213, 
	214, 215, 216, 218, 217, 419, 219, 221, 
	222, 223, 224, 225, 226, 227, 228, 229, 
	230, 231, 232, 234, 233, 419, 235, 237, 
	238, 239, 248, 240, 241, 242, 243, 244, 
	246, 245, 419, 247, 249, 250, 251, 252, 
	254, 255, 256, 258, 257, 419, 259, 261, 
	262, 263, 264, 265, 266, 267, 268, 270, 
	269, 419, 271, 273, 274, 275, 276, 277, 
	278, 279, 281, 280, 419, 282, 284, 285, 
	286, 287, 288, 289, 291, 290, 419, 292, 
	294, 295, 296, 297, 298, 300, 299, 419, 
	301, 303, 304, 309, 305, 307, 306, 419, 
	308, 310, 315, 311, 312, 313, 314, 316, 
	317, 318, 319, 320, 322, 323, 324, 326, 
	325, 419, 327, 329, 343, 330, 331, 332, 
	333, 334, 335, 336, 337, 338, 339, 341, 
	340, 419, 342, 344, 345, 346, 348, 347, 
	419, 349, 351, 367, 352, 353, 354, 355, 
	356, 357, 358, 359, 360, 361, 362, 363, 
	365, 364, 419, 366, 368, 369, 370, 371, 
	372, 373, 374, 375, 376, 377, 378, 380, 
	379, 419, 381, 383, 384, 385, 386, 387, 
	389, 388, 419, 390, 392, 393, 394, 395, 
	396, 397, 398, 399, 400, 401, 402, 403, 
	404, 405, 406, 407, 408, 409, 411, 410, 
	421, 412
];

_tsip_machine_parser_headers_trans_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 63, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 3, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	5, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 7, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	9, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 11, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 13, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 15, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	17, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 19, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 21, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 23, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 25, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 27, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 29, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 31, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 33, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 35, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 37, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 39, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 41, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 43, 0, 
	0, 0, 0, 0, 0, 0, 0, 45, 
	0, 0, 0, 0, 0, 0, 0, 47, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 49, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 51, 0, 0, 0, 0, 0, 0, 
	53, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 55, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 57, 0, 0, 0, 0, 0, 0, 
	0, 0, 59, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	61, 0
];

tsip_machine_parser_headers_start = 1;
tsip_machine_parser_headers_first_final = 419;
tsip_machine_parser_headers_error = 0;

tsip_machine_parser_headers_en_main = 1;


/* line 718 "./ragel/tsip_parser_header.jrl" */

function tsip_header_parse(o_ragel_state, o_msg){
	var cs = 0;
	var p = o_ragel_state.i_tag_start;
	var pe = o_ragel_state.i_tag_end;
	var eof = pe;
	var data = o_ragel_state.o_data;
	var s_str = o_ragel_state.s_data.substring(o_ragel_state.i_tag_start, o_ragel_state.i_tag_start + (o_ragel_state.i_tag_end - o_ragel_state.i_tag_start));
	
	
/* line 1503 "./src/parsers/tsip_parser_header.js" */
{
	 cs = tsip_machine_parser_headers_start;
} /* JSCodeGen::writeInit */

/* line 728 "./ragel/tsip_parser_header.jrl" */
	
/* line 1510 "./src/parsers/tsip_parser_header.js" */
{
	var _klen, _trans, _keys, _ps, _widec, _acts, _nacts;
	var _goto_level, _resume, _eof_trans, _again, _test_eof;
	var _out;
	_klen = _trans = _keys = _acts = _nacts = null;
	_goto_level = 0;
	_resume = 10;
	_eof_trans = 15;
	_again = 20;
	_test_eof = 30;
	_out = 40;
	while (true) {
	_trigger_goto = false;
	if (_goto_level <= 0) {
	if (p == pe) {
		_goto_level = _test_eof;
		continue;
	}
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	}
	if (_goto_level <= _resume) {
	_keys = _tsip_machine_parser_headers_key_offsets[cs];
	_trans = _tsip_machine_parser_headers_index_offsets[cs];
	_klen = _tsip_machine_parser_headers_single_lengths[cs];
	_break_match = false;
	
	do {
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + _klen - 1;

	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + ( (_upper - _lower) >> 1 );

	        if (data[p] < _tsip_machine_parser_headers_trans_keys[_mid]) {
	           _upper = _mid - 1;
	        } else if (data[p] > _tsip_machine_parser_headers_trans_keys[_mid]) {
	           _lower = _mid + 1;
	        } else {
	           _trans += (_mid - _keys);
	           _break_match = true;
	           break;
	        };
	     } /* while */
	     if (_break_match) { break; }
	     _keys += _klen;
	     _trans += _klen;
	  }
	  _klen = _tsip_machine_parser_headers_range_lengths[cs];
	  if (_klen > 0) {
	     _lower = _keys;
	     _upper = _keys + (_klen << 1) - 2;
	     while (true) {
	        if (_upper < _lower) { break; }
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1);
	        if (data[p] < _tsip_machine_parser_headers_trans_keys[_mid]) {
	          _upper = _mid - 2;
	         } else if (data[p] > _tsip_machine_parser_headers_trans_keys[_mid+1]) {
	          _lower = _mid + 2;
	        } else {
	          _trans += ((_mid - _keys) >> 1);
	          _break_match = true;
	          break;
	        }
	     } /* while */
	     if (_break_match) { break; }
	     _trans += _klen
	  }
	} while (false);
	_trans = _tsip_machine_parser_headers_indicies[_trans];
	cs = _tsip_machine_parser_headers_trans_targs[_trans];
	if (_tsip_machine_parser_headers_trans_actions[_trans] != 0) {
		_acts = _tsip_machine_parser_headers_trans_actions[_trans];
		_nacts = _tsip_machine_parser_headers_actions[_acts];
		_acts += 1;
		while (_nacts > 0) {
			_nacts -= 1;
			_acts += 1;
			switch (_tsip_machine_parser_headers_actions[_acts - 1]) {
case 0:
/* line 20 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_Dummy.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 1:
/* line 62 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_Allow.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 2:
/* line 83 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Authorization.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 3:
/* line 90 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Call_ID.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 4:
/* line 97 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_Dummy.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 5:
/* line 104 "./ragel/tsip_parser_header.jrl" */

	    var headers = tsip_header_Contact.prototype.Parse(s_str);
	    for(var i = 0; i < headers.length; ++i){
		    o_msg.add_header(headers[i]);
		}
			break;
case 6:
/* line 134 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Content_Length.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 7:
/* line 141 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Content_Type.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 8:
/* line 148 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_CSeq.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 9:
/* line 169 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Event.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 10:
/* line 176 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Expires.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 11:
/* line 183 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_From.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 12:
/* line 225 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Max_Forwards.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 13:
/* line 423 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_WWW_Authenticate.prototype.Parse(s_str);
		o_msg.add_headers(header);
		p = (pe - 1); // hack: Ragel "when" clause not supported in javascript
			break;
case 14:
/* line 431 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Authorization.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 15:
/* line 452 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_Dummy.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 16:
/* line 459 "./ragel/tsip_parser_header.jrl" */

	    var headers = tsip_header_Record_Route.prototype.Parse(s_str);
		if(headers){
			for(var i = 0; i < headers.length; ++i){
				o_msg.add_header(headers[i]);
			}
		}
			break;
case 17:
/* line 477 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Refer_To.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 18:
/* line 484 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Referred_By.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 19:
/* line 498 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_Dummy.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 20:
/* line 519 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Require.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 21:
/* line 540 "./ragel/tsip_parser_header.jrl" */

	    var headers = tsip_header_Route.prototype.Parse(s_str);
		if(headers){
			for(var i = 0; i < headers.length; ++i){
				o_msg.add_header(headers[i]);
			}
		}
			break;
case 22:
/* line 551 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_RSeq.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 23:
/* line 618 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_Dummy.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 24:
/* line 632 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_Supported.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 25:
/* line 646 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_Dummy.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 26:
/* line 653 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_To.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 27:
/* line 660 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_Dummy.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 28:
/* line 667 "./ragel/tsip_parser_header.jrl" */

	    var header = tsip_header_User_Agent.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
case 29:
/* line 674 "./ragel/tsip_parser_header.jrl" */
	
	    var headers = tsip_header_Via.prototype.Parse(s_str);
		if(headers){
			for(var i = 0; i < headers.length; ++i){
				o_msg.add_header(headers[i]);
			}
		}
			break;
case 30:
/* line 692 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_WWW_Authenticate.prototype.Parse(s_str);
		o_msg.add_headers(header);
		p = (pe - 1); // hack: Ragel "when" clause not supported in javascript
			break;
case 31:
/* line 700 "./ragel/tsip_parser_header.jrl" */

		var header = tsip_header_Dummy.prototype.Parse(s_str);
		o_msg.add_headers(header);
			break;
/* line 1802 "./src/parsers/tsip_parser_header.js" */
			} /* action switch */
		}
	}
	if (_trigger_goto) {
		continue;
	}
	}
	if (_goto_level <= _again) {
	if (cs == 0) {
		_goto_level = _out;
		continue;
	}
	p += 1;
	if (p != pe) {
		_goto_level = _resume;
		continue;
	}
	}
	if (_goto_level <= _test_eof) {
	}
	if (_goto_level <= _out) {
		break;
	}
	}
	}

/* line 729 "./ragel/tsip_parser_header.jrl" */
	
	if( cs < 
/* line 1832 "./src/parsers/tsip_parser_header.js" */
419
/* line 730 "./ragel/tsip_parser_header.jrl" */
 ){
	    tsk_utils_log_error("Failed to parse header: " + s_str);
	    return -2;
	}
	return 0;
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
tsip_transac.prototype.__magic_cookie = "z9hG4bK";

var tsip_transac_event_type_e =
{
    INCOMING_MSG : 0,
	OUTGOING_MSG: 1,
	CANCELED: 2,
	TERMINATED: 3,
	TIMEDOUT: 4,
	ERROR: 5,
	TRANSPORT_ERROR: 6
};

var tsip_transac_type_e =
{
    NONE: -1,

    ICT: 0,
    IST: 1,
    NICT: 2,
    NIST: 3
};

function tsip_transac() {
    this.e_type = tsip_transac_type_e.NONE;
    this.o_dialog = null;
    this.o_fsm = null;
    this.b_reliable = true;
    this.b_running = false;
    this.b_initialized = false;
    this.s_branch = null;
    this.i_cseq_value = 0;
    this.s_cseq_method = null;
    this.s_callid = null;
    this.fn_callback = null;
};

tsip_transac.prototype.init = function (e_type, b_reliable, i_cseq_value, s_cseq_method, s_callid, o_dialog, i_fsm_state_curr, i_fsm_state_term) {
    if (!this.b_initialized) {
        this.e_type = e_type;
        this.b_reliable = b_reliable;
        this.i_cseq_value = i_cseq_value;
        this.s_cseq_method = s_cseq_method;
        this.s_callid = s_callid;
        this.o_dialog = o_dialog;
        this.o_fsm = new tsk_fsm(i_fsm_state_curr, i_fsm_state_term, null, this);
        this.b_initialized = true;
    }
    return 0;
};

tsip_transac.prototype.deinit = function () {
    this.get_stack().o_layer_transac.remove(this);
    this.b_initialized = false;
    return 0;
}

tsip_transac.prototype.timer_schedule = function (T, N) {
    this.timer_cancel(N);
    var This = this;
    var s_code = tsk_string_format("This.o_timer{1} = setTimeout(function(){ __tsip_transac_{0}_timer_callback(This, This.o_timer{1})}, This.i_timer{1});", T, N);
    eval(s_code);
}

tsip_transac.prototype.timer_cancel = function (N) {
    var s_code = tsk_string_format("if(this.o_timer{0}) { clearTimeout(this.o_timer{0}); this.o_timer{0} = null; }", N);
    eval(s_code);
}

tsip_transac.prototype.set_callback = function (fn_callback) {
    this.fn_callback = fn_callback;
}

tsip_transac.prototype.send = function (s_branch, o_message) {
    return this.get_stack().o_layer_transport.send(s_branch, o_message);
}

tsip_transac.prototype.callback = function (e_event_type, o_message) {
    if (this.fn_callback) {
        return this.fn_callback(this, e_event_type, o_message);
    }
    tsk_utils_log_error("Invalid callback function");
    return -1;
}

tsip_transac.prototype.get_type = function () {
    return this.e_type;
}

tsip_transac.prototype.get_fsm = function () {
    return this.o_fsm;
}

tsip_transac.prototype.get_dialog = function () {
    return this.o_dialog;
}

tsip_transac.prototype.get_session = function () {
    if (this.o_dialog) {
        return this.o_dialog.o_session;
    }
    return null;
}

tsip_transac.prototype.get_stack = function () {
    var o_session = this.get_session();
    if (o_session) {
        return o_session.o_stack;
    }
    return null;
}

tsip_transac.prototype.fsm_act = function (i_action, o_message) {
    if (!this.o_fsm) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }
    return this.o_fsm.act(i_action, this, o_message, this, o_message);
};

tsip_transac.prototype.send = function (s_branch, o_message) {
    var o_stack = this.get_stack();
    if (!o_stack || !o_stack.o_layer_transport) {
        tsk_utils_log_error("Invalid state");
        return -1;
    }
    return o_stack.o_layer_transport.send(s_branch, o_message);
}

tsip_transac.prototype.compare = function (transac) {
    return tsip_transac_compare(this, transac);
}

function tsip_transac_compare(o_transac1, o_transac2){
	if(o_transac1 && o_transac2){
		if((o_transac1.s_branch == o_transac2.s_branch) && (o_transac1.s_cseq_method == o_transac2.s_cseq_method)){
			return 0;
		}
	}
	return -1;
}

if(!window.__b_release_mode){
    tsip_api_add_js_scripts('head',
     'src/tinySIP/src/transactions/tsip_transac_ict.js',
     'src/tinySIP/src/transactions/tsip_transac_ist.js',
     'src/tinySIP/src/transactions/tsip_transac_layer.js',
     'src/tinySIP/src/transactions/tsip_transac_nict.js',
     'src/tinySIP/src/transactions/tsip_transac_nist.js'
    );
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/**
* SIP INVITE Client Transaction as per RFC 3261 subclause 17.1.1.
*/

tsip_transac_ict.prototype = Object.create(tsip_transac.prototype);
tsip_transac_ict.prototype.__b_debug_state_machine = false;

var tsip_transac_ict_actions_e =
{
	CANCEL: tsip_action_type_e.CANCEL,

	SEND: 10001,
	TIMER_A: 10002,
	TIMER_B: 10003,
	TIMER_D: 10004,
	TIMER_M: 10005,
	I_1XX: 10006,
	I_2XX: 10007,
	I_300_to_699: 10008,
	TRANSPOR_TERROR: 10009,
	ERROR: 10010
};

var tsip_transac_ict_states_e =
{
    STARTED: 0,
	CALLING: 1,
	PROCEEDING: 2,
	COMPLETED: 3,
	ACCEPTED: 4,
	TERMINATED: 5
};

function tsip_transac_ict(b_reliable, i_cseq_value, s_callid, o_dialog) {
    var o_stack;
    if (!o_dialog || !(o_stack = o_dialog.get_stack())) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    tsip_transac.call(this);

    this.init(tsip_transac_type_e.ICT, b_reliable, i_cseq_value, "INVITE", s_callid, o_dialog, tsip_transac_ict_states_e.STARTED, tsip_transac_ict_states_e.TERMINATED);
    this.set_callback(__tsip_transac_ict_event_callback);
    this.o_fsm.set_debug_enabled(tsip_transac_ict.prototype.__b_debug_state_machine);
    this.o_fsm.set_onterm_callback(__tsip_transac_ict_onterm, this);

    /* Timers */
    this.o_timerA = null;
    this.o_timerB = null;
    this.o_timerD = null;
    this.o_timerM = null;

    this.i_timerA = o_stack.o_timers.getA();
    this.i_timerB = o_stack.o_timers.getB();
    this.i_timerD = b_reliable ? 0 : o_stack.o_timers.getD();
    this.i_timerM = o_stack.o_timers.getM();

    // initialize the state machine
    this.o_fsm.set(
        /*=======================
        * === Started === 
        */
        // Started -> (Send) -> Calling
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.STARTED, tsip_transac_ict_actions_e.SEND, tsip_transac_ict_states_e.CALLING, __tsip_transac_ict_Started_2_Calling_X_send, "tsip_transac_ict_Started_2_Calling_X_send"),
        // Started -> (Any) -> Started
        tsk_fsm_entry.prototype.CreateAlwaysNothing(tsip_transac_ict_states_e.STARTED, "tsip_transac_ict_Started_2_Started_X_any"),

        /*=======================
        * === Calling === 
        */
        // Calling -> (timerA) -> Calling
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.CALLING, tsip_transac_ict_actions_e.TIMER_A, tsip_transac_ict_states_e.CALLING, __tsip_transac_ict_Calling_2_Calling_X_timerA, "tsip_transac_ict_Calling_2_Calling_X_timerA"),
        // Calling -> (timerB) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.CALLING, tsip_transac_ict_actions_e.TIMER_B, tsip_transac_ict_states_e.TERMINATED, __tsip_transac_ict_Calling_2_Terminated_X_timerB, "tsip_transac_ict_Calling_2_Terminated_X_timerB"),
        // Calling -> (300-699) -> Completed
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.CALLING, tsip_transac_ict_actions_e.I_300_to_699, tsip_transac_ict_states_e.COMPLETED, __tsip_transac_ict_Calling_2_Completed_X_300_to_699, "tsip_transac_ict_Calling_2_Completed_X_300_to_699"),
        // Calling  -> (1xx) -> Proceeding
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.CALLING, tsip_transac_ict_actions_e.I_1XX, tsip_transac_ict_states_e.PROCEEDING, __tsip_transac_ict_Calling_2_Proceeding_X_1xx, "tsip_transac_ict_Calling_2_Proceeding_X_1xx"),
        // Calling  -> (2xx) -> Accepted
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.CALLING, tsip_transac_ict_actions_e.I_2XX, tsip_transac_ict_states_e.ACCEPTED, __tsip_transac_ict_Calling_2_Accepted_X_2xx, "tsip_transac_ict_Calling_2_Accepted_X_2xx"),

        /*=======================
        * === Proceeding === 
        */
        // Proceeding -> (1xx) -> Proceeding
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.PROCEEDING, tsip_transac_ict_actions_e.I_1XX, tsip_transac_ict_states_e.PROCEEDING, __tsip_transac_ict_Proceeding_2_Proceeding_X_1xx, "tsip_transac_ict_Proceeding_2_Proceeding_X_1xx"),
        // Proceeding -> (300-699) -> Completed
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.PROCEEDING, tsip_transac_ict_actions_e.I_300_to_699, tsip_transac_ict_states_e.COMPLETED, __tsip_transac_ict_Proceeding_2_Completed_X_300_to_699, "tsip_transac_ict_Proceeding_2_Completed_X_300_to_699"),
        // Proceeding -> (2xx) -> Accepted
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.PROCEEDING, tsip_transac_ict_actions_e.I_2XX, tsip_transac_ict_states_e.ACCEPTED, __tsip_transac_ict_Proceeding_2_Accepted_X_2xx, "tsip_transac_ict_Proceeding_2_Accepted_X_2xx"),

        /*=======================
        * === Completed === 
        */
        // Completed -> (300-699) -> Completed
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.COMPLETED, tsip_transac_ict_actions_e.I_300_to_699, tsip_transac_ict_states_e.COMPLETED, __tsip_transac_ict_Completed_2_Completed_X_300_to_699, "tsip_transac_ict_Completed_2_Completed_X_300_to_699"),
        // Completed -> (timerD) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.COMPLETED, tsip_transac_ict_actions_e.TIMER_D, tsip_transac_ict_states_e.TERMINATED, __tsip_transac_ict_Completed_2_Terminated_X_timerD, "tsip_transac_ict_Completed_2_Terminated_X_timerD"),

        /*=======================
        * === Accepted === 
        */
        // Accepted -> (2xx) -> Accepted
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.ACCEPTED, tsip_transac_ict_actions_e.I_2XX, tsip_transac_ict_states_e.ACCEPTED, __tsip_transac_ict_Accepted_2_Accepted_X_2xx, "tsip_transac_ict_Accepted_2_Accepted_X_2xx"),
        // Accepted -> (timerM) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ict_states_e.ACCEPTED, tsip_transac_ict_actions_e.TIMER_M, tsip_transac_ict_states_e.TERMINATED, __tsip_transac_ict_Accepted_2_Terminated_X_timerM, "tsip_transac_ict_Accepted_2_Terminated_X_timerM"),

        /*=======================
        * === Any === 
        */
        // Any -> (transport error) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_ict_actions_e.TRANSPORT_ERROR, tsip_transac_ict_states_e.TERMINATED, __tsip_transac_ict_Any_2_Terminated_X_transportError, "tsip_transac_ict_Any_2_Terminated_X_transportError"),
        // Any -> (transport error) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_ict_actions_e.ERROR, tsip_transac_ict_states_e.TERMINATED, __tsip_transac_ict_Any_2_Terminated_X_Error, "tsip_transac_ict_Any_2_Terminated_X_Error"),
        // Any -> (cancel) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_ict_actions_e.CANCEL, tsip_transac_ict_states_e.TERMINATED, __tsip_transac_ict_Any_2_Terminated_X_cancel, "tsip_transac_ict_Any_2_Terminated_X_cancel")
    );
}

tsip_transac_ict.prototype.start = function (o_request) {
	var i_ret = -1;
	if(o_request && !this.b_running){
		/* Add branch to the new client transaction */
		this.s_branch = tsk_string_format("{0}{1}", tsip_transac.prototype.__magic_cookie, tsk_string_random(32));

		this.b_running = true;
		this.o_request = o_request;

		i_ret = this.fsm_act(tsip_transac_ict_actions_e.SEND, o_request);
	}
	return i_ret;
}

tsip_transac_ict.prototype.send_ack = function(o_response){
	if(!this.o_request || !o_response){
        tsk_utils_log_error("Invalid state");
		return -1;
	}

	// check lastINVITE
	if(	!this.o_request.o_hdr_firstVia ||
		!this.o_request.o_hdr_From || 
		!this.o_request.line.request.o_uri || 
		!this.o_request.o_hdr_Call_ID || 
		!this.o_request.o_hdr_CSeq)
	{
		tsk_utils_log_error("Invalid INVITE message");
		return -2;
	}

	// check response
	if(!o_response.o_hdr_To){
		tsk_utils_log_error("Invalid response message");
		return -3;
	}

    var i_ret = -1;
	var o_request = null;

	/*	RFC 3261 - 17.1.1.3 Construction of the ACK Request
		
		The ACK request constructed by the client transaction MUST contain
		values for the Call-ID, From, and Request-URI that are equal to the
		values of those header fields in the request passed to the transport
		by the client transaction (call this the "original request").  The To
		header field in the ACK MUST equal the To header field in the
		response being acknowledged, and therefore will usually differ from
		the To header field in the original request by the addition of the
		tag parameter.  The ACK MUST contain a single Via header field, and
		this MUST be equal to the top Via header field of the original
		request.  The CSeq header field in the ACK MUST contain the same
		value for the sequence number as was present in the original request,
		but the method parameter MUST be equal to "ACK".

		If the INVITE request whose response is being acknowledged had Route
		header fields, those header fields MUST appear in the ACK.  This is
		to ensure that the ACK can be routed properly through any downstream
		stateless proxies.

		Although any request MAY contain a body, a body in an ACK is special
		since the request cannot be rejected if the body is not understood.
		Therefore, placement of bodies in ACK for non-2xx is NOT RECOMMENDED,
		but if done, the body types are restricted to any that appeared in
		the INVITE, assuming that the response to the INVITE was not 415.  If
		it was, the body in the ACK MAY be any type listed in the Accept
		header field in the 415.
	*/
	if((o_request = new tsip_request("ACK", this.o_request.line.request.o_uri, this.o_request.o_hdr_From.o_uri, o_response.o_hdr_To.o_uri, this.o_request.o_hdr_Call_ID.s_value, this.o_request.o_hdr_CSeq.i_seq))){
		// Via
		o_request.o_hdr_firstVia = this.o_request.o_hdr_firstVia;
		// tags
		if(o_request.o_hdr_From){
			o_request.o_hdr_From.s_tag = this.o_request.o_hdr_From.s_tag;
		}
		if(o_request.o_hdr_To){
			o_request.o_hdr_To.s_tag = o_response.o_hdr_To.s_tag;
        }

        /* Add outbound proxy */
        // The outbound proxy is added as Route header only if the transport is WS/WSS to allow webrtc2sip to forward the request
        // For all other protocols (e.g UDP) the request will already be sent to the outbound proxy address
        if (this.get_stack().network.e_proxy_cscf_type == tsip_transport_type_e.WS || this.get_stack().network.e_proxy_cscf_type == tsip_transport_type_e.WSS) {
        var s_proxy_outbound = this.get_stack().__get_proxy_outbound_uri_string();
            if (s_proxy_outbound) {
                o_request.add_header(new tsip_header_Dummy("Route", s_proxy_outbound), true/*top*/);
            }
        }
		// Routes
		for(var i = 0; i < this.o_request.ao_headers.length; ++i){
			if(this.o_request.ao_headers[i].e_type == tsip_header_type_e.Route){
                o_request.add_header(this.o_request.ao_headers[i]);
			}
		}

		// SigComp
		o_request.s_sigcomp_id = this.get_session().s_sigcomp_id;

		// send the request
        i_ret = this.send(o_request.o_hdr_firstVia.s_branch, o_request);
	}

	return i_ret;
}

//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

function __tsip_transac_ict_Started_2_Calling_X_send(ao_args) {
    var o_transac = ao_args[0];

    //== Send the request
    o_transac.send(o_transac.s_branch, o_transac.o_request);

	/* RFC 3261 - 17.1.1.2 Formal Description
		If an unreliable transport is being used, the client transaction MUST 
		start timer A with a value of T1.
		If a reliable transport is being used, the client transaction SHOULD
		NOT start timer A (Timer A controls request retransmissions).  For
		any transport, the client transaction MUST start timer B with a value
		of 64*T1 seconds (Timer B controls transaction timeouts).
	*/
    if (!o_transac.b_reliable) {
        o_transac.timer_schedule('ict', 'A');
    }
	o_transac.timer_schedule('ict', 'B');

	return 0;
}

function __tsip_transac_ict_Calling_2_Calling_X_timerA(ao_args) {
    var o_transac = ao_args[0];

	/*	RFC 3261 - 17.1.1.2 Formal Description
		When timer A fires, the client transaction MUST retransmit the
		request by passing it to the transport layer, and MUST reset the
		timer with a value of 2*T1.  The formal definition of retransmit

		within the context of the transaction layer is to take the message
		previously sent to the transport layer and pass it to the transport
		layer once more.

		When timer A fires 2*T1 seconds later, the request MUST be
		retransmitted again (assuming the client transaction is still in this
		state).  This process MUST continue so that the request is
		retransmitted with intervals that double after each transmission.
		These retransmissions SHOULD only be done while the client
		transaction is in the "calling" state.
	*/

	//== Send the request
	o_transac.send(o_transac.s_branch, o_transac.o_request);
    	
    o_transac.i_timerA <<= 1; /* Will not raise indefinitely ==> see timer B */
	o_transac.timer_schedule('ict', 'A');

	return 0;
}

function __tsip_transac_ict_Calling_2_Terminated_X_timerB(ao_args) {
    var o_transac = ao_args[0];

	/*	RFC 3261 - 17.1.1.2 Formal Description
		If the client transaction is still in the "Calling" state when timer
		B fires, the client transaction SHOULD inform the TU that a timeout
		has occurred.  The client transaction MUST NOT generate an ACK.  The
		value of 64*T1 is equal to the amount of time required to send seven
		requests in the case of an unreliable transport.
	*/
    o_transac.get_dialog().callback(tsip_dialog_event_type_e.TIMEDOUT, null);
	
	return 0;
}

function __tsip_transac_ict_Calling_2_Completed_X_300_to_699(ao_args) {
    var o_transac = ao_args[0];
	var o_response = ao_args[1];
	var i_ret;

	/*	draft-sparks-sip-invfix-03 - 8.4.  Pages 126 through 128
		When in either the "Calling" or "Proceeding" states, reception of
		a response with status code from 300-699 MUST cause the client
		transaction to transition to "Completed".  The client transaction
		MUST pass the received response up to the TU, and the client
		transaction MUST generate an ACK request, even if the transport is
		reliable (guidelines for constructing the ACK from the response
		are given in Section 17.1.1.3) and then pass the ACK to the
		transport layer for transmission.  The ACK MUST be sent to the
		same address, port, and transport to which the original request
		was sent.
	*/
	/* Do not retransmit */
	if(!o_transac.b_reliable){
		o_transac.timer_cancel('A');
	}
	o_transac.timer_cancel('B'); /* Now it's up to the UAS to update the FSM. */

	/*	draft-sparks-sip-invfix-03 - 8.4.  Pages 126 through 128
		The client transaction MUST start timer D when it enters the
		"Completed" state for any reason, with a value of at least 32
		seconds for unreliable transports, and a value of zero seconds for
		reliable transports.  Timer D reflects the amount of time that the
		server transaction can remain in the "Completed" state when
		unreliable transports are used.
   */
	o_transac.timer_schedule('ict', 'D'); /* timerD already have the right value (0 if reliable and non-zero otherwise) */

	/* Send ACK */
	if ((i_ret = o_transac.send_ack(o_response)) <= 0) {
	    return i_ret;
	}

	/* Pass the response to the dialog. */
    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_response);
}

function __tsip_transac_ict_Calling_2_Proceeding_X_1xx(ao_args) {
    var o_transac = ao_args[0];
	var o_response = ao_args[1];
	
	/*	RFC 3261 - 17.1.1.2 Formal Description
		If the client transaction receives a provisional response while in
		the "Calling" state, it transitions to the "Proceeding" state. In the
		"Proceeding" state, the client transaction SHOULD NOT retransmit the
		request any longer. Furthermore, the provisional response MUST be
		passed to the TU.  Any further provisional responses MUST be passed
		up to the TU while in the "Proceeding" state.
	*/
	
	/* Do not retransmit */
	if(!o_transac.b_reliable){
		o_transac.timer_cancel('A');
	}
	o_transac.timer_cancel('B'); /* Now it's up to the UAS to update the FSM. */
	
	/* Pass the provisional response to the dialog. */
	return o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_response);
}

function __tsip_transac_ict_Calling_2_Accepted_X_2xx(ao_args) {
    var o_transac = ao_args[0];
	var o_response = ao_args[1];
	
	/*	draft-sparks-sip-invfix-03 - 8.4.  Pages 126 through 128
		When a 2xx response is received while in either the "Calling" or
		"Proceeding" states, the client transaction MUST transition to the
		"Accepted" state, and Timer M MUST be started with a value of
		64*T1.  The 2xx response MUST be passed up to the TU.  The client
		transaction MUST NOT generate an ACK to the 2xx response - its
		handling is delegated to the TU.
	*/
	
	/* Schedule timer M */
	o_transac.timer_schedule('ict', 'M');
	
	/* Cancel timers A and B */
	if(!o_transac.b_reliable){
		o_transac.timer_schedule('ict', 'A');
	}
	o_transac.timer_schedule('ict', 'B');

	/* pass the response to the TU (dialog) */
	return o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_response);
}

function __tsip_transac_ict_Proceeding_2_Proceeding_X_1xx(ao_args) {
    var o_transac = ao_args[0];
	var o_response = ao_args[1];

	/* pass the response to the TU (dialog) */
	return o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_response);
}

function __tsip_transac_ict_Proceeding_2_Completed_X_300_to_699(ao_args) {
    var o_transac = ao_args[0];
	var o_response = ao_args[1];
	var i_ret;

	/*	draft-sparks-sip-invfix-03 - 8.4.  Pages 126 through 128
		When in either the "Calling" or "Proceeding" states, reception of
		a response with status code from 300-699 MUST cause the client
		transaction to transition to "Completed".  The client transaction
		MUST pass the received response up to the TU, and the client
		transaction MUST generate an ACK request, even if the transport is
		reliable (guidelines for constructing the ACK from the response
		are given in Section 17.1.1.3) and then pass the ACK to the
		transport layer for transmission.  The ACK MUST be sent to the
		same address, port, and transport to which the original request
		was sent.
	*/
	/* Do not retransmit */
	if(!o_transac.b_reliable){
		o_transac.timer_cancel('A');
	}
	o_transac.timer_cancel('B'); /* Now it's up to the UAS to update the FSM. */

	/*	draft-sparks-sip-invfix-03 - 8.4.  Pages 126 through 128
		The client transaction MUST start timer D when it enters the
		"Completed" state for any reason, with a value of at least 32
		seconds for unreliable transports, and a value of zero seconds for
		reliable transports.  Timer D reflects the amount of time that the
		server transaction can remain in the "Completed" state when
		unreliable transports are used.
   */
	o_transac.timer_schedule('ict', 'D'); /* timerD already have the right value (0 if reliable and non-zero otherwise) */

	/* Send ACK */
	if((i_ret = o_transac.send_ack(o_response)) <= 0){
		return i_ret;
	}

	/* Pass the response to the dialog */
    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_response);
}

function __tsip_transac_ict_Proceeding_2_Accepted_X_2xx(ao_args) {
    var o_transac = ao_args[0];
	var o_response = ao_args[1];

	/*	draft-sparks-sip-invfix-03 - 8.4.  Pages 126 through 128
		When a 2xx response is received while in either the "Calling" or
		"Proceeding" states, the client transaction MUST transition to the
		"Accepted" state, and Timer M MUST be started with a value of
		64*T1.  The 2xx response MUST be passed up to the TU.  The client
		transaction MUST NOT generate an ACK to the 2xx response - its
		handling is delegated to the TU.
	*/

	/* Schedule timer M */
	o_transac.timer_schedule('ict', 'M');

	/* Cancel timers A and B */
	if(!o_transac.b_reliable){
		o_transac.timer_schedule('ict', 'A');
	}
	o_transac.timer_schedule('ict', 'B');

	/* pass the response to the TU (dialog) */
	return o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_response);
}

function __tsip_transac_ict_Completed_2_Completed_X_300_to_699(ao_args) {
    var o_transac = ao_args[0];
    var o_response = ao_args[1];

	/*	draft-sparks-sip-invfix-03 - 8.4.  Pages 126 through 128
		Any retransmissions of a response with status code 300-699 that
		are received while in the "Completed" state MUST cause the ACK to
		be re-passed to the transport layer for retransmission, but the
		newly received response MUST NOT be passed up to the TU.
	*/

    return (o_transac.send_ack(o_response) <= 0 ? -1 : 0);
}

function __tsip_transac_ict_Completed_2_Terminated_X_timerD(ao_args) {
    /*	draft-sparks-sip-invfix-03 - 8.4.  Pages 126 through 128
    If timer D fires while the client transaction is in the
    "Completed" state, the client transaction MUST move to the
    "Terminated" state.
    */

    /* Timers will be canceled by "tsip_transac_ict_OnTerminated" */
    return 0;
}

function __tsip_transac_ict_Accepted_2_Accepted_X_2xx(ao_args) {
    var o_transac = ao_args[0];
    var o_response = ao_args[1];

	/*	draft-sparks-sip-invfix-03 - 7.2. UAC Impacts
		A 2xx response received while in the "Accepted" state MUST be passed to the TU and
		the machine remains in the "Accepted" state.  The client transaction
		MUST NOT generate an ACK to any 2xx response on its own.  The TU
		responsible for the transaction will generate the ACK.
	*/
	
	/* Pass the response to the TU. */
    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_response);
}

function __tsip_transac_ict_Accepted_2_Terminated_X_timerM(ao_args) {
    /*	draft-sparks-sip-invfix-03 - 8.4.  Pages 126 through 128
    If timer M fires while the client transaction is in the "Accepted"
    state, the client transaction MUST move to the "Terminated" state.
    */
    return 0;
}

function __tsip_transac_ict_Any_2_Terminated_X_transportError(ao_args) {
    var o_transac = ao_args[0];

	/* Timers will be canceled by "tsip_transac_ict_OnTerminated" */

    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.TRANSPORT_ERROR, null);
}

function __tsip_transac_ict_Any_2_Terminated_X_Error(ao_args) {
    var o_transac = ao_args[0];

	/* Timers will be canceled by "tsip_transac_ict_OnTerminated" */

    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.ERROR, null);
}

function __tsip_transac_ict_Any_2_Terminated_X_cancel(ao_args) {
    /* doubango-specific */
    return 0;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function __tsip_transac_ict_onterm(o_self) {
    o_self.timer_cancel('A');
    o_self.timer_cancel('B');
    o_self.timer_cancel('D');
    o_self.timer_cancel('M');

    return o_self.deinit();
}

function __tsip_transac_ict_event_callback(o_self, e_event_type, o_message) {
    if (!o_self) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }
    var i_ret = 0;

    switch (e_event_type) {
        case tsip_transac_event_type_e.INCOMING_MSG:
            {
                if (o_message && o_message.is_response()) {
                    if (o_message.is_1xx()) {
                        i_ret = o_self.fsm_act(tsip_transac_ict_actions_e.I_1XX, o_message);
                    }
                    else if (o_message.is_2xx()) {
                        i_ret = o_self.fsm_act(tsip_transac_ict_actions_e.I_2XX, o_message);
                    }
                    else if (o_message.is_3456()) {
                        i_ret = o_self.fsm_act(tsip_transac_ict_actions_e.I_300_to_699, o_message);
                    }
                    else {
                        tsk_utils_log_warn("Not supported status code: " + o_message.get_response_code());
                    }
                }
                break;
            }

        case tsip_transac_event_type_e.CANCELED:
        case tsip_transac_event_type_e.TERMINATED:
        case tsip_transac_event_type_e.TIMEDOUT:
            break;

        case tsip_transac_event_type_e.ERROR:
            {
                i_ret = o_self.fsm_act(tsip_transac_ict_actions_e.ERROR, o_message);
                break;
            }

        case tsip_transac_event_type_e.TRANSPORT_ERROR:
            {
                i_ret = o_self.fsm_act(tsip_transac_ict_actions_e.TRANSPORT_ERROR, o_message);
                break;
            }
    }

    return i_ret;
}

function __tsip_transac_ict_timer_callback(o_self, o_timer) {
    if (o_self) {
        if (o_timer == o_self.o_timerA) {
            o_self.fsm_act(tsip_transac_ict_actions_e.TIMER_A, null);
        }
        else if (o_timer == o_self.o_timerB) {
            o_self.fsm_act(tsip_transac_ict_actions_e.TIMER_B, null);
        }
        else if (o_timer == o_self.o_timerD) {
            o_self.fsm_act(tsip_transac_ict_actions_e.TIMER_D, null);
        }
        else if (o_timer == o_self.o_timerM) {
            o_self.fsm_act(tsip_transac_ict_actions_e.TIMER_M, null);
        }
    }
}


/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/*
* SIP INVITE Server Transaction as per RFC 3261 subclause 17.2.1.
*/
tsip_transac_ist.prototype = Object.create(tsip_transac.prototype);
tsip_transac_ist.prototype.__b_debug_state_machine = true;

var tsip_transac_ist_actions_e =
{
	CANCEL: tsip_action_type_e.CANCEL,

	RECV_INVITE: 10001,
	RECV_ACK: 10002,
	SEND_1XX: 10003,
	SEND_2XX: 10004,
	SEND_300_to_699: 10005,
	SEND_NON1XX: 10006,
	TIMER_H: 10007,
	TIMER_I: 10008,
	TIMER_G: 10009,
	TIMER_L: 10010,
    TIMER_X: 10011,
    TRANSPORT_ERROR: 10012,
	ERROR: 10013
};

var tsip_transac_ist_states_e =
{
    STARTED: 0,
	PROCEEDING: 1,
	COMPLETED: 2,
	ACCEPTED: 3,
	CONFIRMED: 4,
	TERMINATED: 5
};


function tsip_transac_ist(b_reliable, i_cseq_value, s_callid, o_dialog) {
    var o_stack;
    if (!o_dialog || !(o_stack = o_dialog.get_stack())) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    tsip_transac.call(this);

    this.o_lastResponse = null;

    this.init(tsip_transac_type_e.IST, b_reliable, i_cseq_value, "INVITE", s_callid, o_dialog, tsip_transac_ist_states_e.STARTED, tsip_transac_ist_states_e.TERMINATED);
    this.set_callback(__tsip_transac_ist_event_callback);
    this.o_fsm.set_debug_enabled(tsip_transac_ist.prototype.__b_debug_state_machine);
    this.o_fsm.set_onterm_callback(__tsip_transac_ist_onterm, this);

    /* Timers */
    this.o_timerH = null;
    this.o_timerI = null;
    this.o_timerG = null;
    this.o_timerL = null;
    this.o_timerX = null;

    this.i_timerH = o_stack.o_timers.getH();
    this.i_timerI = b_reliable ? 0 : o_stack.o_timers.getI();
    this.i_timerG = o_stack.o_timers.getG();
    this.i_timerL = o_stack.o_timers.getL();
    this.i_timerX = o_stack.o_timers.getG();

    // initialize the state machine
    this.o_fsm.set(

        /*=======================
		* === Started === 
		*/
		// Started -> (recv INVITE) -> Proceeding
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.STARTED, tsip_transac_ist_actions_e.RECV_INVITE, tsip_transac_ist_states_e.PROCEEDING, __tsip_transac_ist_Started_2_Proceeding_X_INVITE, "tsip_transac_ist_Started_2_Proceeding_X_INVITE"),
		// Started -> (Any other) -> Started
		tsk_fsm_entry.prototype.CreateAlwaysNothing(tsip_transac_ist_states_e.STARTED, "tsip_transac_ist_Started_2_Started_X_any"),

		/*=======================
		* === Proceeding === 
		*/
		// Proceeding -> (recv INVITE) -> Proceeding
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.PROCEEDING, tsip_transac_ist_actions_e.RECV_INVITE, tsip_transac_ist_states_e.PROCEEDING, __tsip_transac_ist_Proceeding_2_Proceeding_X_INVITE, "tsip_transac_ist_Proceeding_2_Proceeding_X_INVITE"),
		// Proceeding -> (send 1xx) -> Proceeding
		tsk_fsm_entry.prototype.Create(tsip_transac_ist_states_e.PROCEEDING, tsip_transac_ist_actions_e.SEND_1XX, __tsip_transac_ist_cond_is_resp2invite, tsip_transac_ist_states_e.PROCEEDING, __tsip_transac_ist_Proceeding_2_Proceeding_X_1xx, "tsip_transac_ist_Proceeding_2_Proceeding_X_1xx"),
		// Proceeding -> (send 300to699) -> Completed
		tsk_fsm_entry.prototype.Create(tsip_transac_ist_states_e.PROCEEDING, tsip_transac_ist_actions_e.SEND_300_to_699, __tsip_transac_ist_cond_is_resp2invite, tsip_transac_ist_states_e.COMPLETED, __tsip_transac_ist_Proceeding_2_Completed_X_300_to_699, "tsip_transac_ist_Proceeding_2_Completed_X_300_to_699"),
		// Proceeding -> (send 2xx) -> Accepted
		tsk_fsm_entry.prototype.Create(tsip_transac_ist_states_e.PROCEEDING, tsip_transac_ist_actions_e.SEND_2XX, __tsip_transac_ist_cond_is_resp2invite, tsip_transac_ist_states_e.ACCEPTED, __tsip_transac_ist_Proceeding_2_Accepted_X_2xx, "tsip_transac_ist_Proceeding_2_Accepted_X_2xx"),

		/*=======================
		* === Completed === 
		*/
		// Completed -> (recv INVITE) -> Completed
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.COMPLETED, tsip_transac_ist_actions_e.RECV_INVITE, tsip_transac_ist_states_e.COMPLETED, __tsip_transac_ist_Completed_2_Completed_INVITE, "tsip_transac_ist_Completed_2_Completed_INVITE"),
		// Completed -> (timer G) -> Completed
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.COMPLETED, tsip_transac_ist_actions_e.TIMER_G, tsip_transac_ist_states_e.COMPLETED, __tsip_transac_ist_Completed_2_Completed_timerG, "tsip_transac_ist_Completed_2_Completed_timerG"),
		// Completed -> (timerH) -> Terminated
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.COMPLETED, tsip_transac_ist_actions_e.TIMER_H, tsip_transac_ist_states_e.TERMINATED, __tsip_transac_ist_Completed_2_Terminated_timerH, "tsip_transac_ist_Completed_2_Terminated_timerH"),
		// Completed -> (recv ACK) -> Confirmed
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.COMPLETED, tsip_transac_ist_actions_e.RECV_ACK, tsip_transac_ist_states_e.CONFIRMED, __tsip_transac_ist_Completed_2_Confirmed_ACK, "tsip_transac_ist_Completed_2_Confirmed_ACK"),
			
		/*=======================
		* === Accepted === 
		*/
		// Accepted -> (recv INVITE) -> Accepted
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.ACCEPTED, tsip_transac_ist_actions_e.RECV_INVITE, tsip_transac_ist_states_e.ACCEPTED, __tsip_transac_ist_Accepted_2_Accepted_INVITE, "tsip_transac_ist_Accepted_2_Accepted_INVITE"),
		// Accepted -> (send 2xx) -> Accepted
		tsk_fsm_entry.prototype.Create(tsip_transac_ist_states_e.ACCEPTED, tsip_transac_ist_actions_e.SEND_2XX, __tsip_transac_ist_cond_is_resp2invite, tsip_transac_ist_states_e.ACCEPTED, __tsip_transac_ist_Accepted_2_Accepted_2xx, "tsip_transac_ist_Accepted_2_Accepted_2xx"),
        // Accepted -> (timer X) -> Accepted
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.ACCEPTED, tsip_transac_ist_actions_e.TIMER_X, tsip_transac_ist_states_e.ACCEPTED, __tsip_transac_ist_Accepted_2_Accepted_timerX, "tsip_transac_ist_Accepted_2_Accepted_timerX"),
        // Accepted -> (recv ACK) -> Accepted
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.ACCEPTED, tsip_transac_ist_actions_e.RECV_ACK, tsip_transac_ist_states_e.ACCEPTED, __tsip_transac_ist_Accepted_2_Accepted_iACK, "tsip_transac_ist_Accepted_2_Accepted_iACK"),
		// Accepted -> (timerL) -> Terminated
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.ACCEPTED, tsip_transac_ist_actions_e.TIMER_L, tsip_transac_ist_states_e.TERMINATED, __tsip_transac_ist_Accepted_2_Terminated_timerL, "tsip_transac_ist_Accepted_2_Terminated_timerL"),

		/*=======================
		* === Confirmed === 
		*/
		// Confirmed -> (timerI) -> Terminated
		tsk_fsm_entry.prototype.CreateAlways(tsip_transac_ist_states_e.CONFIRMED, tsip_transac_ist_actions_e.TIMER_I, tsip_transac_ist_states_e.TERMINATED, __tsip_transac_ist_Confirmed_2_Terminated_timerI, "tsip_transac_ist_Confirmed_2_Terminated_timerI"),


		/*=======================
		* === Any === 
		*/
		// Any -> (transport error) -> Terminated
		tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_ist_actions_e.TRANSPORT_ERROR, tsip_transac_ist_states_e.TERMINATED, __tsip_transac_ist_Any_2_Terminated_X_transportError, "tsip_transac_ist_Any_2_Terminated_X_transportError"),
		// Any -> (error) -> Terminated
		tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_ist_actions_e.ERROR, tsip_transac_ist_states_e.TERMINATED, __tsip_transac_ist_Any_2_Terminated_X_Error, "tsip_transac_ist_Any_2_Terminated_X_Error"),
		// Any -> (cancel) -> Terminated
		tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_ist_actions_e.CANCEL, tsip_transac_ist_states_e.TERMINATED, __tsip_transac_ist_Any_2_Terminated_X_cancel, "tsip_transac_ist_Any_2_Terminated_X_cancel")
    );
}

tsip_transac_ist.prototype.start = function (o_request) {
	var i_ret = -1;
	if(o_request && !this.b_running){
		this.b_running = true;
		i_ret = this.fsm_act(tsip_transac_ist_actions_e.RECV_INVITE, o_request);
	}
	return i_ret;
}

tsip_transac_ist.prototype.set_last_response = function(o_response){
    this.o_lastResponse = o_response;
}

/* ======================== conds ======================== */
function __tsip_transac_ist_cond_is_resp2invite(o_transac, o_message) {
    return o_message.is_response_to_invite();
}

//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------


function __tsip_transac_ist_Started_2_Proceeding_X_INVITE(ao_args) {
    var o_transac = ao_args[0];
    var o_request = ao_args[1];
	var i_ret = -1;

	/*	RFC 3261 - 17.2.1 INVITE Server Transaction
		When a server transaction is constructed for a request, it enters the
		"Proceeding" state.  The server transaction MUST generate a 100
		(Trying) response unless it knows that the TU will generate a
		provisional or final response within 200 ms, in which case it MAY
		generate a 100 (Trying) response.

		RFC 3262 - 3. UAS Behavior
		A UAS MUST NOT attempt to send a 100 (Trying) response reliably.
	*/
	if(o_request){
		var o_response;
		if((o_response = new tsip_response(100, "Trying (sent from the Transaction Layer)", o_request))){
			i_ret = (o_transac.send(o_transac.s_branch, o_response) > 0 ? 0 : -1);
            o_transac.set_last_response(o_response);
		}
	}
	if(i_ret == 0){ /* Send "100 Trying" is OK ==> alert dialog for the incoming INVITE */
        i_ret = o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_request);
	}
	return i_ret;
}

function __tsip_transac_ist_Proceeding_2_Proceeding_X_INVITE(ao_args) {
    var o_transac = ao_args[0];
	var i_ret = -1;

	/*	RFC 3261 - 17.2.1 INVITE Server Transaction
		If a request retransmission is received while in the "Proceeding" state, the most
		recent provisional response that was received from the TU MUST be
		passed to the transport layer for retransmission.
	*/
	if(o_transac.o_lastResponse){
        i_ret = (o_transac.send(o_transac.s_branch, o_transac.o_lastResponse) > 0 ? 0 : -1);
	}

	return i_ret;
}

function __tsip_transac_ist_Proceeding_2_Proceeding_X_1xx(ao_args) {
    var o_transac = ao_args[0];
    var o_response = ao_args[1];
	var i_ret;

	/* Send to the transport layer */
    i_ret = (o_transac.send(o_transac.s_branch, o_response) > 0 ? 0 : -1);
	/* Update last response */
	o_transac.set_last_response(o_response);

	return i_ret;
}

function __tsip_transac_ist_Proceeding_2_Completed_X_300_to_699(ao_args) {
    var o_transac = ao_args[0];
    var o_response = ao_args[1];
	var i_ret;

	/*	RFC 3264 17.2.1 INVITE Server Transaction
		While in the "Proceeding" state, if the TU passes a response with
		status code from 300 to 699 to the server transaction, the response
		MUST be passed to the transport layer for transmission, and the state
		machine MUST enter the "Completed" state. For unreliable transports, timer G is set to fire in T1 seconds, 
		and is not set to fire for reliable transports.
	*/
	if(!o_transac.b_reliable){
        o_transac.timer_schedule('ist', 'G');
	}

	/* Send to the transport layer */
    i_ret = (o_transac.send(o_transac.s_branch, o_response) > 0 ? 0 : -1);

	/* Update last response */
    o_transac.set_last_response(o_response);

	/* RFC 3261 - 17.2.1 INVITE Server Transaction
		When the "Completed" state is entered, timer H MUST be set to fire in
		64*T1 seconds for all transports.
	*/
    o_transac.timer_schedule('ist', 'H');

	return i_ret;
}

function __tsip_transac_ist_Proceeding_2_Accepted_X_2xx(ao_args) {
    var o_transac = ao_args[0];
    var o_response = ao_args[1];
	var i_ret;

	/*	draft-sparks-sip-invfix-03 - 8.5. Pages 134 to 135
		If, while in the "Proceeding" state, the TU passes a 2xx response
		to the server transaction, the server transaction MUST pass this
		response to the transport layer for transmission.  It is not
		retransmitted by the server transaction; retransmissions of 2xx
		responses are handled by the TU.  The server transaction MUST then
		transition to the "Accepted" state.
	*/
	i_ret = (o_transac.send(o_transac.s_branch, o_response) > 0 ? 0 : -1);

	/* Update last response */
	o_transac.set_last_response(o_response);

    /* RFC 3261 - 13.3.1.4 The INVITE is Accepted
		Since 2xx is retransmitted end-to-end, there may be hops between
		UAS and UAC that are UDP.  To ensure reliable delivery across
		these hops, the response is retransmitted periodically even if the
		transport at the UAS is reliable.
	*/
    o_transac.timer_schedule('ist', 'X');
    o_transac.i_timerX <<= 1;

	/*	draft-sparks-sip-invfix-03 - 8.7. Page 137
		When the INVITE server transaction enters the "Accepted" state,
		Timer L MUST be set to fire in 64*T1 for all transports.  This
		value matches both Timer B in the next upstream client state
		machine (the amount of time the previous hop will wait for a
		response when no provisionals have been sent) and the amount of
		time this (or any downstream) UAS core might be retransmitting the
		2xx while waiting for an ACK.
	*/
	o_transac.timer_schedule('ist', 'L');

	return i_ret;
}

function __tsip_transac_ist_Completed_2_Completed_INVITE(ao_args) {
    var o_transac = ao_args[0];
	var i_ret;

	/*	RFC 3261 - 17.2.1 INVITE Server Transaction
		Furthermore, while in the "Completed" state, if a request retransmission is
		received, the server SHOULD pass the response to the transport for
		retransmission.
	*/
	if(o_transac.o_lastResponse){
        i_ret = (o_transac.send(o_transac.s_branch, o_transac.o_lastResponse) > 0 ? 0 : -1);
	}

    return i_ret;
}

function __tsip_transac_ist_Completed_2_Completed_timerG(ao_args) {
    var o_transac = ao_args[0];
	var i_ret;
	
	/*	RFC 3261 - 17.2.1 INVITE Server Transaction
		If timer G fires, the response is passed to the transport layer once 
		more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds.  
		From then on, when timer G fires, the response is passed to the transport again for
		transmission, and timer G is reset with a value that doubles, unless
		that value exceeds T2, in which case it is reset with the value of T2.
	*/
	if(o_transac.o_lastResponse){
        i_ret = (o_transac.send(o_transac.s_branch, o_transac.o_lastResponse) > 0 ? 0 : -1);
	}
    o_transac.i_timerG = Math.min(o_transac.i_timerG << 1, o_transac.get_stack().o_timers.getT2());
    o_transac.timer_schedule('ist', 'G');

	return i_ret;
}

function __tsip_transac_ist_Completed_2_Terminated_timerH(ao_args) {
    var o_transac = ao_args[0];

	/*	RFC 3261 - 17.2.1 INVITE Server Transaction
		If timer H fires while in the "Completed" state, it implies that the
		ACK was never received.  In this case, the server transaction MUST
		transition to the "Terminated" state, and MUST indicate to the TU
		that a transaction failure has occurred.
	*/
    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.TRANSPORT_ERROR, null);
}

function __tsip_transac_ist_Completed_2_Confirmed_ACK(ao_args) {
    var o_transac = ao_args[0];

	/*	RFC 3261 - 17.2.1 INVITE Server Transaction
		If an ACK is received while the server transaction is in the
		"Completed" state, the server transaction MUST transition to the
		"Confirmed" state.  As Timer G is ignored in this state, any
		retransmissions of the response will cease
	*/
    o_transac.timer_cancel('G'); /* To avoid warnings from FSM manager. */

	/*	RFC 3261 - 17.2.1 INVITE Server Transaction
		The purpose of the "Confirmed" state is to absorb any additional ACK
		messages that arrive, triggered from retransmissions of the final
		response.  When this state is entered, timer I is set to fire in T4
		seconds for unreliable transports, and zero seconds for reliable
		transports.
	*/
    o_transac.timer_schedule('ist', 'I'); /* Has the right value (zero of reliable and ...) */

	return 0;
}

function __tsip_transac_ist_Accepted_2_Accepted_INVITE(ao_args) {
    var o_transac = ao_args[0];
	
	/*	draft-sparks-sip-invfix-03 - 8.7. Page 137
		The purpose of the "Accepted" state is to absorb retransmissions
		of an accepted INVITE request.  Any such retransmissions are
		absorbed entirely within the server transaction.  They are not
		passed up to the TU since any downstream UAS cores that accepted
		the request have taken responsibility for reliability and will
		already retransmit their 2xx responses if neccessary.
	*/

	/*	Do not pass to the TU (see above)
		VERY IMPORTANT: INVITE dialog is responsible for reliability of the 2xx response.
	*/
    if (o_transac.o_lastResponse) {
        return (o_transac.send(o_transac.s_branch, o_transac.o_lastResponse) > 0 ? 0 : -1);
    }
	return 0;
}

function __tsip_transac_ist_Accepted_2_Accepted_2xx(ao_args) {
    var o_transac = ao_args[0];
    var o_response = ao_args[1];
	var i_ret;
	/*	draft-sparks-sip-invfix-03 - 8.7. Page 137
		While in the "Accepted" state, if the TU passes a 2xx response,
		the server transaction MUST pass the response to the transport
		layer for transmission.
	*/
	i_ret = (o_transac.send(o_transac.s_branch, o_response) > 0 ? 0 : -1);

	/* Update last response */
	o_transac.set_last_response(o_response);

	return i_ret;
}

/*	Accepted --> (timer X) --> Accepted
* Doubango specific
*/
function __tsip_transac_ist_Accepted_2_Accepted_timerX(ao_args){
	var o_transac = ao_args[0];
	if(o_transac.o_lastResponse){
		var i_ret = (o_transac.send(o_transac.s_branch, o_transac.o_lastResponse) > 0 ? 0 : -1);
		if (i_ret == 0) {
		    o_transac.i_timerX <<= 1;
		    o_transac.timer_schedule('ist', 'X');
		}
		return i_ret;
	}
	return 0;
}

  /* doubango-specific */
function __tsip_transac_ist_Accepted_2_Accepted_iACK(ao_args) {
    var o_transac = ao_args[0];
    var o_request = ao_args[1];
    o_transac.timer_cancel('X');
    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_request);
}

function __tsip_transac_ist_Accepted_2_Terminated_timerL(ao_args) {
    /*	draft-sparks-sip-invfix-03 - 8.7. Page 137
    If Timer L fires while the INVITE server transaction is in the "Accepted" state, the transaction
    MUST transition to the "Terminated" state. Once the transaction is in the "Terminated" state, it MUST be
    destroyed immediately.
    */
    return 0;
}

function __tsip_transac_ist_Confirmed_2_Terminated_timerI(ao_args) {
    /*	RFC 3261 - 17.2.1 INVITE Server Transaction
    Once timer I fires, the server MUST transition to the
    "Terminated" state.

    Once the transaction is in the "Terminated" state, it MUST be
    destroyed immediately.  As with client transactions, this is needed
    to ensure reliability of the 2xx responses to INVITE.
    */
    return 0;
}

function __tsip_transac_ist_Any_2_Terminated_X_transportError(ao_args) {
    var o_transac = ao_args[0];

	/* Timers will be canceled by "tsip_transac_nist_OnTerminated" */

    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.TRANSPORT_ERROR, null);
}

function __tsip_transac_ist_Any_2_Terminated_X_Error(ao_args) {
    var o_transac = ao_args[0];
    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.ERROR, null);
}

/* doubango-specific */
function __tsip_transac_ist_Any_2_Terminated_X_cancel(ao_args) {
    return 0;
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function __tsip_transac_ist_onterm(o_self) {
    o_self.timer_cancel('H');
    o_self.timer_cancel('I');
    o_self.timer_cancel('G');
    o_self.timer_cancel('L');
    o_self.timer_cancel('X');

    return o_self.deinit();
}

function __tsip_transac_ist_event_callback(o_self, e_event_type, o_message) {
    if (!o_self) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }
    var i_ret = -1;

    switch (e_event_type) {
        case tsip_transac_event_type_e.INCOMING_MSG: /* From Transport Layer to Transaction Layer */
            {
                if (o_message && o_message.is_request()) {
                    if (o_message.is_invite()) {
                        i_ret = o_self.fsm_act(tsip_transac_ist_actions_e.RECV_INVITE, o_message);
                    }
                    else if (o_message.is_ack()) {
                        i_ret = o_self.fsm_act(tsip_transac_ist_actions_e.RECV_ACK, o_message);
                    }
                }
                break;
            }

        case tsip_transac_event_type_e.OUTGOING_MSG: /* From TU to Transport Layer */
            {
                if (o_message && o_message.is_response()) {
                    if (o_message.is_1xx()) {
                        i_ret = o_self.fsm_act(tsip_transac_ist_actions_e.SEND_1XX, o_message);
                    }
                    else if (o_message.is_2xx()) {
                        i_ret = o_self.fsm_act(tsip_transac_ist_actions_e.SEND_2XX, o_message);
                    }
                    else if (o_message.is_3456()) {
                        i_ret = o_self.fsm_act(tsip_transac_ist_actions_e.SEND_300_to_699, o_message);
                    }
                }
                break;
            }

        case tsip_transac_event_type_e.CANCELED:
        case tsip_transac_event_type_e.TERMINATED:
        case tsip_transac_event_type_e.TIMEDOUT:
            break;

        case tsip_transac_event_type_e.ERROR:
            {
                i_ret = o_self.fsm_act(tsip_transac_ist_actions_e.ERROR, o_message);
                break;
            }

        case tsip_transac_event_type_e.TRANSPORT_ERROR:
            {
                i_ret = o_self.fsm_act(tsip_transac_ist_actions_e.TRANSPORT_ERROR, o_message);
                break;
            }
    }

    return i_ret;
}

function __tsip_transac_ist_timer_callback(o_self, o_timer) {
    if (o_self) {
        if (o_timer == o_self.o_timerH) {
            o_self.fsm_act(tsip_transac_ist_actions_e.TIMER_H, null);
        }
        else if (o_timer == o_self.o_timerI) {
            o_self.fsm_act(tsip_transac_ist_actions_e.TIMER_I, null);
        }
        else if (o_timer == o_self.o_timerG) {
            o_self.fsm_act(tsip_transac_ist_actions_e.TIMER_G, null);
        }
        else if (o_timer == o_self.o_timerL) {
            o_self.fsm_act(tsip_transac_ist_actions_e.TIMER_L, null);
        }
        else if (o_timer == o_self.o_timerX) {
            o_self.fsm_act(tsip_transac_ist_actions_e.TIMER_X, null);
        }
    }
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
function tsip_transac_layer(o_stack) {
    if (!o_stack) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }

    this.o_stack = o_stack;
    this.ao_transacs = new Array();
}

tsip_transac_layer.prototype.transac_new = function (b_is_ct, o_message, o_dialog) {
    if (!o_message || !o_message.o_hdr_CSeq || !o_message.o_hdr_Call_ID) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }

    var o_transac = null;

    while (this.b_locked){}

    this.b_locked = true;

    var b_reliable = true; // WebSockets
    if (this.o_stack.o_layer_transport.ao_transports.length > 0) {
        b_reliable = this.o_stack.o_layer_transport.ao_transports[0].is_reliable();
    }

    if (o_message) {
        if (o_message.is_request()) {
            if (b_is_ct)/* Client transaction */
            {
                if (o_message.is_invite()) {
                    // INVITE Client transaction (ICT)
                    o_transac = new tsip_transac_ict(b_reliable, o_message.o_hdr_CSeq.i_seq, o_message.o_hdr_Call_ID.s_value, o_dialog);
                }
                else {
                    // NON-INVITE Client transaction (NICT)
                    o_transac = new tsip_transac_nict(b_reliable, o_message.o_hdr_CSeq.i_seq, o_message.o_hdr_CSeq.s_method, o_message.o_hdr_Call_ID.s_value, o_dialog);
                }
            }
            else	/* Server transaction */
            {
                if (o_message.is_invite()) {
                    // INVITE Server transaction (IST)
                    o_transac = new tsip_transac_ist(b_reliable, o_message.o_hdr_CSeq.i_seq, o_message.o_hdr_Call_ID.s_value, o_dialog);
                }
                else {
                    // NON-INVITE Server transaction (NIST)
                    o_transac = new tsip_transac_nist(b_reliable, o_message.o_hdr_CSeq.i_seq, o_message.o_hdr_CSeq.s_method, o_message.o_hdr_Call_ID.s_value, o_dialog);
                }

                if (o_transac) { /* Copy branch from the message */
                    o_transac.s_branch = o_message.o_hdr_firstVia.s_branch;
                }
            }

            /* Add new transaction */
            if (o_transac) {
                this.ao_transacs.push(o_transac);
            }
        }
    }

    this.b_locked = false;

    return o_transac;
}

tsip_transac_layer.prototype.indexof = function (o_transac) {
    var i_index = -1;
    if (o_transac) {
        while (this.b_locked){}

        this.b_locked = true;
        for(var i = 0; i < this.ao_transacs.length; ++i){
            if(o_transac == this.ao_transacs[i]){
                i_index = i;
                break;
            }
        }
        this.b_locked = false;
    }
    return i_index;
}

tsip_transac_layer.prototype.remove = function (o_transac) {
    if (o_transac) {
        while (this.b_locked){}

        this.b_locked = true;
        for (var i = 0; i < this.ao_transacs.length; ++i) {
            if (o_transac == this.ao_transacs[i]) {
                this.ao_transacs.splice(i, 1);
                break;
            }
        }
        this.b_locked = false;
    }
};

tsip_transac_layer.prototype.cancel_by_dialog = function (o_dialog) {
    if (!o_dialog) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    var o_transac = null;

    while (this.b_locked){}

    this.b_locked = true;

    for (var i = 0; i < this.ao_transacs.length; ++i) {
        o_transac = this.ao_transacs[i];
        if (o_dialog.compare(o_transac.get_dialog()) == 0) {
            // async call to avoid dealoc
            setTimeout(function () { o_transac.fsm_act(tsip_action_type_e.CANCEL, null); }, 1);
        }
    }

    this.b_locked = false;

    return 0;
};

tsip_transac_layer.prototype.find_client = function (o_response) {
    if (!o_response) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }

    /*
        RFC 3261 - 17.1.3 Matching Responses to Client Transactions

        When the transport layer in the client receives a response, it has to
        determine which client transaction will handle the response, so that
        the processing of Sections 17.1.1 and 17.1.2 can take place.  The
        branch parameter in the top Via header field is used for this
        purpose.  A response matches a client transaction under two
        conditions:

        1.  If the response has the same value of the branch parameter in
        the top Via header field as the branch parameter in the top
        Via header field of the request that created the transaction.

        2.  If the method parameter in the CSeq header field matches the
        method of the request that created the transaction.  The
        method is needed since a CANCEL request constitutes a
        different transaction, but shares the same value of the branch
        parameter.
    */

    var o_ret = null;
	var o_transac;

	/*	Check first Via/CSeq validity.
	*/
	if(!o_response.o_hdr_firstVia || !o_response.o_hdr_CSeq){
		return null;
	}

    while (this.b_locked){}

	this.b_locked = true;

	for(var i = 0; i < this.ao_transacs.length; ++i){
		o_transac = this.ao_transacs[i];
		if( (o_transac.s_branch == o_response.o_hdr_firstVia.s_branch) 
			&& (o_transac.s_cseq_method == o_response.o_hdr_CSeq.s_method)){
		    o_ret = o_transac;
			break;
		}
	}

	this.b_locked = false;

    return o_ret;
};

tsip_transac_layer.prototype.find_server = function(o_message)
{
	/*
	   RFC 3261 - 17.2.3 Matching Requests to Server Transactions

	   When a request is received from the network by the server, it has to
	   be matched to an existing transaction.  This is accomplished in the
	   following manner.

	   The branch parameter in the topmost Via header field of the request
	   is examined.  If it is present and begins with the magic cookie
	   "z9hG4bK", the request was generated by a client transaction
	   compliant to this specification.  Therefore, the branch parameter
	   will be unique across all transactions sent by that client.  The
	   request matches a transaction if:

		  1. the branch parameter in the request is equal to the one in the
			 top Via header field of the request that created the
			 transaction, and

		  2. the sent-by value in the top Via of the request is equal to the
			 one in the request that created the transaction, and

		  3. the method of the request matches the one that created the
			 transaction, except for ACK, where the method of the request
			 that created the transaction is INVITE.
	*/
	var o_ret = null;
	var o_transac;

	/*	Check first Via/CSeq validity */
	if(!o_message.o_hdr_firstVia || !o_message.o_hdr_CSeq || !o_message.o_hdr_Call_ID){
		return null;
	}

	while (this.b_locked){}

	this.b_locked = true;

	for(var i = 0; i < this.ao_transacs.length; ++i){
		o_transac = this.ao_transacs[i];
		if(o_message.is_ack() && (o_transac.s_callid == o_message.o_hdr_Call_ID.s_value)){ /* 1. ACK branch won't match INVITE's but they MUST have the same CSeq/CallId values */
			if(tsk_string_iequals(o_transac.s_cseq_method, "INVITE") && o_message.o_hdr_CSeq.i_seq == o_transac.i_cseq_value){
				o_ret = o_transac;
				break;
			}
		}
		else if(tsk_string_equals(o_transac.s_branch, o_message.o_hdr_firstVia.s_branch) /* 2. Compare branches*/
			&& (1 == 1) /* FIXME: compare host:ip */){
			if(tsk_string_equals(o_transac.s_cseq_method, o_message.o_hdr_CSeq.s_method)){
				o_ret = o_transac;
				break;
			}
            else if (o_message.is_cancel() || o_message.is_response_to_cancel()) {
                o_ret = o_transac;
				break;
			}
		}
	}

	this.b_locked = false;

	return o_ret;
}

tsip_transac_layer.prototype.handle_incoming_message = function (o_message) {
    if (!o_message) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }
    var i_ret = -1;
    var o_transac = null;

    if (o_message.is_request()) {
        o_transac = this.find_server(o_message);
    }
    else {
        o_transac = this.find_client(o_message);
    }

    if (o_transac) {
        i_ret = o_transac.callback(tsip_transac_event_type_e.INCOMING_MSG, o_message);
    }

    return i_ret;
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/*
* SIP Non-INVITE Client Transaction as per RFC 3261 subcaluse 17.1.2.
*/
tsip_transac_nict.prototype = Object.create(tsip_transac.prototype);
tsip_transac_nict.prototype.__b_debug_state_machine = false;

var tsip_transac_nict_actions_e = 
{
	CANCEL: tsip_action_type_e.CANCEL,

	SEND: 10001,
	TIMER_E: 10002,
	TIMER_F: 10003,
	TIMER_K: 10004,
	I_1xx: 10005,
	I_200_to_699: 10006,
	TRANSPORT_ERROR: 10007,
	ERROR: 10008
};

var tsip_transac_nict_states_e = 
{
	STARTED: 0,
	TRYING: 1,
	PROCEEDING: 2,
	COMPLETED: 3,
	TERMINATED: 4
};

function tsip_transac_nict(b_reliable, i_cseq_value, s_cseq_method, s_callid, o_dialog) {
    var o_stack;
    if(!o_dialog || !(o_stack = o_dialog.get_stack())){
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    tsip_transac.call(this);
    this.o_request = null;

    this.init(tsip_transac_type_e.NICT, b_reliable, i_cseq_value, s_cseq_method, s_callid, o_dialog, tsip_transac_nict_states_e.STARTED, tsip_transac_nict_states_e.TERMINATED);
    this.set_callback(__tsip_transac_nict_event_callback);
    this.o_fsm.set_debug_enabled(tsip_transac_nict.prototype.__b_debug_state_machine);
    this.o_fsm.set_onterm_callback(__tsip_transac_nict_onterm, this);

    /* Timers */
	this.o_timerE = null;
	this.o_timerF = null;
	this.o_timerK = null;

	this.i_timerE = o_stack.o_timers.getE();
	this.i_timerF = o_stack.o_timers.getF();
	this.i_timerK = b_reliable ? 0 : o_stack.o_timers.getK(); /* RFC 3261 - 17.1.2.2*/

	// initialize the state machine
	this.o_fsm.set(
	    /*=======================
	    * === Started === 
	    */
	    // Started -> (Send) -> Trying
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.STARTED, tsip_transac_nict_actions_e.SEND, tsip_transac_nict_states_e.TRYING, __tsip_transac_nict_Started_2_Trying_X_send, "__tsip_transac_nict_Started_2_Trying_X_send"),
	    // Started -> (Any) -> Started
	    tsk_fsm_entry.prototype.CreateAlwaysNothing(tsip_transac_nict_states_e.STARTED, "tsip_transac_nict_Started_2_Started_X_any"),

	    /*=======================
	    * === Trying === 
	    */
	    // Trying -> (timerE) -> Trying
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.TRYING, tsip_transac_nict_actions_e.TIMER_E, tsip_transac_nict_states_e.TRYING, __tsip_transac_nict_Trying_2_Trying_X_timerE, "__tsip_transac_nict_Trying_2_Trying_X_timerE"),
	    // Trying -> (timerF) -> Terminated
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.TRYING, tsip_transac_nict_actions_e.TIMER_F, tsip_transac_nict_states_e.TERMINATED, __tsip_transac_nict_Trying_2_Terminated_X_timerF, "__tsip_transac_nict_Trying_2_Terminated_X_timerF"),
	    // Trying -> (transport error) -> Terminated
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.TRYING, tsip_transac_nict_actions_e.TRANSPORT_ERROR, tsip_transac_nict_states_e.TERMINATED, __tsip_transac_nict_Trying_2_Terminated_X_transportError, "__tsip_transac_nict_Trying_2_Terminated_X_transportError"),
	    // Trying  -> (1xx) -> Proceeding
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.TRYING, tsip_transac_nict_actions_e.I_1xx, tsip_transac_nict_states_e.PROCEEDING, __tsip_transac_nict_Trying_2_Proceedding_X_1xx, "__tsip_transac_nict_Trying_2_Proceedding_X_1xx"),
	    // Trying  -> (200 to 699) -> Completed
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.TRYING, tsip_transac_nict_actions_e.I_200_to_699, tsip_transac_nict_states_e.COMPLETED, __tsip_transac_nict_Trying_2_Completed_X_200_to_699, "__tsip_transac_nict_Trying_2_Completed_X_200_to_699"),

	    /*=======================
	    * === Proceeding === 
	    */
	    // Proceeding -> (timerE) -> Proceeding
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.PROCEEDING, tsip_transac_nict_actions_e.TIMER_E, tsip_transac_nict_states_e.PROCEEDING, __tsip_transac_nict_Proceeding_2_Proceeding_X_timerE, "__tsip_transac_nict_Proceeding_2_Proceeding_X_timerE"),
	    // Proceeding -> (timerF) -> Terminated
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.PROCEEDING, tsip_transac_nict_actions_e.TIMER_F, tsip_transac_nict_states_e.TERMINATED, __tsip_transac_nict_Proceeding_2_Terminated_X_timerF, "__tsip_transac_nict_Proceeding_2_Terminated_X_timerF"),
	    // Proceeding -> (transport error) -> Terminated
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.PROCEEDING, tsip_transac_nict_actions_e.TRANSPORT_ERROR, tsip_transac_nict_states_e.TERMINATED, __tsip_transac_nict_Proceeding_2_Terminated_X_transportError, "__tsip_transac_nict_Proceeding_2_Terminated_X_transportError"),
	    // Proceeding -> (1xx) -> Proceeding
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.PROCEEDING, tsip_transac_nict_actions_e.I_1xx, tsip_transac_nict_states_e.PROCEEDING, __tsip_transac_nict_Proceeding_2_Proceeding_X_1xx, "__tsip_transac_nict_Proceeding_2_Proceeding_X_1xx"),
	    // Proceeding -> (200 to 699) -> Completed
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.PROCEEDING, tsip_transac_nict_actions_e.I_200_to_699, tsip_transac_nict_states_e.COMPLETED, __tsip_transac_nict_Proceeding_2_Completed_X_200_to_699, "__tsip_transac_nict_Proceeding_2_Completed_X_200_to_699"),

	    /*=======================
	    * === Completed === 
	    */
	    // Completed -> (timer K) -> Terminated
	    tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nict_states_e.COMPLETED, tsip_transac_nict_actions_e.TIMER_K, tsip_transac_nict_states_e.TERMINATED, __tsip_transac_nict_Completed_2_Terminated_X_timerK, "__tsip_transac_nict_Completed_2_Terminated_X_timerK"),

	    /*=======================
	    * === Any === 
	    */
	    // Any -> (transport error) -> Terminated
	    tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_nict_actions_e.TRANSPORT_ERROR, tsip_transac_nict_states_e.TERMINATED, __tsip_transac_nict_Any_2_Terminated_X_transportError, "__tsip_transac_nict_Any_2_Terminated_X_transportError"),
	    // Any -> (error) -> Terminated
	    tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_nict_actions_e.ERROR, tsip_transac_nict_states_e.TERMINATED, __tsip_transac_nict_Any_2_Terminated_X_Error, "__tsip_transac_nict_Any_2_Terminated_X_Error"),
	    // Any -> (cancel) -> Terminated
	    tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_nict_actions_e.CANCEL, tsip_transac_nict_states_e.TERMINATED, __tsip_transac_nict_Any_2_Terminated_X_cancel, "__tsip_transac_nict_Any_2_Terminated_X_cancel")

	);
}

tsip_transac_nict.prototype.start = function (o_request) {
    var i_ret = -1;
	if(o_request && !this.b_running){
		/* Add branch to the new client transaction
		* IMPORTANT: CANCEL will have the same Via and Contact headers as the request it cancel
		*/
		if(o_request.is_cancel()){
			this.s_branch = o_request.o_hdr_firstVia ? o_request.o_hdr_firstVia.s_branch : "doubango";
		}
        else{
            this.s_branch = tsk_string_format("{0}{1}", tsip_transac.prototype.__magic_cookie, tsk_string_random(32));
        }

		this.b_running = true;
		this.o_request = o_request;

		i_ret = this.fsm_act(tsip_transac_nict_actions_e.SEND, o_request);
	}
    return i_ret;
};

/* ======================== transitions ======================== */
function __tsip_transac_nict_Started_2_Trying_X_send(ao_args) {
    var o_transac = ao_args[0];
    var o_request = ao_args[1];

	//== Send the request
    o_transac.send(o_transac.s_branch, o_request);

	/*	RFC 3261 - 17.1.2.2
		The "Trying" state is entered when the TU initiates a new client
		transaction with a request.  When entering this state, the client
		transaction SHOULD set timer F to fire in 64*T1 seconds.
	*/
    o_transac.timer_schedule('nict', 'F');
		
	/*	RFC 3261 - 17.1.2.2
		If an  unreliable transport is in use, the client transaction MUST set timer
		E to fire in T1 seconds.
	*/
	if (!o_transac.b_reliable) {
	    o_transac.timer_schedule('nict', 'E');
	}

    return 0;
}

function __tsip_transac_nict_Trying_2_Trying_X_timerE(ao_args) {
    var o_transac = ao_args[0];

	//== Send the request
    o_transac.send(o_transac.s_branch, o_transac.o_request);

	/*	RFC 3261 - 17.1.2.2
		If timer E fires while still in this (Trying) state, the timer is reset, but this time with a value of MIN(2*T1, T2).
		When the timer fires again, it is reset to a MIN(4*T1, T2).  This process continues so that retransmissions occur with an exponentially
	    increasing interval that caps at T2.  The default value of T2 is 4s, and it represents the amount of time a non-INVITE server transaction
	    will take to respond to a request, if it does not respond immediately.  For the default values of T1 and T2, this results in
	    intervals of 500 ms, 1 s, 2 s, 4 s, 4 s, 4 s, etc.
	*/
    o_transac.i_timerE = Math.min(o_transac.i_timerE << 1, o_transac.get_stack().o_timers.getT2());
    o_transac.timer_schedule('nict', 'E');

	return 0;
}

function __tsip_transac_nict_Trying_2_Terminated_X_timerF(ao_args) {
    var o_transac = ao_args[0];
    
	/*	RFC 3261 - 17.1.2.2
		If Timer F fires while the client transaction is still in the
		"Trying" state, the client transaction SHOULD inform the TU about the
		timeout, and then it SHOULD enter the "Terminated" state.
	*/

	/* Timers will be canceled by "tsip_transac_nict_OnTerminated" */
	
    o_transac.get_dialog().callback(tsip_dialog_event_type_e.TIMEDOUT, o_transac.o_request);

	return 0;
}

function __tsip_transac_nict_Trying_2_Terminated_X_transportError(ao_args) {
    var o_transac = ao_args[0];

	/* Timers will be canceled by "tsip_transac_nict_OnTerminated" */

    o_transac.get_dialog().callback(tsip_dialog_event_type_e.TRANSPORT_ERROR, o_transac.o_request);

    return 0;
}

function __tsip_transac_nict_Trying_2_Proceedding_X_1xx(ao_args) {
    var o_transac = ao_args[0];
    var o_message1xx = ao_args[1];

	/*	RFC 3261 - 17.1.2.2
		If a provisional response is received while in the "Trying" state, the
		response MUST be passed to the TU, and then the client transaction
		SHOULD move to the "Proceeding" state.
	*/

	/* Cancel timers */
	if(!o_transac.b_reliable){
		o_transac.timer_cancel('E');
	}
	o_transac.timer_cancel('F'); /* Now it's up to the UAS to update the FSM. */
	
	/* Pass the provisional response to the dialog */
	o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_message1xx);

	return 0;
}

function __tsip_transac_nict_Trying_2_Completed_X_200_to_699(ao_args) {
    var o_transac = ao_args[0];
    var o_message = ao_args[1];

	/*	RFC 3261 - 17.1.2.2
		If a final response (status codes 200-699) is received while in the "Trying" state, the response
		MUST be passed to the TU, and the client transaction MUST transition
		to the "Completed" state.

		If Timer K fires while in this state (Completed), the client transaction MUST transition to the "Terminated" state.
	*/

	if(!o_transac.b_reliable){
		o_transac.timer_cancel('E');
	}
	o_transac.timer_cancel('F');

    /* Pass the final response to the dialog */
    o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_message);

    /* SCHEDULE timer K */
    o_transac.timer_schedule('nict', 'K');

	return 0;
}

function __tsip_transac_nict_Proceeding_2_Proceeding_X_timerE(ao_args) {
    var o_transac = ao_args[0];

	//== Send the request
    o_transac.send(o_transac.s_branch, o_transac.o_request);

	/*	RFC 3261 - 17.1.2.2
		If Timer E fires while in the "Proceeding" state, the request MUST be
		passed to the transport layer for retransmission, and Timer E MUST be
		reset with a value of T2 seconds.
	*/
    o_transac.i_timerE = Math.min(o_transac.i_timerE << 1, o_transac.get_stack().o_timers.getT2());
    o_transac.timer_schedule('nict', 'E');

	return 0;
}

function __tsip_transac_nict_Proceeding_2_Terminated_X_timerF(ao_args) {
    var o_transac = ao_args[0];
    
	/*	RFC 3261 - 17.1.2.2
		If timer F fires while in the "Proceeding" state, the TU MUST be informed of a timeout, and the
		client transaction MUST transition to the terminated state.
	*/

	/* Timers will be canceled by "tsip_transac_nict_OnTerminated" */
    o_transac.get_dialog().callback(tsip_dialog_event_type_e.TRANSPORT_ERROR, null);

	return 0;
}

function __tsip_transac_nict_Proceeding_2_Terminated_X_transportError(ao_args) {
    var o_transac = ao_args[0];

	/* Timers will be canceles by On */
    o_transac.get_dialog().callback(tsip_dialog_event_type_e.TRANSPORT_ERROR, null);

	return 0;
}

function __tsip_transac_nict_Proceeding_2_Proceeding_X_1xx(ao_args) {
    var o_transac = ao_args[0];
    var o_message1xx = ao_args[1];

	if(!o_transac.b_reliable){
		o_transac.timer_cancel('E');
	}
    o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_message1xx);

	return 0;
}

function __tsip_transac_nict_Proceeding_2_Completed_X_200_to_699(ao_args) {
    var o_transac = ao_args[0];
    var o_message = ao_args[1];

	/*	RFC 3261 - 17.1.2.2
		If a final response (status codes 200-699) is received while in the
		"Proceeding" state, the response MUST be passed to the TU, and the
		client transaction MUST transition to the "Completed" state.
	*/

	/*	RFC 3261 - 17.1.2.2
		Once the client transaction enters the "Completed" state, it MUST set
		Timer K to fire in T4 seconds for unreliable transports, and zero
		seconds for reliable transports.  The "Completed" state exists to
		buffer any additional response retransmissions that may be received
		(which is why the client transaction remains there only for

		unreliable transports).  T4 represents the amount of time the network
		will take to clear messages between client and server transactions.
		The default value of T4 is 5s.
	*/

	if(!o_transac.b_reliable){
		o_transac.timer_cancel('E');
	}

    o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_message);
	
	/* SCHEDULE timer K */
    o_transac.timer_schedule('nict', 'K');

	return 0;
}

function __tsip_transac_nict_Completed_2_Terminated_X_timerK(ao_args) {
    /*	RFC 3261 - 17.1.2.2
    If Timer K fires while in this state (Completed), the client transaction
    MUST transition to the "Terminated" state.
    */

    /*	RFC 3261 - 17.1.2.2
    ONCE THE TRANSACTION IS IN THE TERMINATED STATE, IT MUST BE DESTROYED IMMEDIATELY.
    */

    /* Timers will be canceled by "tsip_transac_nict_OnTerminated" */

    //TSIP_TRANSAC(self)->dialog->callback(TSIP_TRANSAC(self)->dialog, tsip_dialog_transac_ok, 0);

    return 0;
}

function __tsip_transac_nict_Any_2_Terminated_X_transportError(ao_args) {
    var o_transac = ao_args[0];

	/* Timers will be canceled by "tsip_transac_nict_OnTerminated" */

    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.TRANSPORT_ERROR, null);
}

function __tsip_transac_nict_Any_2_Terminated_X_Error(ao_args) {
    var o_transac = ao_args[0];

	/* Timers will be canceled by "tsip_transac_nict_OnTerminated" */

    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.ERROR, null);
}

/* doubango-specific */
function __tsip_transac_nict_Any_2_Terminated_X_cancel(ao_args) {
    /* doubango-specific */
    return 0;
}


function __tsip_transac_nict_onterm(o_self) {
    o_self.timer_cancel('E');
    o_self.timer_cancel('F');
    o_self.timer_cancel('K');

    return o_self.deinit();
}

function __tsip_transac_nict_event_callback(o_self, e_event_type, o_message) {
    if (!o_self) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }
	var i_ret = 0;

	switch (e_event_type){
	    case tsip_transac_event_type_e.INCOMING_MSG:
		    {
		        if (o_message && o_message.is_response()) {
		            if (o_message.is_1xx()) {
		                i_ret = o_self.fsm_act(tsip_transac_nict_actions_e.I_1xx, o_message);
				    }
					else if (o_message.is_23456()) {
					    i_ret = o_self.fsm_act(tsip_transac_nict_actions_e.I_200_to_699, o_message);
				    }
				    else{
				        tsk_utils_log_warn("Not supported status code: " + o_message.get_response_code());
				    }
			    }
			    break;
		    }

        case tsip_transac_event_type_e.CANCELED:
        case tsip_transac_event_type_e.TERMINATED:
        case tsip_transac_event_type_e.TIMEDOUT:
		    break;

		case tsip_transac_event_type_e.ERROR:
		    {
		        i_ret = o_self.fsm_act(tsip_transac_nict_actions_e.ERROR, o_message);
			    break;
		    }

        case tsip_transac_event_type_e.TRANSPORT_ERROR:
		    {
		        i_ret = o_self.fsm_act(tsip_transac_nict_actions_e.TRANSPORT_ERROR, o_message);
			    break;
		    }
	}

    return i_ret;
}

function __tsip_transac_nict_timer_callback(o_self, o_timer){
	if(o_self){
		if(o_timer == o_self.o_timerE){
			o_self.fsm_act(tsip_transac_nict_actions_e.TIMER_E, null);
		}
		else if(o_timer == o_self.o_timerF){
			o_self.fsm_act(tsip_transac_nict_actions_e.TIMER_F, null);
		}
		else if(o_timer == o_self.o_timerK){
			o_self.fsm_act(tsip_transac_nict_actions_e.TIMER_K, null);
		}
	}
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
/*
* SIP Non-INVITE Server Transaction as per RFC 3261 subclause 17.2.2.
*/
tsip_transac_nist.prototype = Object.create(tsip_transac.prototype);
tsip_transac_nist.prototype.__b_debug_state_machine = false;

var tsip_transac_nist_actions_e = 
{
	CANCEL: tsip_action_type_e.CANCEL,

	RECV_REQUEST: 10001,
	SEND_1XX: 10002,
	SEND_200_to_699: 10003,
	TIMER_J: 10004,
	TRANSPORT_ERROR: 10007,
	ERROR: 10008
};

var tsip_transac_nist_states_e = 
{
	STARTED: 0,
	TRYING: 1,
	PROCEEDING: 2,
	COMPLETED: 3,
	TERMINATED: 4
};

function tsip_transac_nist(b_reliable, i_cseq_value, s_cseq_method, s_callid, o_dialog) {
    var o_stack;
    if (!o_dialog || !(o_stack = o_dialog.get_stack())) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    tsip_transac.call(this);

    this.o_lastResponse = null;

    this.init(tsip_transac_type_e.nist, b_reliable, i_cseq_value, s_cseq_method, s_callid, o_dialog, tsip_transac_nist_states_e.STARTED, tsip_transac_nist_states_e.TERMINATED);
    this.set_callback(__tsip_transac_nist_event_callback);
    this.o_fsm.set_debug_enabled(tsip_transac_nist.prototype.__b_debug_state_machine);
    this.o_fsm.set_onterm_callback(__tsip_transac_nist_onterm, this);

    /* Timers */
    this.o_timerJ = null;
    this.i_timerJ = b_reliable ? 0 : o_stack.o_timers.getJ(); /* RFC 3261 - 17.2.2*/


    // initialize the state machine
    this.o_fsm.set(
        /*=======================
        * === Started === 
        */
        // Started -> (receive request) -> Trying
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nist_states_e.STARTED, tsip_transac_nist_actions_e.RECV_REQUEST, tsip_transac_nist_states_e.TRYING, tsip_transac_nist_Started_2_Trying_X_request, "tsip_transac_nist_Started_2_Trying_X_request"),
        // Started -> (Any other) -> Started
        tsk_fsm_entry.prototype.CreateAlwaysNothing(tsip_transac_nist_states_e.STARTED, "tsip_transac_nist_Started_2_Started_X_any"),

        /*=======================
        * === Trying === 
        */
        // Trying -> (send 1xx) -> Proceeding
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nist_states_e.TRYING, tsip_transac_nist_actions_e.SEND_1XX, tsip_transac_nist_states_e.PROCEEDING, tsip_transac_nist_Trying_2_Proceeding_X_send_1xx, "tsip_transac_nist_Trying_2_Proceeding_X_send_1xx"),
        // Trying -> (send 200 to 699) -> Completed
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nist_states_e.TRYING, tsip_transac_nist_actions_e.SEND_200_to_699, tsip_transac_nist_states_e.COMPLETED, tsip_transac_nist_Trying_2_Completed_X_send_200_to_699, "tsip_transac_nist_Trying_2_Completed_X_send_200_to_699"),

        /*=======================
        * === Proceeding === 
        */
        // Proceeding -> (send 1xx) -> Proceeding
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nist_states_e.PROCEEDING, tsip_transac_nist_actions_e.SEND_1XX, tsip_transac_nist_states_e.PROCEEDING, tsip_transac_nist_Proceeding_2_Proceeding_X_send_1xx, "tsip_transac_nist_Proceeding_2_Proceeding_X_send_1xx"),
        // Proceeding -> (send 200 to 699) -> Completed
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nist_states_e.PROCEEDING, tsip_transac_nist_actions_e.SEND_200_to_699, tsip_transac_nist_states_e.COMPLETED, tsip_transac_nist_Proceeding_2_Completed_X_send_200_to_699, "tsip_transac_nist_Proceeding_2_Completed_X_send_200_to_699"),
        // Proceeding -> (receive request) -> Proceeding
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nist_states_e.PROCEEDING, tsip_transac_nist_actions_e.RECV_REQUEST, tsip_transac_nist_states_e.PROCEEDING, tsip_transac_nist_Proceeding_2_Proceeding_X_request, "tsip_transac_nist_Proceeding_2_Proceeding_X_request"),

        /*=======================
        * === Completed === 
        */
        // Completed -> (receive request) -> Completed
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nist_states_e.COMPLETED, tsip_transac_nist_actions_e.RECV_REQUEST, tsip_transac_nist_states_e.COMPLETED, tsip_transac_nist_Completed_2_Completed_X_request, "tsip_transac_nist_Completed_2_Completed_X_request"),
        // Completed -> (timer J) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsip_transac_nist_states_e.COMPLETED, tsip_transac_nist_actions_e.TIMER_J, tsip_transac_nist_states_e.TERMINATED, tsip_transac_nist_Completed_2_Terminated_X_tirmerJ, "tsip_transac_nist_Completed_2_Terminated_X_tirmerJ"),

        /*=======================
        * === Any === 
        */
        // Any -> (transport error) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_nist_actions_e.TRANSPORT_ERROR, tsip_transac_nist_states_e.TERMINATED, tsip_transac_nist_Any_2_Terminated_X_transportError, "tsip_transac_nist_Any_2_Terminated_X_transportError"),
        // Any -> (transport error) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_nist_actions_e.ERROR, tsip_transac_nist_states_e.TERMINATED, tsip_transac_nist_Any_2_Terminated_X_Error, "tsip_transac_nist_Any_2_Terminated_X_Error"),
        // Any -> (cancel) -> Terminated
        tsk_fsm_entry.prototype.CreateAlways(tsk_fsm.prototype.__i_state_any, tsip_transac_nist_actions_e.CANCEL, tsip_transac_nist_states_e.TERMINATED, tsip_transac_nist_Any_2_Terminated_X_cancel, "tsip_transac_nist_Any_2_Terminated_X_cancel")
    );
}


tsip_transac_nist.prototype.start = function (o_request) {
    var i_ret = -1;
    if (o_request && !this.b_running) {
        this.b_running = true;
        i_ret = this.fsm_act(tsip_transac_nist_actions_e.RECV_REQUEST, o_request);
    }
    return i_ret;
}


//--------------------------------------------------------
//				== STATE MACHINE BEGIN ==
//--------------------------------------------------------

/* Started --> (INCOMING REQUEST) --> Trying
*/
function tsip_transac_nist_Started_2_Trying_X_request(ao_args){
	var o_transac = ao_args[0];
    var o_request = ao_args[1];

	/*	RFC 3261 - 17.2.2
		The state machine is initialized in the "Trying" state and is passed
		a request other than INVITE or ACK when initialized.  This request is
		passed up to the TU.  Once in the "Trying" state, any further request
		retransmissions are discarded.  A request is a retransmission if it
		matches the same server transaction, using the rules specified in
		Section 17.2.3.
	*/
    return o_transac.get_dialog().callback(tsip_dialog_event_type_e.I_MSG, o_request);
}

/* Trying --> (1xx) --> Proceeding
*/
function tsip_transac_nist_Trying_2_Proceeding_X_send_1xx(ao_args){
    var o_transac = ao_args[0];
    var o_response = ao_args[1];
	var i_ret;

	/*	RFC 3261 - 17.2.2
		While in the "Trying" state, if the TU passes a provisional response
		to the server transaction, the server transaction MUST enter the
		"Proceeding" state.  The response MUST be passed to the transport
		layer for transmission.
	*/
	i_ret = o_transac.send(this.s_branch, o_response) > 0 ? 0 : -1;

	/* Update last response */
    o_transac.o_lastResponse = o_response;

	return i_ret;
}

/*	Trying --> (200-699) --> Completed
*/
function tsip_transac_nist_Trying_2_Completed_X_send_200_to_699(ao_args){
	var o_transac = ao_args[0];
    var o_response = ao_args[1];
	var i_ret;

	i_ret = o_transac.send(this.s_branch, o_response) > 0 ? 0 : -1;

	/*	RFC 3261 - 17.2.2
		When the server transaction enters the "Completed" state, it MUST set
		Timer J to fire in 64*T1 seconds for unreliable transports, and zero
		seconds for reliable transports.
	*/
    o_transac.timer_schedule('nist', 'J');

	/* Update last response */
	o_transac.o_lastResponse = o_response;

	return i_ret;
}

/*	Proceeding --> (1xx) --> Proceeding
*/
function tsip_transac_nist_Proceeding_2_Proceeding_X_send_1xx(ao_args){
	var o_transac = ao_args[0];
    var o_response = ao_args[1];

    /* Update last response */
	o_transac.o_lastResponse = o_response;

	/*	RFC 3261 - 17.2.2
		Any further provisional responses that are
		received from the TU while in the "Proceeding" state MUST be passed
		to the transport layer for transmission.
	*/
	return o_transac.send(this.s_branch, o_response) > 0 ? 0 : -1;
}

/* Proceeding -> (INCOMING REQUEST) -> Proceeding
*/
function tsip_transac_nist_Proceeding_2_Proceeding_X_request(ao_args){
	var o_transac = ao_args[0];

	/*	RFC 3261 - 17.2.2
		If a retransmission of the request is received while in the "Proceeding" state, the most
		recently sent provisional response MUST be passed to the transport
		layer for retransmission.
	*/
	if(o_transac.o_lastResponse){
		o_transac.send(this.s_branch, o_transac.o_lastResponse);
	}

	return 0;
}

/*	Proceeding --> (200-699) --> Completed
*/
function tsip_transac_nist_Proceeding_2_Completed_X_send_200_to_699(ao_args){
	var o_transac = ao_args[0];
    var o_response = ao_args[1];
	var i_ret;

	/*	RFC 3261 - 17.2.2
		If the TU passes a final response (status
		codes 200-699) to the server while in the "Proceeding" state, the
		transaction MUST enter the "Completed" state, and the response MUST
		be passed to the transport layer for transmission.
	*/
	i_ret = o_transac.send(this.s_branch, o_response) > 0 ? 0 : -1;

	/*	RFC 3261 - 17.2.2
		When the server transaction enters the "Completed" state, it MUST set
		Timer J to fire in 64*T1 seconds for unreliable transports, and zero
		seconds for reliable transports.
	*/
	o_transac.timer_schedule('nist', 'J');

	/* Update last response */
	o_transac.o_lastResponse = o_response;

	return i_ret;
}

/* Completed --> (INCOMING REQUEST) --> Completed
*/
function tsip_transac_nist_Completed_2_Completed_X_request(ao_args){
	var o_transac = ao_args[0];

	/*	RFC 3261 - 17.2.2
		While in the "Completed" state, the server transaction MUST pass the final response to the transport
		layer for retransmission whenever a retransmission of the request is received.
	*/
	if(o_transac.o_lastResponse){
		o_transac.send(this.s_branch, o_transac.o_lastResponse);
	}

	return 0;
}

/* Complete --> (Timer J) --> Terminated
*/
function tsip_transac_nist_Completed_2_Terminated_X_tirmerJ(ao_args){
	/*	RFC 3261 - 17.2.2
		The server transaction remains in this state (Completed) until Timer J fires, at
	    which pofunction it MUST transition to the "Terminated" state.
	*/

	/*	RFC 3261 - 17.2.2
		THE SERVER TRANSACTION MUST BE DESTROYED THE INSTANT IT ENTERS THE "TERMINATED" STATE.
	*/
	return 0;
}

/* Any -> (Transport Error) -> Terminated
*/
function tsip_transac_nist_Any_2_Terminated_X_transportError(ao_args){
	var o_transac = ao_args[0];

	/* Timers will be canceled by "tsip_transac_nist_OnTerminated" */

	return o_transac.get_dialog().callback(tsip_dialog_event_type_e.TRANSPORT_ERROR, null);
}

/* Any -> (Error) -> Terminated
*/
function tsip_transac_nist_Any_2_Terminated_X_Error(ao_args){
	var o_transac = ao_args[0];

	/* Timers will be canceled by "tsip_transac_nist_OnTerminated" */

	return o_transac.get_dialog().callback(tsip_dialog_event_type_e.ERROR, null);
}

/* Any -> (cancel) -> Terminated
*/
function tsip_transac_nist_Any_2_Terminated_X_cancel(ao_args){
	/* doubango-specific */
	return 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//				== STATE MACHINE END ==
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function __tsip_transac_nist_onterm(o_self) {
    o_self.timer_cancel('J');

    return o_self.deinit();
}

function __tsip_transac_nist_event_callback(o_self, e_event_type, o_message) {
	var i_ret = -1;

	switch(e_event_type){
	    case tsip_transac_event_type_e.INCOMING_MSG: /* From Transport Layer to Transaction Layer */
		    {
			    if(o_message && o_message.is_request()){
                     i_ret = o_self.fsm_act(tsip_transac_nist_actions_e.RECV_REQUEST, o_message);
			    }
			    break;
		    }

	    case tsip_transac_event_type_e.OUTGOING_MSG: /* From TU to Transport Layer */
		    {
			    if(o_message && o_message.is_response()){
				    if(o_message.is_1xx()){
                        i_ret = o_self.fsm_act(tsip_transac_nist_actions_e.SEND_1XX, o_message);
				    }
				    else if(o_message.is_23456()){
                        i_ret = o_self.fsm_act(tsip_transac_nist_actions_e.SEND_200_to_699, o_message);
				    }
			    }
			    break;
		    }

	    case tsip_transac_event_type_e.CANCELED:
	    case tsip_transac_event_type_e.TERMINATED:
	    case tsip_transac_event_type_e.TIMEDOUT:
		    break;

	    case tsip_transac_event_type_e.ERROR:
		    {
			    i_ret = o_self.fsm_act(tsip_transac_nist_actions_e.ERROR, o_message);
			    break;
		    }

	    case tsip_transac_event_type_e.TRANSPORT_ERROR:
		    {
			    i_ret = o_self.fsm_act(tsip_transac_nist_actions_e.TRANSPORT_ERROR, o_message);
			    break;
		    }
	}

	return i_ret;
}

function __tsip_transac_nist_timer_callback(o_self, o_timer){
	if(o_self){
		if(o_timer == o_self.o_timerJ){
			o_self.fsm_act(tsip_transac_nist_actions_e.TIMER_J, null);
		}
	}
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
var tsip_transport_type_e = 
{
    WS: 0,
    WSS: 1,
    TCP: 2,
    TLS: 3,
    UDP: 4,
    SCTP: 5,
    DTLS: 6
};

var tsip_transport_event_type_e =
{
    STARTED: 0,
    STOPPED: 1,
    ERROR: 2
};

function tsip_transport(e_type, o_stack, s_host, i_port, s_description, fn_callback) {
    if(!o_stack){
        tsk_utils_log_error("Invalid argument");
        return null;
    }

    switch(e_type){
        case tsip_transport_type_e.WS:
            {
                this.b_reliable = true;
                this.s_scheme = "sip";
                this.s_protocol = "ws";
                this.s_via_protocol = "WS";
                this.s_service = "SIP+D2W";
                this.o_ws = null;
                this.__start = function () { return __tsip_transport_ws_start(this); };
                this.__stop = function () { return __tsip_transport_ws_stop(this); };
                this.__have_socket = function (o_socket) { return __tsip_transport_ws_have_socket(this, o_socket); }
                this.__send = function (o_data, i_length) { return __tsip_transport_ws_send(this, o_data, i_length); }
                break;
            }
        case tsip_transport_type_e.WSS:
            {
                this.b_reliable = true;
                this.s_scheme = "sip";
                this.s_protocol = "wss";
                this.s_via_protocol = "WSS";
                this.s_service = "SIP+D2W";
                this.o_ws = null;
                this.__start = function () { return __tsip_transport_ws_start(this); };
                this.__stop = function () { return __tsip_transport_ws_stop(this); };
                this.__have_socket = function (o_socket) { return __tsip_transport_ws_have_socket(this, o_socket); }
                this.__send = function (o_data, i_length) { return __tsip_transport_ws_send(this, o_data, i_length); }
                break;
            }

        case tsip_transport_type_e.UDP:
            {
                if(!tsk_utils_have_webrtc4all()){
                    tsk_utils_log_error("Transport not supported");
                    return null;
                }

                this.b_reliable = false;
                this.s_scheme = "sip";
                this.s_protocol = "udp";
                this.s_via_protocol = "UDP";
                this.s_service = "SIP+D2U";
                this.o_transport = null;
                this.__start = function () { return __tsip_transport_webrtc4all_start(this); };
                this.__stop = function () { return __tsip_transport_webrtc4all_stop(this); };
                this.__have_socket = function (o_socket) { return __tsip_transport_webrtc4all_have_socket(this, o_socket); }
                this.__send = function (o_data, i_length) { return __tsip_transport_webrtc4all_send(this, o_data, i_length); }
                break;
            }

        case tsip_transport_type_e.TCP:
        case tsip_transport_type_e.TLS:
        case tsip_transport_type_e.SCTP:
        case tsip_transport_type_e.DTLS:
        default:
            {
                tsk_utils_log_error(e_type + " not supported as a valid SIP transport");
                return null;
            }
    }
    
    this.e_type = e_type;
    this.o_stack = o_stack;
    this.s_host = s_host;
    this.i_port = i_port;
    this.s_description = s_description;
    this.fn_callback = fn_callback;
    this.b_started = false;

    return this;
}

tsip_transport.prototype.get_layer = function () {
    return this.o_stack.o_layer_transport;
}

tsip_transport.prototype.is_reliable = function(){
    return this.b_reliable;
}

tsip_transport.prototype.start = function() {
    if (this.b_started) {
        tsk_utils_log_warn("Already started");
        return 0;
    }

   return this.__start();
}

tsip_transport.prototype.stop = function () {
    if (!this.b_started) {
        tsk_utils_log_warn("Not started");
        return 0;
    }

    return this.__stop();
}

tsip_transport.prototype.get_local_ip = function(){
    if(this.e_type == tsip_transport_type_e.WS || this.e_type == tsip_transport_type_e.WSS){
        return "df7jal23ls0d.invalid";
    }
    else if(this.o_transport && this.o_transport.localIP){
        return this.o_transport.localIP;
    }
    tsk_utils_log_error("Not implemented");
    return "127.0.0.1";
}

tsip_transport.prototype.get_local_port = function(){
    if(this.e_type == tsip_transport_type_e.WS || this.e_type == tsip_transport_type_e.WSS){
        return -1;
    }
    else if(this.o_transport && this.o_transport.localPort){
        return this.o_transport.localPort;
    }
    tsk_utils_log_error("Not implemented");
    return 5060;
}

tsip_transport.prototype.get_uri = function(b_lr){	
	var b_ipv6 = false;
	var s_uristring = tsk_string_format("{0}:{1}{2}{3}:{4};{5};transport={6}",
		this.s_scheme,
		b_ipv6 ? "[" : "",
		this.o_stack.network.aor.s_ip,
		b_ipv6 ? "]" : "",
		this.o_stack.network.aor.i_port,
		b_lr ? "lr" : "",
		this.s_protocol);
	    
    var o_uri = tsip_uri.prototype.Parse(s_uristring);
    if(o_uri){
        o_uri.e_host_type = b_ipv6 ? tsip_host_type_e.ipv6 : tsip_host_type_e.ipv4;
    }
	return o_uri;
}

tsip_transport.prototype.have_socket = function (o_socket) {
    return this.__have_socket(o_socket);
}

tsip_transport.prototype.send = function (s_branch, o_message, s_dest_ip, i_dest_port) {
    var o_data = null;

    /* Add Via and update AOR, IPSec headers, SigComp ...
    * ACK sent from the transaction layer will contains a Via header and should not be updated 
    * CANCEL will have the same Via and Contact headers as the request it cancel */
    if (o_message.is_request() && (!o_message.is_ack() || (o_message.is_ack() && !o_message.o_hdr_firstVia)) && !o_message.is_cancel()) {
        this.message_addvia(s_branch, o_message); /* should be done before tsip_transport_o_message_update() which could use the Via header */
        this.message_update_aor(o_message); /* AoR */
        this.message_update(o_message); /* IPSec, SigComp, ... */
    }
    else if (o_message.is_response()) {
        /* AoR for responses which have a contact header (e.g. 183/200 INVITE) */
        if (o_message.o_hdr_Contact) {
            this.message_update_aor(o_message);
        }
        /*	RFC 3581 - 4.  Server Behavior
        When a server compliant to this specification (which can be a proxy
        or UAS) receives a request, it examines the topmost Via header field
        value.  If this Via header field value contains an "rport" parameter
        with no value, it MUST set the value of the parameter to the source
        port of the request.
        */
        if (o_message.o_hdr_firstVia.i_rport == 0) {
            /* As the response message has been built from the request ...then it's first via is the same as
            the request's first via.
            */
            o_message.o_hdr_firstVia.i_rport = o_message.o_hdr_firstVia.i_port;
        }
    }

    o_data = o_message.toString();

    tsk_utils_log_info("SEND: " + o_data);

    //if (o_data.length > 1300) {
        /*	RFC 3261 - 18.1.1 Sending Requests (FIXME)
        If a request is within 200 bytes of the path MTU, or if it is larger
        than 1300 bytes and the path MTU is unknown, the request MUST be sent
        using an RFC 2914 [43] congestion controlled transport protocol, such
        as TCP. If this causes a change in the transport protocol from the
        one indicated in the top Via, the value in the top Via MUST be
        changed.  This prevents fragmentation of messages over UDP and
        provides congestion control for larger messages.  However,
        implementations MUST be able to handle messages up to the maximum
        datagram packet size.  For UDP, this size is 65,535 bytes, including
        IP and UDP headers.
        */
    //}

    return this.__send(o_data, o_data.length);
}

function tsip_transport_event(o_transport, e_type, s_description, o_data) {
    this.o_transport = o_transport;
    this.e_type = e_type;
    this.s_description = s_description;
    this.o_data = o_data;
    return this;
}

tsip_transport.prototype.signal = function (e_type, s_description, o_data) {
    if (this.fn_callback) {
        var fn_callback = this.fn_callback;
        var o_event = new tsip_transport_event(this, e_type, s_description, o_data);
        setTimeout(function () { fn_callback(o_event) }, 1);
    }
    return 0;
}

tsip_transport.prototype.message_addvia = function(s_branch, o_message){	
	/* is there a Via header? */
	if(!o_message.o_hdr_firstVia){
		/*	RFC 3261 - 18.1.1 Sending Requests
			Before a request is sent, the client transport MUST insert a value of
			the "sent-by" field into the Via header field.  This field contains
			an IP address or host name, and port.  The usage of an FQDN is
			RECOMMENDED.  This field is used for sending responses under certain
			conditions, described below.  If the port is absent, the default
			value depends on the transport.  It is 5060 for UDP, TCP and SCTP,
			5061 for TLS.
		*/
        // FIXME:
		o_message.o_hdr_firstVia = new tsip_header_Via(tsip_header_Via.prototype.__s_proto_name_default, tsip_header_Via.prototype.__s_proto_version_default,
			this.s_via_protocol, this.get_local_ip(), this.get_local_port());
		
        o_message.o_hdr_firstVia.add_param("rport", null);
	}
	
	/* updates the branch */
	if(s_branch){
        o_message.o_hdr_firstVia.s_branch = s_branch;
	}
	else{ /* Probably ACK sent from Dialog Layer */
        o_message.o_hdr_firstVia.s_branch = tsk_string_format("{0}{1}", tsip_transac.prototype.__magic_cookie, tsk_string_random(20));
	}

	/* multicast case */
	//if(false){
		/*	RFC 3261 - 18.1.1 Sending Requests (FIXME)
			A client that sends a request to a multicast address MUST add the
			"maddr" parameter to its Via header field value containing the
			destination multicast address, and for IPv4, SHOULD add the "ttl"
			parameter with a value of 1.  Usage of IPv6 multicast is not defined
			in this specification, and will be a subject of future
			standardization when the need arises.
		*/
	//}

	return 0;
}

tsip_transport.prototype.message_update_aor = function(o_message){
	/* already updtated (e.g. retrans)? */
	if(!o_message.b_update){
		return 0;
	}
	
	/* retrieves the transport ip address and port */
	if(!this.o_stack.network.aor.s_ip && !this.o_stack.network.aor.i_port){
		this.o_stack.network.aor.s_ip = this.get_local_ip();
        this.o_stack.network.aor.i_port = this.get_local_port();
	}

	/* === Host and port === */
	if(o_message.o_hdr_Contact && o_message.o_hdr_Contact.o_uri){
        o_message.o_hdr_Contact.o_uri.s_scheme = this.s_scheme;
        o_message.o_hdr_Contact.o_uri.s_host = this.o_stack.network.aor.s_ip;
        o_message.o_hdr_Contact.o_uri.i_port = this.o_stack.network.aor.i_port;
		tsk_params_add(o_message.o_hdr_Contact.o_uri.ao_params, "transport", this.s_protocol);
	}

	return 0;
}

tsip_transport.prototype.message_update = function(o_message){
	/* already updtated (e.g. retrans)? */
	if(!o_message.b_update){
		return 0;
	}

	/* === SigComp === */
	if(o_message.s_sigcomp_id){
		/* Via */
		if(o_message.o_hdr_firstVia){
            o_message.o_hdr_firstVia.add_param("comp", "sigcomp");
            o_message.o_hdr_firstVia.add_param("sigcomp-id", tsk_string_format("\"{0}\"", o_message.s_sigcomp_id));
		}
		/* Contact */
		if(o_message.o_hdr_Contact && o_message.o_hdr_Contact.o_uri){
		    tsk_params_add(o_message.o_hdr_Contact.o_uri.ao_params, "sigcomp-id", o_message.sigcomp_id);
		}
	}

	o_message.b_update = false; /* To avoid to update retrans. */
	
	return 0;
}



















/******************** WebSocket *******************/
function __tsip_transport_ws_start(o_self) {
    if (!o_self) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    var s_url = tsk_string_is_null_or_empty(o_self.o_stack.network.s_websocket_server_url) ?
             tsk_string_format("{0}://{1}:{2}",o_self.s_protocol, o_self.s_host, o_self.i_port) : o_self.o_stack.network.s_websocket_server_url;
    tsk_utils_log_info("Connecting to '"+s_url+"'");
    o_self.o_ws = new WebSocket(s_url, 'sip');
    o_self.o_ws.binaryType = "arraybuffer";
    o_self.o_ws.o_transport = o_self;
    o_self.o_ws.onopen = __tsip_transport_ws_onopen;
    o_self.o_ws.onclose = __tsip_transport_ws_onclose;
    o_self.o_ws.onmessage = __tsip_transport_ws_onmessage;
    o_self.o_ws.onerror = __tsip_transport_ws_onerror;

    return 0;
}

function __tsip_transport_ws_stop(o_self) {
    if (!o_self) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    if (o_self.o_ws) {
        o_self.o_ws.close();
    }

    return 0;
}

function __tsip_transport_ws_have_socket(o_self, o_socket) {
    return o_self.o_ws == o_socket;
}

function __tsip_transport_ws_send(o_self, o_data, i_length) {

    if (!o_self.o_ws) {
        tsk_utils_log_error("Invalid state");
        return 0;
    }

    o_self.o_ws.send(o_data);
    return i_length;
}

function __tsip_transport_ws_onopen(evt) {
    tsk_utils_log_info("__tsip_transport_ws_onopen");
    this.o_transport.b_started = true;
    this.o_transport.signal(tsip_transport_event_type_e.STARTED, evt.reason, null);
}

function __tsip_transport_ws_onclose(evt) {
    tsk_utils_log_info("__tsip_transport_ws_onclose");
    this.o_transport.b_started = false;
    this.o_transport.signal(tsip_transport_event_type_e.STOPPED, evt.reason, null);
}

function __tsip_transport_ws_onmessage(evt) {
    tsk_utils_log_info("__tsip_transport_ws_onmessage");

    var o_ragel_state = tsk_ragel_state_create();
    if(typeof(evt.data) == 'string'){
        tsk_ragel_state_init_str(o_ragel_state, evt.data);
    }
    else{
        tsk_ragel_state_init_ai(o_ragel_state, evt.data);
    }
    var o_message = tsip_message.prototype.Parse(o_ragel_state, true);

    if (o_message) {
        tsk_utils_log_info("recv=" + o_message);
        o_message.o_socket = this;
        return this.o_transport.get_layer().handle_incoming_message(o_message);
    }
    else {
        tsk_utils_log_error("Failed to parse message: " + evt.data);
        return -1;
    }
}

function __tsip_transport_ws_onerror(evt) {
    tsk_utils_log_info("__tsip_transport_ws_onerror");
    this.o_transport.signal(tsip_transport_event_type_e.ERROR, evt.reason, null);
}


/******************** webrtc4all *******************/
function __tsip_transport_webrtc4all_start(o_self) {
    if (!o_self) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    var b_isInternetExplorer = (WebRtc4all_GetType() == WebRtcType_e.IE);
    var s_url = tsk_string_is_null_or_empty(o_self.o_stack.network.s_proxy_outbound_host) ?
             tsk_string_format("{0}://{1}:{2}", o_self.s_protocol, o_self.s_host, o_self.i_port) : 
             tsk_string_format("{0}://{1}:{2}", o_self.s_protocol, o_self.o_stack.network.s_proxy_outbound_host, o_self.o_stack.network.i_proxy_outbound_port);
    
    tsk_utils_log_info("Connecting to '" + s_url+"'");
    if(b_isInternetExplorer){
        o_self.o_transport = new ActiveXObject("webrtc4ie.NetTransport");
        eval("function o_self.o_transport::OnEvent(i_type, s_data) { return __tsip_transport_webrtc4all_onevent (o_self, i_type, s_data); }");
    }
    else{
        o_self.o_transport = WebRtc4npapi.createNetTransport();
        o_self.o_transport.opaque = o_self;
        o_self.o_transport.setCallbackFuncName("__tsip_transport_webrtc4all_onevent");
    }
    
    try{
        // if sip outbound proxy is defined then, use it otherwise perform DNS NAPTR+SRV ("SIP+D2U")
        if(o_self.o_stack.network.s_proxy_outbound_host && o_self.o_stack.network.i_proxy_outbound_port){
            o_self.s_host = o_self.o_stack.network.s_proxy_outbound_host;
            o_self.i_port = o_self.o_stack.network.i_proxy_outbound_port;
        }
        else{
            o_self.o_transport.SetDomain(o_self.o_stack.network.o_uri_realm.s_host); // DNS NAPTR+SRV ("SIP+D2U")
        }

        // IMPORTANT: StartDebug is not implemented in all functions
        //if(o_self.o_transport.StartDebug){
            //o_self.o_transport.StartDebug(); // To debug ATL/COM objects (C/C++)
        //}
        o_self.o_transport.Start(b_isInternetExplorer ? WebRtc4all_GetLooper() : 0);
        if(o_self.o_transport.defaultDestAddr && o_self.o_transport.defaultDestPort){ // use connection info from DNS results
            o_self.s_host = o_self.o_transport.defaultDestAddr;
            o_self.i_port = o_self.o_transport.defaultDestPort;
            tsk_utils_log_info("Transport default destination=" + o_self.s_host + ":" + o_self.i_port);
        }
        o_self.b_started = true;
        o_self.signal(tsip_transport_event_type_e.STARTED, "Network transport started", null);
    }
    catch(e){
        tsk_utils_log_error(e);
        return -1;
    }

    return 0;
}

function __tsip_transport_webrtc4all_stop(o_self) {
    if (!o_self) {
        tsk_utils_log_error("Invalid argument");
        return -1;
    }

    if (o_self.o_transport) {
        o_self.o_transport.Stop();
    }

    return 0;
}

function __tsip_transport_webrtc4all_have_socket(o_self, o_socket) {
    return o_self.o_transport == o_socket;
}

function __tsip_transport_webrtc4all_send(o_self, o_data, i_length) {

    if (!o_self.o_transport) {
        tsk_utils_log_error("Invalid state");
        return 0;
    }
    
    o_self.o_transport.SendTo(o_data, o_self.s_host, o_self.i_port);
    return i_length;
}

function __tsip_transport_webrtc4all_onevent(o_self, i_type, s_data) {
    tsk_utils_log_info("__tsip_transport_webrtc4all_onevent");
    if(s_data){
        var o_ragel_state = tsk_ragel_state_create();
        tsk_ragel_state_init_str(o_ragel_state, s_data);

        var o_message = tsip_message.prototype.Parse(o_ragel_state, true);
        if (o_message) {
            tsk_utils_log_info("RECV=" + o_message.toString());
            o_message.o_socket = o_self.o_transport;
            return o_self.get_layer().handle_incoming_message(o_message);
        }
        else {
            tsk_utils_log_error("Failed to parse message: " + evt.data);
            return -1;
        }
    }
}

/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/
function tsip_transport_layer(o_stack) {
    if (!o_stack) {
        tsk_utils_log_error("Invalid argument");
        return null;
    }

    this.o_stack = o_stack;
    this.b_running = false;
    this.ao_transports = new Array();
}

function tsip_transport_layer_find_result(){
    this.o_transport = null;
    this.s_dest_ip = null;
    this.i_dest_port = 0;
}

tsip_transport_layer.prototype.get_layer_transac = function () {
    if (this.o_stack) {
        return this.o_stack.o_layer_transac;
    }
    return null;
}

tsip_transport_layer.prototype.get_layer_dialog = function () {
    if (this.o_stack) {
        return this.o_stack.o_layer_dialog;
    }
    return null;
}

tsip_transport_layer.prototype.stop = function () {
    while (this.b_locked){}

    this.b_locked = true;

    for (var i = 0; i < this.ao_transports.length; ++i) {
        this.ao_transports[i].stop();
    }

    this.b_locked = false;

    return 0;
}

tsip_transport_layer.prototype.send = function (s_branch, o_message) {
    var o_result = this.transport_find(o_message);
    if (!o_result || !o_result.o_transport) {
        tsk_utils_log_error("Failed to find transport");
        return 0;
    }

    return o_result.o_transport.send(s_branch, o_message, o_result.s_dest_ip, o_result.i_dest_port);
}

tsip_transport_layer.prototype.transport_new = function (e_type, s_host, i_port, s_description, fn_callback) {
    var o_transport = null;
    while (this.b_locked){}

    this.b_locked = true;
    o_transport = new tsip_transport(e_type, this.o_stack, s_host, i_port, s_description, fn_callback);
    if (o_transport) {
        this.ao_transports.push(o_transport);
    }
    this.b_locked = false;
    return o_transport;
}

tsip_transport_layer.prototype.transport_remove = function (o_transport) {
    if (o_transport) {
        while (this.b_locked){}

        this.b_locked = true;
        for (var i = 0; i < this.ao_transports.length; ++i) {
            if (this.ao_transports[i] == o_transport) {
                this.ao_transports.splice(i, 1);
                break;
            }
        }
        this.b_locked = false;
    }
}

tsip_transport_layer.prototype.transport_find = function (o_message) {
    if(!o_message){
        tsk_utils_log_error("Invalid argument");
        return null;
    }
    var o_ret = new tsip_transport_layer_find_result();

	o_ret.s_dest_ip = this.o_stack.network.s_proxy_cscf_host;
	o_ret.i_dest_port = this.o_stack.network.i_proxy_cscf_port;

	/* =========== Sending Request ========= */
	if(o_message.is_request()){
		/* Request are always sent to the Proxy-CSCF */
		for(var i = 0; i < this.ao_transports.length; ++i){
			if(this.ao_transports[i].e_type == this.o_stack.network.e_proxy_cscf_type){
				o_ret.o_transport = this.ao_transports[i];
				break;
			}
		}
	}



	/* =========== Sending Response =========
	*
	*/
	else if(o_message.o_hdr_firstVia){
		if(o_message.o_hdr_firstVia.is_transport_reliable()) /*== RELIABLE ===*/
		{
			/*	RFC 3261 - 18.2.2 Sending Responses
				If the "sent-protocol" is a reliable transport protocol such as
				TCP or SCTP, or TLS over those, the response MUST be sent using
				the existing connection to the source of the original request
				that created the transaction, if that connection is still open.
				This requires the server transport to maintain an association
				between server transactions and transport connections.  If that
				connection is no longer open, the server SHOULD open a
				connection to the IP address in the "received" parameter, if
				present, using the port in the "sent-by" value, or the default
				port for that transport, if no port is specified.  If that
				connection attempt fails, the server SHOULD use the procedures
				in [4] for servers in order to determine the IP address and
				port to open the connection and send the response to.
			*/
		}
		else
		{
			if(o_message.o_hdr_firstVia.s_maddr) /*== UNRELIABLE MULTICAST ===*/
			{	
				/*	RFC 3261 - 18.2.2 Sending Responses 
					Otherwise, if the Via header field value contains a "maddr" parameter, the 
					response MUST be forwarded to the address listed there, using 
					the port indicated in "sent-by", or port 5060 if none is present.  
					If the address is a multicast address, the response SHOULD be 
					sent using the TTL indicated in the "ttl" parameter, or with a 
					TTL of 1 if that parameter is not present.
				*/
			}
			else	/*=== UNRELIABLE UNICAST ===*/
			{
				if(o_message.o_hdr_firstVia.s_received)
				{
					if(o_message.o_hdr_firstVia.i_rport > 0)
					{
						/*	RFC 3581 - 4.  Server Behavior
							When a server attempts to send a response, it examines the topmost
							Via header field value of that response.  If the "sent-protocol"
							component indicates an unreliable unicast transport protocol, such as
							UDP, and there is no "maddr" parameter, but there is both a
							"received" parameter and an "rport" parameter, the response MUST be
							sent to the IP address listed in the "received" parameter, and the
							port in the "rport" parameter.  The response MUST be sent from the
							same address and port that the corresponding request was received on.
							This effectively adds a new processing step between bullets two and
							three in Section 18.2.2 of SIP [1].
						*/
						o_ret.s_dest_ip = o_message.o_hdr_firstVia.s_received;
						o_ret.i_dest_port = o_message.o_hdr_firstVia.i_rport;
					}
					else
					{
						/*	RFC 3261 - 18.2.2 Sending Responses
							Otherwise (for unreliable unicast transports), if the top Via
							has a "received" parameter, the response MUST be sent to the
							address in the "received" parameter, using the port indicated
							in the "sent-by" value, or using port 5060 if none is specified
							explicitly.  If this fails, for example, elicits an ICMP "port
							unreachable" response, the procedures of Section 5 of [4]
							SHOULD be used to determine where to send the response.
						*/
						o_ret.s_dest_ip = o_message.o_hdr_firstVia.s_received;
						o_ret.i_dest_port = o_message.o_hdr_firstVia.i_port ? o_message.o_hdr_firstVia.i_port : 5060;
					}
				}
				else if(!o_message.o_hdr_firstVia.s_received)
				{
					/*	RFC 3261 - 18.2.2 Sending Responses
						Otherwise, if it is not receiver-tagged, the response MUST be
						sent to the address indicated by the "sent-by" value, using the
						procedures in Section 5 of [4].
					*/
					o_ret.s_dest_ip = o_message.o_hdr_firstVia.s_host;
					if(o_message.o_hdr_firstVia.i_port > 0)
					{
						o_ret.i_dest_port = o_message.o_hdr_firstVia.i_port;
					}
				}
			}
		}
		
        /* Find the transport */
        while(this.b_locked){}
        this.b_locked = true;
		for(i = 0; i < this.ao_transports.length; ++i){
			 if(this.ao_transports[i].have_socket(o_message.o_socket)){
				o_ret.o_transport = this.ao_transports[i];
				break;
			}
		}
        this.b_locked = false;
	}

    return o_ret;
}

tsip_transport_layer.prototype.handle_incoming_message = function (o_message) {
    if (o_message) {
        var o_layer_transac = this.get_layer_transac();
        if (!o_layer_transac) {
            tsk_utils_log_error("Invalid transaction layer");
            return -1;
        }
        var i_ret;

        if ((i_ret = o_layer_transac.handle_incoming_message(o_message)) != 0) {
            o_layer_dialog = this.get_layer_dialog();
            if (!o_layer_dialog) {
                tsk_utils_log_error("Invalid dialog layer");
                return -1;
            }

            /* NO MATCHING TRANSACTION FOUND ==> LOOK INTO DIALOG LAYER */
            i_ret = o_layer_dialog.handle_incoming_message(o_message);
        }
        return i_ret;
    }
    return 0;
}
/*
* Copyright (C) 2012 Doubango Telecom <http://www.doubango.org>
* License: BSD
* This file is part of Open Source sipML5 solution <http://www.sipml5.org>
*/

/**
@fileoverview This is SIPML5 "library" contains a  lot of classes and functions.

@name sipML5 API
@author      Doubango Telecom <http://www.doubango.org>
@version     1.3.203
*/

/** 
@namespace
@description Root namesapce.
*/
SIPml = {};

/** @private */SIPml.b_initialized = false;
/** @private */SIPml.b_initializing = false;
/** @private */SIPml.s_navigator_friendly_name = 'unknown';
/** @private */SIPml.b_navigator_outdated = false;
/** @private */SIPml.s_navigator_version = 'unknown';
/** @private */SIPml.s_system_friendly_name = 'unknown';
/** @private */SIPml.b_webrtc4all_plugin_outdated = false;
/** @private */SIPml.b_webrtc4all_supported = false;
/** @private */SIPml.s_webrtc4all_version = 'unknown';
/** @private */SIPml.b_have_media_stream = false;
/** @private */SIPml.b_webrtc_supported = false;


/**
Sets the debug level.
@since version 1.3.203
@param {String} level The level. Supported values: <i>info</i>, <i>warn</i>, <i>error</i> and <i>fatal</i>.
*/
SIPml.setDebugLevel = function(level) {
    tsk_utils_log_set_level(level === 'fatal' ? 1 : (level === 'error' ? 2 : (level === 'warn' ? 3 : 4)));
}

/**
Sets the default webrtc type. Must be called before <a href="#.init">initializing</a> the engine.
@since version 1.4.217
@param {String} type The type. Supported values: <i>native</i>, <i>w4a</i> and <i>erisson</i>.
@returns {Boolean} <i>true</i> if succeed; otherwise <i>false</i>
*/
SIPml.setWebRtcType = function(type) {
    if(SIPml.isInitialized()){
        throw new Error("ERR_ALREADY_INITIALIZED: Engine already initialized.");
    }
    return WebRtc4all_SetType(type);
}

/**
Gets the version name of the installed <a href="http://code.google.com/p/webrtc4all/">webrtc4all plugin</a>.
You must <a href="#.init">initialize</a> the engine before calling this function.
@static
@returns {String} Version name (e.g. '1.12.756')
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.getWebRtc4AllVersion = function() {
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return SIPml.s_webrtc4all_version;
};

/**
Gets the web browser version (e.g. <i>'1.5.beta'</i>).
You must <a href="#.init">initialize</a> the engine before calling this function.
@static
@returns {String} The the web browser version.
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.getNavigatorVersion = function() {
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return SIPml.s_navigator_version; 
};

/**
Gets the web browser friendly name (e.g. <i>'chrome'</i>, <i>'firefox'</i>, <i>'safari'</i>, <i>'opera'</i>, <i>'ie'</i> or <i>'netscape'</i>).
You must <a href="#.init">initialize</a> the engine before calling this function.
@static
@returns {String} The web browser friendly name.
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.getNavigatorFriendlyName = function() {
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return SIPml.s_navigator_friendly_name; 
};

/**
Gets the Operating System friendly name (e.g. <i>'windows'</i>, <i>'mac'</i>, <i>'lunix'</i>, <i>'solaris'</i>, <i>'sunos'</i> or <i>'powerpc'</i>).
You must <a href="#.init">initialize</a> the engine before calling this function.
@static
@returns {String} The Operating System friendly name.
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.getSystemFriendlyName = function() {
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return SIPml.s_system_friendly_name; 
};

/**
Checks whether the web browser supports WebRTC but is outdated.
You must <a href="#.init">initialize</a> the engine before calling this function.
@static
@returns {Boolean} <i>true</i> if outdated; otherwise <i>false</i>
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.isNavigatorOutdated= function () {
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return SIPml.b_navigator_outdated; 
}

/**
Checks whether the <a href="http://code.google.com/p/webrtc4all/">webrtc4all plugin</a> is outdated or not.
You must <a href="#.init">initialize</a> the engine before calling this function.
@static
@returns {Boolean} <i>true</i> if outdated; otherwise <i>false</i>
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.isWebRtc4AllPluginOutdated = function(){
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return SIPml.b_webrtc4all_plugin_outdated; 
}

/**
Checks whether the <a href="http://code.google.com/p/webrtc4all/">webrtc4all plugin</a> is installed or not.
You must <a href="#.init">initialize</a> the engine before calling this function.
@static
@returns {Boolean} <i>true</i> if supported; otherwise <i>false</i>
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.isWebRtc4AllSupported = function(){
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return SIPml.b_webrtc4all_supported; 
}

/**
Checks whether Screen share is supported on this browser.
You must <a href="#.init">initialize</a> the engine before calling this function.
@since version 1.3.203
@static
@returns {Boolean} <i>true</i> if supported; otherwise <i>false</i>
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.isScreenShareSupported = function () {
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return (navigator.userAgent.match('Chrome') && parseInt(navigator.userAgent.match(/Chrome\/(.*) /)[1]) >= 26);
}

/**
Checks whether WebRTC is supported or not.
You must <a href="#.init">initialize</a> the engine before calling this function.
@static
@returns {Boolean} <i>true</i> if supported; otherwise <i>false</i>
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.isWebRtcSupported = function () {
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return SIPml.b_webrtc_supported; 
}

/**
Checks whether WebSocket is supported or not.
@static
@returns {Boolean} <i>true</i> if supported; otherwise <i>false</i>
*/
SIPml.isWebSocketSupported = function () {
    return tsk_utils_have_websocket(); 
}

/**
Checks whether <a href="https://developer.mozilla.org/en-US/docs/WebRTC/navigator.getUserMedia">getUserMedia</a> is supported or not. The engined must be initialized before calling this function.
@static
@returns {Boolean} <i>true</i> if <a href="https://developer.mozilla.org/en-US/docs/WebRTC/navigator.getUserMedia">getUserMedia</a> is supported; otherwise <i>false</i>
*/
SIPml.haveMediaStream = function () {
    if(!SIPml.isInitialized()){
        throw new Error("ERR_NOT_INITIALIZED: Engine not initialized yet. Please call 'SIPml.init()' first");
    }
    return SIPml.b_have_media_stream;
}

/**
Checks whether the engine is ready to make/receive calls or not. <br />
The engine is ready when:
    <ul>
        <li>engine is <a href="#.init">initialized</a></li>
        <li>webrtc is supported</li>
        <li>we got a valid media stream (from <a href="https://developer.mozilla.org/en-US/docs/WebRTC/navigator.getUserMedia">getUserMedia</a>)</li>
    </ul>
@static
@returns {Boolean} <i>true</i> if the engine is ready; otherwise <i>false</i>
@throws {ERR_NOT_INITIALIZED} <font color="red">ERR_NOT_INITIALIZED</font> if the engine is not <a href="#.init">initialized</a>.
*/
SIPml.isReady = function () {
    return (SIPml.isInitialized() && SIPml.isWebRtcSupported() && SIPml.haveMediaStream()); 
}

/**
Checks whether the engine is initialized or not. To initialize the stack you must call <a href="#.init">init()</a> function.
@static
@returns {Boolean} <i>true</i> if the engine is initialized; otherwise <i>false</i>
*/
SIPml.isInitialized = function () { return SIPml.b_initialized; }


/**
Initialize the engine. <b>You must call this function before any other.</b>.
@param {CallbackFunction} [readyCallback] Optional callback function to call when the stack finish initializing and become ready.
@param {CallbackFunction} [errorCallback] Optional callback function to call when initialization fails.

@example
SIPml.init(function(e){ console.info('engine is ready'); }, function(e){ console.info('Error: ' + e.message); });
@static
*/
SIPml.init = function (successCallback, errorCallback) {
    if (!SIPml.b_initialized && !SIPml.b_initializing) {
        SIPml.b_initializing = true;
        tsk_utils_init_webrtc();

        tsk_utils_log_info('User-Agent=' + (navigator.userAgent || "unknown"));

        SIPml.b_have_media_stream = tsk_utils_have_stream();
        SIPml.b_webrtc_supported = tsk_utils_have_webrtc();
        SIPml.b_webrtc4all_supported = tsk_utils_have_webrtc4all();
        SIPml.s_webrtc4all_version = tsk_utils_webrtc4all_get_version();
        SIPml.s_navigator_friendly_name = tsk_utils_get_navigator_friendly_name();
        SIPml.s_system_friendly_name = tsk_utils_get_system_friendly_name();

        // prints whether WebSocket is supported
        tsk_utils_log_info("WebSocket supported = " + (SIPml.isWebSocketSupported() ? "yes" : "no"));

        // check webrtc4all version
        if (tsk_utils_have_webrtc4all()) {
            tsk_utils_log_info("WebRTC type = " + WebRtc4all_GetType() + " version = " + tsk_utils_webrtc4all_get_version());
            if (SIPml.s_webrtc4all_version != '1.35.981') {
                SIPml.b_webrtc4all_plugin_outdated = true;
            }
        }

        // prints navigator friendly name
        tsk_utils_log_info("Navigator friendly name = " + SIPml.s_navigator_friendly_name);

        // gets navigator version
        if(SIPml.s_navigator_friendly_name == 'ie'){
            var re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
            if (re.exec(navigator.userAgent) != null) {
                SIPml.s_navigator_version = RegExp.$1;
            }
        }        

        // prints OS friendly name
        tsk_utils_log_info("OS friendly name = " + SIPml.s_system_friendly_name);
        // prints support for WebRTC (native or plugin)
        tsk_utils_log_info("Have WebRTC = " + (tsk_utils_have_webrtc() ? "yes" : "false"));
        // prints support for getUserMedia
        tsk_utils_log_info("Have GUM = " + (tsk_utils_have_stream() ? "yes" : "false"));

        // checks for WebRTC support
        if (!tsk_utils_have_webrtc()) {
            // is it chrome?
            if (SIPml.s_navigator_friendly_name == "chrome") {
                SIPml.b_navigator_outdated = true;
                return;
            }

            // for now the plugins (WebRTC4all only works on Windows)
            if (SIPml.s_system_friendly_name == 'win' || SIPml.s_system_friendly_name == 'windows') {
                // Internet explorer
                if (SIPml.s_navigator_friendly_name == 'ie') {
                    // Check for IE version 
                    var rv = -1;
                    var ua = navigator.userAgent;
                    var re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                    if (re.exec(ua) != null) {
                        rv = parseFloat(RegExp.$1);
                    }
                    if (rv < 9.0) {
                        SIPml.b_navigator_outdated = true;
                        return;
                    }

                    // break page loading ('window.location' won't stop JS execution)
                    if (!tsk_utils_have_webrtc4all()) {
                        return;
                    }
                }
            }
        }

        if(SIPml.b_webrtc_supported && SIPml.b_have_media_stream){
            SIPml.b_initialized = true;
            SIPml.b_initializing = false;
            tsk_utils_log_info("Engine initialized");
            if(successCallback){
                successCallback({});
            }
        }
        else{
            if(errorCallback){
                var s_description = !SIPml.b_webrtc_supported ? "WebRTC not supported" : (!SIPml.b_have_media_stream ? "getUserMedia not supported" : "Internal error");
                errorCallback({description: s_description});
            }
        }
    }
}

// ================================== SIPml.EventTarget ==========================================

/**
@constructor
Defines an event target. You sould never create an event target object.
*/
SIPml.EventTarget = function () {
    this.ao_listeners = [];
}

/**
Adds an event listener to the target object. <br /><br />
<table border="1">
    <tr>
        <td><b>Target classes<b></td>
        <td><b>Supported event types<b></td>
        <td><b>Raised event object<b></td>
        <td><b>Remarques<b></td>
    </tr>
    <tr>
        <td><a href="SIPml.Stack.html" name="SIPml.EventTarget.Stack">SIPml.Stack</a></td>
        <td>
            <b>*</b><br/> starting<br/> started<br/> stopping<br/> stopped<br/> failed_to_start<br/> failed_to_stop<br/> i_new_call<br /> i_new_message<br />
            m_permission_requested<br/> m_permission_accepted<br/> m_permission_refused
        </td>
        <td><a href="SIPml.Stack.Event.html">SIPml.Stack.Event</a></td>
        <td>'*' is used to listen for all events</td>
    </tr>
    <tr>
        <td>
            <a href="SIPml.Session.html" name="SIPml.EventTarget.Session">SIPml.Session</a>
            <ul>
                <li><a href="SIPml.Session.Call.html">SIPml.Session.Call</a></li>
                <li><a href="SIPml.Session.Message.html">SIPml.Session.Message</a></li>
                <li><a href="SIPml.Session.Message.html">SIPml.Session.Registration</a></li>
                <li><a href="SIPml.Session.Message.html">SIPml.Session.Subscribe</a></li>
                <li><a href="SIPml.Session.Message.html">SIPml.Session.Publish</a></li>
            <ul>
        </td>
        <td><b>*</b><br/> connecting<br/> connected<br/> terminating<br/> terminated<br/>
                i_ao_request<br />
                media_added<br/> media_removed<br/>
                i_request<br/> o_request<br/> cancelled_request<br/> sent_request<br/>
                transport_error<br/> global_error<br/> message_error<br/> webrtc_error
        </td>
        <td><a href="SIPml.Session.Event.html">SIPml.Session.Event</a></td>
        <td>'*' is used to listen for all events<br /></td>
    </tr>
    <tr>
        <td><a href="SIPml.Session.Call.html" name="SIPml.EventTarget.Session.Call">SIPml.Session.Call</a></td>
        <td>
            m_early_media<br/> m_local_hold_ok<br/> m_local_hold_nok<br/> m_local_resume_ok<br/> m_local_resume_nok<br/> m_remote_hold<br/> m_remote_resume<br/>
            m_stream_video_local_added<br /> m_stream_video_local_removed<br/> m_stream_video_remote_added<br/> m_stream_video_remote_removed <br />
            m_stream_audio_local_added<br /> m_stream_audio_local_removed<br/> m_stream_audio_remote_added<br/> m_stream_audio_remote_removed <br />
            i_ect_new_call<br/> o_ect_trying<br/> o_ect_accepted<br/> o_ect_completed<br/> i_ect_completed<br/> o_ect_failed<br/> i_ect_failed<br/> o_ect_notify<br/> i_ect_notify<br/> i_ect_requested <br />
            i_info
        </td>
        <td><a href="SIPml.Session.Event.html">SIPml.Session.Event</a></td>
        <td>borrows all events supported by <a href="SIPml.Session.html">SIPml.Session</a></td>
    </tr>
    <tr>
        <td><a href="SIPml.Session.Subscribe.html" name="SIPml.EventTarget.Session.Subscribe">SIPml.Session.Subscribe</a></td>
        <td>
            i_notify
        </td>
        <td><a href="SIPml.Session.Event.html">SIPml.Session.Event</a></td>
        <td>borrows all events supported by <a href="SIPml.Session.html">SIPml.Session</a></td>
    </tr>
</table>
@param {String|Array} type The event type/identifier. Must not be null or empty. Use <b>'*'</b> to listen for all events.
@param {function} listener The object that receives a notification when an event of the specified type occurs. This must be an object implementing the <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventListener">EventListener</a> interface, or simply a JavaScript function.
@example
// listen for a single event
this.addEventListener('started', function(e){
    console.info("'started' event fired");
});
// or listen for two or more events
this.addEventListener(['started', 'stopped'], function(e){
    console.info("'"+e.type+"' event fired");
});
// or listen for all events
this.addEventListener('*', function(e){
    console.info("'"+e.type+"' event fired");
});
@see <a href="#removeEventListener">removeEventListener</a>
@throws {ERR_INVALID_PARAMETER_VALUE|ERR_INVALID_PARAMETER_TYPE} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_INVALID_PARAMETER_TYPE</font>
*/
SIPml.EventTarget.prototype.addEventListener = function (o_type, o_listener) {
    if (!o_listener) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: 'listener' must not be null");
    }
    if (!o_type) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: 'type' must not be null");
    }
    if(!(o_type instanceof String || typeof o_type == "string" || o_type instanceof Array)){
        throw new Error("ERR_INVALID_PARAMETER_TYPE: 'type' must be a string or array");
    }
    
    if(o_type instanceof Array){
        var This = this;
        o_type.forEach(function (s_type) {
            if (!tsk_string_is_null_or_empty(s_type) && tsk_string_is_string(s_type)) {
                This.ao_listeners[s_type] = o_listener;
            }
        });
    }
    else{
        this.ao_listeners[o_type] = o_listener;
    }
}

/**
Removes an event listener from the target object.
@param {String} type The event type/identifier to stop listening for.
@see <a href="#addEventListener">addEventListener</a>
@exemple
this.removeEventListener('started');
*/
SIPml.EventTarget.prototype.removeEventListener = function (s_type) {
    if (tsk_string_is_string(s_type) && !tsk_string_is_null_or_empty(s_type)) {
        this.ao_listeners[s_type] = undefined;
    }
}

/**
@ignore
@private
@param {Object} event
*/
SIPml.EventTarget.prototype.dispatchEvent = function (o_event) {
    var o_listener = (this.ao_listeners[o_event.s_type] || this.ao_listeners['*']);
    if (o_listener) {
        o_listener.call(this, o_event.o_value);
    }
}



// ================================== SIPml.Event ==========================================


/** 
SIP  event object. You should never create an instance of this class by yourself.
@constructor
@param {String} type The event type or identifier. Please check <a href="SIPml.EventTarget.html#SIPml.EventTarget.Session">this link</a> for more information about all supported session event types.
@param {tsip_event} [event] Private wrapped session object.
@property {String} type The event <a href="SIPml.EventTarget.html#SIPml.EventTarget.Session">type or identifier</a> (e.g. <i>'connected'</i>).
@property {String} description User-friendly description in english (e.g. <i>'Session is now connected'</i>).
*/
SIPml.Event = function (s_type, o_event) {
    this.type = s_type;
    this.description = o_event ? o_event.s_phrase : s_type;
    this.o_event = o_event;
}

/**
Gets the SIP response code.
@returns {Integer} The SIP response code (e.g. 404).
*/
SIPml.Event.prototype.getSipResponseCode = function () {
    var o_message = this.o_event ? this.o_event.get_message() : null;
    if (o_message && o_message.is_response()) {
        return o_message.get_response_code();
    }
    return -1;
}

/**
Gets the SIP content associated to this event. This function could be called to get the content of the incoming SIP message ('i_new_message' event).
@returns {Object} SIP content.
@see <a href="#getContentType">getContentType</a>, <a href="#getContentString">getContentString</a>
*/
SIPml.Event.prototype.getContent = function () {
    var o_message = this.o_event ? this.o_event.get_message() : null;
    if (o_message) {
        return o_message.get_content();
    }
    return null;
}

/**
Gets the SIP content associated to this event. This function could be called to get the content of the incoming SIP message ('i_new_message' event).
@returns {String} SIP content.
@see <a href="#getContentType">getContentType</a>, <a href="#getContent">getContent</a>
*/
SIPml.Event.prototype.getContentString = function () {
    var o_message = this.o_event ? this.o_event.get_message() : null;
    if (o_message) {
        return o_message.get_content_as_string();
    }
    return null;
}

/**
Gets the SIP content-type associated to this event. This function could be called to get the content-type of the incoming SIP message ('i_new_message' event).
@returns {Object} SIP content-type.
@see <a href="#getContent">getContent</a>
*/
SIPml.Event.prototype.getContentType = function () {
    var o_message = this.o_event ? this.o_event.get_message() : null;
    if (o_message) {
        return o_message.get_content_type();
    }
    return null;
}



// ================================== SIPml.Stack ==========================================


/**
Anonymous SIP Stack configuration object.
@namespace SIPml.Stack.Configuration
@name SIPml.Stack.Configuration
@property {String} realm The domain name. Required for stack <a href="SIPml.Stack.html#constructor">constructor</a> but optional when used with <a href="SIPml.Stack.html#setConfiguration">setConfiguration</a>. <br />
Example: <i>example.org</i>
@property {String} impi The authentication name. Required for stack <a href="SIPml.Stack.html#constructor">constructor</a> but optional when used with <a href="SIPml.Stack.html#setConfiguration">setConfiguration</a>.<br />
Example: <i>+33600000000</i> or <i>bob</i>.
@property {string} impu The full SIP uri address. Required for stack <a href="SIPml.Stack.html#constructor">constructor</a> but optional when used with <a href="SIPml.Stack.html#setConfiguration">setConfiguration</a>.<br />
Example: <i>sip:+33600000000@example.com</i> or <i>tel:+33600000000</i> or <i>sip:bob@example.com</i>
@property {String} [password] The password to use for SIP authentication.<br />
Example: <i>mysecret</i>
@property {String} [display_name] The display name to use in SIP requests. This is the String displayed by the called party for incoming calls. <br />
Example: <i>I Am Legend</i>
@property {String} [websocket_proxy_url] The websocket proxy url to connect to (SIP server or gateway address). If unset the stack will use sipml5.org as host and a random port. You should not set this value unless you know what you're doing.<br />
Example: <i>ws://sipml5.org:5060</i>
@property {String} [outbound_proxy_url] The outbound Proxy URL is used to set the destination IP address and Port to use for all outgoing requests regardless the <i>domain name</i> (a.k.a <i>realm</i>). <br />
This is a good option for developers using a SIP domain name without valid DNS A/NAPTR/SRV records. You should not set this value unless you know what you're doing. <br />
Example: <i>udp://192.168.0.12:5060</i>
@property {Array} [ice_servers] The list of the STUN/TURN servers to use. The format must be as explained at <a target=_blank href="http://www.w3.org/TR/webrtc/#rtciceserver-type">http://www.w3.org/TR/webrtc/#rtciceserver-type</a>. <br />
To disable TURN/STUN to speedup ICE candidates gathering you can use an empty array. e.g. <i>[]</i>. <br />
Example: <i>[{ url: 'stun:stun.l.google.com:19302'}, { url:'turn:user@numb.viagenie.ca', credential:'myPassword'}]</i>
@property {Object} [bandwidth] Defines the maximum audio and video bandwidth to use. This will change the outhoing SDP to include a "b:AS=" attribute. Use <i>0</i> to let the browser negotiates the right value using RTCP-REMB and congestion control. Same property could be used at session level to override this value.<br />
<i>Available since version 1.3.203</i>. <br />
Example: <i>{ audio:64, video:512 }</i>
@property {Object} [video_size] Defines the maximum and minimum video size to be used. All values are optional. The browser will try to find the best video size between <i>max</i> and <i>min</i> based on the camera capabilities. Same property could be used at session level to override this value.<br />
<i>Available since version 1.3.203</i>. <br />
Example: <i>{ minWidth:640, minHeight:480, maxWidth:1920, maxHeight:1080 }</i>
@property {Boolean} [enable_rtcweb_breaker] Whether to enable the <a href="http://webrtc2sip.org/#aRTCWebBreaker" target=_blank>RTCWeb Breaker</a> module to allow calling SIP-legacy networks. <br />
Example: <i>true</i>
@property {Boolean} [enable_click2call] Whether to enable the <a href="http://click2dial.org" target=_blank>Click2Call / Click2Dial</a> service.
<i>Available since version 1.2.181</i>. <br />
Example: <i>true</i>
@property {Boolean} [enable_early_ims] Whether to enable 3GGP Early IMS as per <a href="http://www.arib.or.jp/english/html/overview/doc/STD-T63v9_60/5_Appendix/Rel6/33/33978-660.pdf" target=_blank>TR 33.978</a>. Should be 'true' unless you're using a real IMS network. <br />
<i>Available since version 1.3.203</i>. <br />
Example: <i>true</i>
@property {Boolean} [enable_media_stream_cache] Whether to reuse the same media stream for all calls. If your website is <b>not using https</b> then, the browser will request access to the camera (or microphone) every time you try to make a call. Caching the media stream will avoid getting these notifications for each call. <br />
<i>Available since version 1.3.203</i>. <br />
Example: <i>true</i>

@property {Object} [events_listener] Object to subscribe to some events.
Example:
<ul>
    <li><i>{ events: '*', listener: function(e){} }</i> </li>
    <li><i>{ events: 'started', listener: function(e){} }</i></li>
    <li><i>{ events: ['started', 'stopped'], listener: function(e){} }</i></li>
</ul>
You can also use <a href="#addEventListener">addEventListener</a> to add listeners to the stack.
@property {Array} [sip_headers] Stack-level SIP headers to add to all outgoing requests. Each header is an object with a <i>name</i> and <i>value</i> fields. <br />
Example: <i>sip_headers: [{name: 'User-Agent', value: 'IM-client/OMA1.0 sipML5-v1.0.89.0'}, {name: 'Organization', value: 'Doubango Telecom'}]</i>

@example
var configuration = {
        realm: 'example.org',
        impi: 'bob',
        impu: 'sip:bob@example.org',
        password: 'mysecret', // optional
        display_name: 'I Am Legend', // optional
        websocket_proxy_url: 'ws://192.168.0.10:5060', // optional
        outbound_proxy_url: 'udp://192.168.0.12:5060', // optional
        ice_servers: [{ url: 'stun:stun.l.google.com:19302'}, { url:'turn:user@numb.viagenie.ca', credential:'myPassword'}], // optional
        enable_rtcweb_breaker: true, // optional
        enable_click2call: false, // optional
        enable_early_ims: true, // optional
        events_listener: { events: '*', listener: listenerFunc }, // optional
        sip_headers: [ //optional
            {name: 'User-Agent', value: 'IM-client/OMA1.0 sipML5-v1.0.89.0'}, 
            {name: 'Organization', value: 'Doubango Telecom'}
        ]
    };
*/


/**
This is the root object used by any other object to make/receive calls, messages or manage presence.
You have to create an instance of this class before anything else.
@extends SIPml.EventTarget
@constructor
@class
@param {SIPml.Stack.Configuration} configuration Configuration object. Could be updated later using <a href="#setConfiguration">setConfiguration</a>.
@throws {ERR_INVALID_PARAMETER_VALUE|ERR_INVALID_PARAMETER_TYPE} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_INVALID_PARAMETER_TYPE</font>
@example
var listenerFunc = function(e){
    console.info('stack event = ' + e.type);
    // Please check <a href="SIPml.EventTarget.html#SIPml.EventTarget.Stack">this link</a> for more information on all supported events.
}

var o_stack = new SIPml.Stack({
        realm: 'example.org',
        impi: 'bob',
        impu: 'sip:bob@example.org',
        password: 'mysecret', // optional
        display_name: 'I Am Legend', // optional
        websocket_proxy_url: 'ws://192.168.0.10:5060', // optional
        outbound_proxy_url: 'udp://192.168.0.12:5060', // optional
        ice_servers: [{ url: 'stun:stun.l.google.com:19302'}, { url:'turn:user@numb.viagenie.ca', credential:'myPassword'}], // optional
        bandwidth: { audio:64, video:512 }, // optional
        video_size: { minWidth:640, minHeight:480, maxWidth:1920, maxHeight:1080 }, // optional
        enable_rtcweb_breaker: true, // optional
        enable_click2call: false, // optional
        events_listener: { events: '*', listener: listenerFunc }, //optional
        sip_headers: [ //optional
            {name: 'User-Agent', value: 'IM-client/OMA1.0 sipML5-v1.0.89.0'}, 
            {name: 'Organization', value: 'Doubango Telecom'}
        ]
    }
);

@see <a href="#setConfiguration">setConfiguration</a>
*/
SIPml.Stack = function (o_conf) {
    SIPml.init();
    SIPml.EventTarget.call(this);
    /*
    members:
    - o_stack {tsip_stack}
    */

    if (!o_conf) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: null configuration value");
    }
    if (tsk_string_is_null_or_empty(o_conf.realm)) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: '" + o_conf.realm + "' is not valid as realm value");
    }
    if (tsk_string_is_null_or_empty(o_conf.impi)) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: '" + o_conf.impi + "' is not valid as impi value");
    }
    if (tsk_string_is_null_or_empty(o_conf.impu)) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: '" + o_conf.impu + "' is not valid as impu value");
    }
    // check IMPU validity
    var o_impu = tsip_uri.prototype.Parse(o_conf.impu);
    if (!o_impu || !o_impu.s_user_name || !o_impu.s_host) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: '" + o_conf.impu + "' is not valid as SIP Uri");
    }

    var i_port;
    var s_proxy;    

    if (!SIPml.isWebSocketSupported()) {
        // port and host will be updated using the result from DNS SRV(NAPTR(realm))
        i_port = 5060;
        s_proxy = o_conf.realm;
    }
    else {
        // there are at least 5 servers running on the cloud.
        // we will connect to one of them and let the balancer to choose the right one (less connected sockets)
        // each port can accept up to 65K connections which means that the cloud can manage 325K active connections
        // the number of port will be increased or decreased based on the current trafic

        // webrtc2sip 2.2+ (Doubango): 
        //      WS: 10060, 11060, 12060, 13060, 14060
        //      WSS: 10062, 11062, 12062, 13062, 14062
        //

        i_port = (o_conf.enable_rtcweb_breaker ? 10062 : 10060) + (((new Date().getTime()) % 5) * 1000);
        s_proxy = "ns313841.ovh.net";
    }

    // create the stack
    this.o_stack = new tsip_stack(o_conf.realm, o_conf.impi, o_conf.impu, s_proxy, i_port);
    this.o_stack.oStack = this;
    // set configurations
    this.setConfiguration(o_conf);

    // listen for stack events
    this.o_stack.on_event_stack = function(e) {
        var s_type;
        switch (e.i_code) {
            case tsip_event_code_e.STACK_STARTING: s_type = 'starting'; break;
            case tsip_event_code_e.STACK_STARTED: s_type = 'started'; break;
            case tsip_event_code_e.STACK_STOPPING: s_type = 'stopping'; break;
            case tsip_event_code_e.STACK_STOPPED: s_type = 'stopped'; break;
            case tsip_event_code_e.STACK_FAILED_TO_START: s_type = 'failed_to_start'; break;
            case tsip_event_code_e.STACK_FAILED_TO_STOP: s_type = 'failed_to_stop'; break;
        }
        if(s_type){
             e.o_stack.oStack.dispatchEvent({ s_type: s_type, o_value: new SIPml.Stack.Event(s_type, e) });
        }
    }


     // listen for dialog events
     this.o_stack.on_event_dialog = function (e) {
         var s_type = null;
         var i_session_id = e.o_session.i_id;
         var oSession = e.o_session.o_stack.oStack.ao_sessions[i_session_id];
         if (!oSession) {
             tsk_utils_log_warn('Cannot find session with id = ' + i_session_id);
             return;
         }

         switch (e.i_code) {
             case tsip_event_code_e.DIALOG_TRANSPORT_ERROR: s_type = 'transport_error'; break;
             case tsip_event_code_e.DIALOG_GLOBAL_ERROR: s_type = 'global_error'; break;
             case tsip_event_code_e.DIALOG_MESSAGE_ERROR: s_type = 'message_error'; break;
             case tsip_event_code_e.DIALOG_WEBRTC_ERROR: s_type = 'webrtc_error'; break;
             case tsip_event_code_e.DIALOG_REQUEST_INCOMING: s_type = 'i_request'; break;
             case tsip_event_code_e.DIALOG_REQUEST_OUTGOING: s_type = 'o_request'; break;
             case tsip_event_code_e.DIALOG_REQUEST_CANCELLED: s_type = 'cancelled_request'; break;
             case tsip_event_code_e.DIALOG_REQUEST_SENT: s_type = 'sent_request'; break;
             case tsip_event_code_e.DIALOG_MEDIA_ADDED: s_type = 'media_added'; break;
             case tsip_event_code_e.DIALOG_MEDIA_REMOVED: s_type = 'media_removed'; break;
             case tsip_event_code_e.DIALOG_CONNECTING: s_type = 'connecting'; break;
             case tsip_event_code_e.DIALOG_CONNECTED: s_type = 'connected'; break;
             case tsip_event_code_e.DIALOG_TERMINATING: s_type = 'terminating'; break;
             case tsip_event_code_e.DIALOG_TERMINATED: 
                {
                    s_type = 'terminated'; 
                    e.o_session.o_stack.oStack.ao_sessions[i_session_id] = undefined; 
                    break;
                }
             default: break;
         }

         if (s_type) {
             oSession.dispatchEvent({ s_type: s_type, o_value: new SIPml.Session.Event(oSession, s_type, e) });
         }
     }

     // listen for MESSAGE events
     this.o_stack.on_event_message = function (e) {
         var s_type = null;
         var i_session_id = e.o_session.i_id;
         var oSession = e.o_session.o_stack.oStack.ao_sessions[i_session_id];

         switch (e.e_message_type) {
             case tsip_event_message_type_e.I_MESSAGE: s_type = 'i_new_message'; break;
             case tsip_event_message_type_e.AO_MESSAGE: s_type = 'i_ao_request'; break;
         }

         if (s_type) {
             // 'i_new_call' is stack-level event
             if (s_type == 'i_new_message') {
                var oNewEvent = new SIPml.Stack.Event(s_type, e);
                oNewEvent.newSession = new SIPml.Session.Message(e.o_session);
                e.o_session.o_stack.oStack.ao_sessions[i_session_id] = oNewEvent.newSession; // save session
                e.o_session.o_stack.oStack.dispatchEvent({ s_type: s_type, o_value:  oNewEvent});
             }
             else {
                 if(oSession){
                    oSession.dispatchEvent({ s_type: s_type, o_value: new SIPml.Session.Event(oSession, s_type, e) });
                 }
                 else{
                    tsk_utils_log_warn('Cannot find session with id = ' + i_session_id + ' and event = ' + e.e_invite_type);
                 }
             }
         }
     };

      // listen for PUBLISH events
     this.o_stack.on_event_publish = function (e) {
         var s_type = null;
         var i_session_id = e.o_session.i_id;
         var oSession = e.o_session.o_stack.oStack.ao_sessions[i_session_id];
         if(!oSession){
            tsk_utils_log_warn('Cannot find session with id = ' + i_session_id + ' and event = ' + e.e_invite_type);
            return;
         }

         switch(e.e_publish_type){
            case tsip_event_publish_type_e.I_PUBLISH: break;
            case tsip_event_publish_type_e.I_UNPUBLISH: break;
            case tsip_event_publish_type_e.AO_PUBLISH: 
            case tsip_event_publish_type_e.AO_UNPUBLISH:
                {
                    s_type = 'i_ao_request'; 
                    break;
                }
         }
         if(s_type){
            oSession.dispatchEvent({ s_type: s_type, o_value: new SIPml.Session.Event(oSession, s_type, e) });
         }
     }

     // listen for SUBSCRIBE events
     this.o_stack.on_event_subscribe = function (e) {
         var s_type = null;
         var i_session_id = e.o_session.i_id;
         var oSession = e.o_session.o_stack.oStack.ao_sessions[i_session_id];
         if(!oSession){
            tsk_utils_log_warn('Cannot find session with id = ' + i_session_id + ' and event = ' + e.e_invite_type);
            return;
         }

         switch(e.e_subscribe_type){
            case tsip_event_subscribe_type_e.I_SUBSCRIBE: break;
            case tsip_event_subscribe_type_e.I_UNSUBSRIBE: break;
            case tsip_event_subscribe_type_e.AO_SUBSCRIBE: 
            case tsip_event_subscribe_type_e.AO_UNSUBSCRIBE:
            case tsip_event_subscribe_type_e.AO_NOTIFY:
                {
                    s_type = 'i_ao_request';
                    break;
                }
            case tsip_event_subscribe_type_e.I_NOTIFY:
                {
                    s_type = 'i_notify';
                    break;
                }
         }
         if(s_type){
            oSession.dispatchEvent({ s_type: s_type, o_value: new SIPml.Session.Event(oSession, s_type, e) });
         }
     }


     // listen for INVITE events
     this.o_stack.on_event_invite = function (e) {
         var s_type = null;
         var i_session_id = e.o_session.i_id;
         var oSession = e.o_session.o_stack.oStack.ao_sessions[i_session_id];
         if (!oSession) {
             switch (e.e_invite_type) {
                case tsip_event_invite_type_e.I_NEW_CALL:
                case tsip_event_invite_type_e.M_STREAM_LOCAL_REQUESTED:
                case tsip_event_invite_type_e.M_STREAM_LOCAL_ACCEPTED:
                case tsip_event_invite_type_e.M_STREAM_LOCAL_REFUSED:
                    break;

                case tsip_event_invite_type_e.M_STREAM_LOCAL_ADDED:
                case tsip_event_invite_type_e.M_STREAM_REMOTE_ADDED:
                case tsip_event_invite_type_e.M_STREAM_LOCAL_REMOVED:
                case tsip_event_invite_type_e.M_STREAM_REMOTE_REMOVED:
                case tsip_event_invite_type_e.I_AO_REQUEST:
                    tsk_utils_log_info('Not notifying to session with id = ' + i_session_id + ' for event = ' + e.e_invite_type);
                    return;

                 default:
                    tsk_utils_log_warn('Cannot find session with id = ' + i_session_id + ' and event = ' + e.e_invite_type);
                    return;
             }
         }

         

         var _setStream = function (o_view, o_stream, o_stream_active, b_audio){
            if(o_stream){
                if(!b_audio && o_stream.videoTracks.length > 0){
                    if (window.HTMLVideoElement && o_view instanceof window.HTMLVideoElement){
                        o_view.srcObject = o_stream_active;
                        if (o_stream_active){
                            o_view.play();
                        }
                    }
                    return true;
                }
                if(b_audio && o_stream.audioTracks.length > 0){
                    if (window.HTMLAudioElement && o_view instanceof window.HTMLAudioElement){
                        o_view.srcObject = o_stream_active;
                        if (o_stream_active){
                            o_view.play();
                        }
                    }
                    return true;
                }
            }
         }

         var attachStream = function(bLocal){
            var o_stream = bLocal ? e.o_session.get_stream_local() : e.o_session.get_stream_remote();
             if (_setStream((bLocal ? oSession.videoLocal : oSession.videoRemote), o_stream, o_stream, false)){
                dispatchEvent(bLocal ? 'm_stream_video_local_added' : 'm_stream_video_remote_added');
            }
            if (_setStream((bLocal ? oSession.audioLocal : oSession.audioRemote), o_stream, o_stream, true)){
                dispatchEvent(bLocal ? 'm_stream_audio_local_added' : 'm_stream_audio_remote_added');
            }
         }
         var deattachStream = function(bLocal){
            var o_stream = bLocal ? e.o_session.get_stream_local() : e.o_session.get_stream_remote();
            if(_setStream((bLocal ? oSession.videoLocal : oSession.videoRemote), o_stream, null, false)){
                dispatchEvent(bLocal ? 'm_stream_video_local_removed' : 'm_stream_video_remote_removed');
            }
            if(_setStream((bLocal ? oSession.audioLocal : oSession.audioRemote), o_stream, null, true)){
                dispatchEvent(bLocal ? 'm_stream_audio_local_removed' : 'm_stream_audio_remote_removed');
            }
         }

        var dispatchEvent = function (s_event_type) {
            if (s_event_type) {
                // 'i_new_call', 'm_permission_requested', 'm_permission_accepted' and 'm_permission_refused' are stack-level event
                switch (s_event_type) {
                    case 'i_new_call':
                    case 'm_permission_requested':
                    case 'm_permission_accepted':
                    case 'm_permission_refused':
                        {
                            var oNewEvent = new SIPml.Stack.Event(s_event_type, e);
                            if(s_event_type == 'i_new_call'){
                                oNewEvent.newSession = new SIPml.Session.Call(e.o_session);
                                e.o_session.o_stack.oStack.ao_sessions[i_session_id] = oNewEvent.newSession; // save session
                            }
                            e.o_session.o_stack.oStack.dispatchEvent({ s_type: s_event_type, o_value: oNewEvent });
                            break;
                        }
                    default:
                        {
                            oSession.dispatchEvent({ s_type: s_event_type, o_value: new SIPml.Session.Event(oSession, s_event_type, e) });
                            break;
                        }
                }
            }
        }

         switch (e.e_invite_type) {
             case tsip_event_invite_type_e.I_NEW_CALL: s_type = 'i_new_call'; break;
             case tsip_event_invite_type_e.I_ECT_NEW_CALL: s_type = 'i_ect_new_call'; break;
             case tsip_event_invite_type_e.I_AO_REQUEST: s_type = 'i_ao_request'; break;
             case tsip_event_invite_type_e.M_EARLY_MEDIA: s_type = 'm_early_media'; break;
             case tsip_event_invite_type_e.M_STREAM_LOCAL_REQUESTED: s_type = 'm_permission_requested'; break;
             case tsip_event_invite_type_e.M_STREAM_LOCAL_ACCEPTED: s_type = 'm_permission_accepted'; break;
             case tsip_event_invite_type_e.M_STREAM_LOCAL_REFUSED: s_type = 'm_permission_refused'; break;
             case tsip_event_invite_type_e.M_STREAM_LOCAL_ADDED:
                 {
                   return attachStream(true);
                 }
             case tsip_event_invite_type_e.M_STREAM_LOCAL_REMOVED:
                 { 
                    return deattachStream(true);
                 }
             case tsip_event_invite_type_e.M_STREAM_REMOTE_ADDED:
                 { 
                    return attachStream(false);
                 }
             case tsip_event_invite_type_e.M_STREAM_REMOTE_REMOVED:
                {
                    return deattachStream(false);
                }
             case tsip_event_invite_type_e.M_LOCAL_HOLD_OK: s_type = 'm_local_hold_ok'; break;
             case tsip_event_invite_type_e.M_LOCAL_HOLD_NOK: s_type = 'm_local_hold_nok'; break;
             case tsip_event_invite_type_e.M_LOCAL_RESUME_OK: s_type = 'm_local_resume_ok'; break;
             case tsip_event_invite_type_e.M_LOCAL_RESUME_NOK: s_type = 'm_local_resume_nok'; break;
             case tsip_event_invite_type_e.M_REMOTE_HOLD: s_type = 'm_remote_hold'; break;
             case tsip_event_invite_type_e.M_REMOTE_RESUME: s_type = 'm_remote_resume'; break;
             case tsip_event_invite_type_e.O_ECT_TRYING: s_type = 'o_ect_trying'; break;
             case tsip_event_invite_type_e.O_ECT_ACCEPTED: s_type = 'o_ect_accepted'; break;
             case tsip_event_invite_type_e.O_ECT_COMPLETED: s_type = 'o_ect_completed'; break;
             case tsip_event_invite_type_e.I_ECT_COMPLETED: s_type = 'i_ect_completed'; break;
             case tsip_event_invite_type_e.O_ECT_FAILED: s_type = 'o_ect_failed'; break;
             case tsip_event_invite_type_e.I_ECT_FAILED: s_type = 'i_ect_failed'; break;
             case tsip_event_invite_type_e.O_ECT_NOTIFY: s_type = 'o_ect_notify'; break;
             case tsip_event_invite_type_e.I_ECT_NOTIFY: s_type = 'i_ect_notify'; break;
             case tsip_event_invite_type_e.I_ECT_REQUESTED: s_type = 'i_ect_requested'; break;
             case tsip_event_invite_type_e.DIALOG_REQUEST_INCOMING:
                 {
                    if(e.o_message) {
                        if(e.o_message.is_info()) { s_type = 'i_info'; }
                    }
                    break;
                 }  
             default: break;
         }

         // dispatch event
         dispatchEvent(s_type);
     }
}

SIPml.Stack.prototype = Object.create(SIPml.EventTarget.prototype);
SIPml.Stack.prototype.ao_sessions = [];

/**
Updates configuration values.
@param {SIPml.Stack.Configuration} configuration Configuration object value.
@returns {Integer} 0 if successful; otherwise nonzero
@example
// add two new headers and change the <i>proxy_url</i>
o_stack.setConfiguration({
    proxy_url: 'ws://192.168.0.10:5060',
    sip_headers: [
            {name: 'User-Agent', value: 'IM-client/OMA1.0 sipML5-v1.0.89.0'}, 
            {name: 'Organization', value: 'Doubango Telecom'}
        ]
    }
);
*/
SIPml.Stack.prototype.setConfiguration = function (o_conf) {
    if (o_conf.realm && !tsk_string_is_string(o_conf.realm)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof o_conf.realm + "' not a valid type for realm. String is expected");
    }
    if (o_conf.impi && !tsk_string_is_string(o_conf.impi)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof o_conf.impi + "' not a valid type for impi. String is expected");
    }
    if (o_conf.impu && !tsk_string_is_string(o_conf.impu)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof o_conf.impu + "' not a valid type for impu. String is expected");
    }
    if (o_conf.password && !tsk_string_is_string(o_conf.password)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof o_conf.password + "' not a valid type for password. String is expected");
    }
    if (o_conf.display_name && !tsk_string_is_string(o_conf.display_name)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof o_conf.display_name + "' not a valid type for display_name. String is expected");
    }
    if (o_conf.websocket_proxy_url && !tsk_string_is_string(o_conf.websocket_proxy_url)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof o_conf.websocket_proxy_url + "' not a valid type for websocket_proxy_url. String is expected");
    }
    if (o_conf.outbound_proxy_url && !tsk_string_is_string(o_conf.outbound_proxy_url)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof o_conf.outbound_proxy_url + "' not a valid type for outbound_proxy_url. String is expected");
    }
    if (o_conf.sip_headers && typeof o_conf.sip_headers != "Array" && !(o_conf.sip_headers instanceof Array)) {
        throw new Error("ERR_INVALID_PARAMETER_TYPE: '" + typeof o_conf.sip_headers + "' not a valid type for sip_headers. Array is expected");
    }

    // event-listener: must be first to be defined as other configs could raise events
    if(o_conf.events_listener){
        this.addEventListener(o_conf.events_listener.events, o_conf.events_listener.listener);
    }

    var b_rtcweb_breaker_enabled = !!o_conf.enable_rtcweb_breaker;
    var b_click2call_enabled = !!o_conf.enable_click2call;
    var b_early_ims = (o_conf.enable_early_ims == undefined) ? true : !!o_conf.enable_early_ims; // default value is true
    var b_enable_media_stream_cache = !!o_conf.enable_media_stream_cache;
    var o_bandwidth = o_conf.bandwidth ? o_conf.bandwidth : { audio:undefined, video:undefined };
    var o_video_size = o_conf.video_size ? o_conf.video_size : { minWidth:undefined, minHeight:undefined, maxWidth:undefined, maxHeight:undefined };
    var o_audio_constraints = o_conf.audio_constraints ? o_conf.audio_constraints : { googEchoCancellation: undefined, googNoiseSuppression: undefined, googAutoGainControl: undefined };
    var o_stack = this.o_stack;
    tsk_utils_log_info("s_websocket_server_url=" + (o_conf.websocket_proxy_url || "(null)"));
    tsk_utils_log_info("s_sip_outboundproxy_url=" + (o_conf.outbound_proxy_url || "(null)"));
    tsk_utils_log_info("b_rtcweb_breaker_enabled=" + (b_rtcweb_breaker_enabled ? "yes" : "no"));
    tsk_utils_log_info("b_click2call_enabled=" + (b_click2call_enabled ? "yes" : "no"));
    tsk_utils_log_info("b_early_ims=" + (b_early_ims ? "yes" : "no"));
    tsk_utils_log_info("b_enable_media_stream_cache=" + (b_enable_media_stream_cache ? "yes" : "no"));
    tsk_utils_log_info("o_bandwidth=" + JSON.stringify(o_bandwidth));
    tsk_utils_log_info("o_video_size=" + JSON.stringify(o_video_size));
    tsk_utils_log_info("o_audio_constraints=" + JSON.stringify(o_audio_constraints));

    o_stack.set(tsip_stack.prototype.SetPassword(o_conf.password),
								tsip_stack.prototype.SetDigest(o_conf.digest),
                     tsip_stack.prototype.SetDisplayName(o_conf.display_name),
                     tsip_stack.prototype.SetProxyOutBoundUrl(o_conf.outbound_proxy_url),
                     tsip_stack.prototype.SetRTCWebBreakerEnabled(b_rtcweb_breaker_enabled),
                     tsip_stack.prototype.SetClick2CallEnabled(b_click2call_enabled),
                     tsip_stack.prototype.SetSecureTransportEnabled(b_rtcweb_breaker_enabled), // always use secure transport when RTCWebBreaker
                     tsip_stack.prototype.SetEarlyIMSEnabled(b_early_ims), // should be 'true' unless you're using a real IMS network
                     tsip_stack.prototype.SetWebsocketServerUrl(o_conf.websocket_proxy_url),
                     tsip_stack.prototype.SetIceServers(o_conf.ice_servers),
                     tsip_stack.prototype.SetMediaStreamCacheEnabled(b_enable_media_stream_cache),
                     tsip_stack.prototype.SetBandwidth(o_bandwidth),
                     tsip_stack.prototype.SetVideoSize(o_video_size),
                     tsip_stack.prototype.SetAudioConstraints(o_audio_constraints)
                    );

    // add sip headers
    if (o_conf.sip_headers) {
        o_conf.sip_headers.forEach(function (o_header) {
            if (o_header && !tsk_string_is_null_or_empty(o_header.name) && (!o_header.value || tsk_string_is_string(o_header.value))) {
                o_stack.set(
                    tsip_stack.prototype.SetHeader(o_header.name, o_header.value)
                );
            }
        });
    }

    return 0;
}


/**
Starts the SIP stack and connect the network transport to the WebSocket server without sending any SIP request. 
This function must be be called before any attempt to make or receive calls/messages. This function is asynchronous which means that the stack will not be immediately started after the call.
Please check <a href="SIPml.EventTarget.html#SIPml.EventTarget.Stack">this link</a> for more information on all supported events.
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_INVALID_STATE} <font color="red">ERR_INVALID_STATE</font>
*/
SIPml.Stack.prototype.start = function () {
    return this.o_stack.start();
}

/**
Stops the SIP stack and disconnect the network transport from the WebSocket server. This function will also hangup all calls and unregister the user from the SIP server.
Please check <a href="SIPml.EventTarget.html#SIPml.EventTarget.Stack">this link</a> for more information on all supported events.
@param {Integer} [timeout] Optional parameter used to defined maximum time in milliseconds to take to stop the stack. 
Default value: 2000 millis
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_INVALID_STATE} <font color="red">ERR_INVALID_STATE</font>
*/
SIPml.Stack.prototype.stop = function (i_timeout) {
    return this.o_stack.stop(i_timeout);
}

/**
Create new SIP session.
@param {String} type Session type. Supported values: <b>'register'</b>, <b>'call-audio'</b>, <b>'call-audiovideo'</b>, <b>'call-video'</b>, <b>'call-screenshare'</b>, <b>'message'</b>, <b>'subscribe'</b> or <b>'publish'</b>.
@param {SIPml.Session.Configuration} [configuration] Anonymous object used to configure the newly created session.
@throws {ERR_INVALID_PARAMETER_VALUE} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> <br>
@returns {SIPml.Session} New session if successful; otherwise null.<br> The session type would be <a href="SIPml.Session.Registration.html">SIPml.Session.Registration</a>, <a href="SIPml.Session.Call.html">SIPml.Session.Call</a> or <a href="SIPml.Session.Message.html">SIPml.Session.Message</a> <br>

@example
var <a href="SIPml.Session.Registration.html">o_registration</a> = this.<a href="#newSession">newSession</a>('register', {
            expires: 200,
            sip_caps: [
                    {name: '+g.oma.sip-im'},
                    {name: '+audio'},
                    {name: 'language', value: '\"en,fr\"'}
            ],
            sip_headers: [
                    {name: 'What', value: 'Registration', session: false}, 
                    {name: 'Organization', value: 'Doubango Telecom', session: true}
            ]
        });
o_registration.<a href="SIPml.Session.Registration.html#register">register</a>();

// or
var <a href="SIPml.Session.Call.html">o_audiovideo</a> = this.<a href="#newSession">newSession</a>('call-audiovideo', {
            video_local: document.getElementById('video_local'), // &lt;video id="video_local" .../&gt;
            video_remote: document.getElementById('video_remote'), // &lt;video id="video_remote" .../&gt;
            audio_remote: document.getElementById('audio_remote'), // &lt;audio id="audio_remote" .../&gt;
            sip_caps: [
                    {name: '+g.oma.sip-im'},
                    {name: '+sip.ice'},
                    {name: 'language', value: '\"en,fr\"'}
            ],
            sip_headers: [
                    {name: 'What', value: 'Audio/Video call', session: false}, 
                    {name: 'Organization', value: 'Doubango Telecom', session: false}
            ]
        });
o_audiovideo.<a href="SIPml.Session.Call.html#call">call</a>('alice'); // call alice
*/
SIPml.Stack.prototype.newSession = function (s_type, o_conf) {
    var o_session;
    var cls;
    if (s_type == 'register') {
        o_session = new tsip_session_register(this.o_stack);
        cls = SIPml.Session.Registration;
    }
    else if (s_type == 'message') {
        o_session = new tsip_session_message(this.o_stack);
        cls = SIPml.Session.Message;
    }
    else if (s_type == 'publish') {
        o_session = new tsip_session_publish(this.o_stack);
        cls = SIPml.Session.Publish;
    }
    else if (s_type == 'subscribe') {
        o_session = new tsip_session_subscribe(this.o_stack);
        cls = SIPml.Session.Subscribe;
    }
    else if (s_type == 'call-audio' || s_type == 'call-audiovideo' || s_type == 'call-video' || s_type == 'call-screenshare') {
        o_session = new tsip_session_invite(this.o_stack);
        o_session.s_type = s_type;
        cls = SIPml.Session.Call;
    }
    else {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: '" + s_type + "' not valid as session type");
    }

    o_session.b_local = true; // locally created session
    var oSession = new cls(o_session, o_conf);
    this.ao_sessions[oSession.getId()] = oSession;
    return oSession;
}

// ================================== SIPml.Stack.Event ==========================================

/** 
SIP Stack event object. You should never create an instance of this object.
@constructor
@extends SIPml.Event
@param {String} type The event type/identifier.
@param {tsip_event} [event] The wrapped event object.
@property {String} type The event type or identifier (e.g. <i>'started'</i> or <i>'i_new_call'</i>). Please check <a href="SIPml.EventTarget.html#SIPml.EventTarget.Stack">this link</a> for more information on all supported events.
@property {String} description User-friendly description in english (e.g. <i>'Stack started'</i> or <i>'<b>I</b>ncoming <b>new</b> <b>call</b>'</i>).
@property {SIPml.Session} [newSession] Optional session object only defined when the event is about a new session creation (e.g. <i>'i_new_call'</i>).
The session type would be <a href="SIPml.Session.Call.html">SIPml.Session.Call</a> or <a href="SIPml.Session.Message.html">SIPml.Session.Message</a>
*/
SIPml.Stack.Event = function (s_type, o_event) {
    SIPml.Event.call(this, s_type, o_event);
}

SIPml.Stack.Event.prototype = Object.create(SIPml.Event.prototype);

// ================================== SIPml.Session ==========================================

/**
Anonymous SIP Session configuration object.
@namespace SIPml.Session.Configuration
@name SIPml.Session.Configuration
@property {Integer} [expires] Session timeout in seconds. 
@property {HTMLVideoElement} [video_local] <a href="https://developer.mozilla.org/en-US/docs/DOM/HTMLVideoElement">HTMLVideoElement<a> where to display the local video preview. This propety should be only used for <a href="SIPml.Session.Call.html">video sessions</a>.
@property {HTMLVideoElement} [video_remote] <a href="https://developer.mozilla.org/en-US/docs/DOM/HTMLVideoElement">HTMLVideoElement<a> where to display the remote video stream. This propety should be only used for <a href="SIPml.Session.Call.html">video sessions</a>.
@property {HTMLAudioElement} [audio_remote] <a href="https://developer.mozilla.org/en-US/docs/DOM/HTMLAudioElement">HTMLAudioElement<a> used to playback the remote audio stream. This propety should be only used for <a href="SIPml.Session.Call.html">audio sessions</a>.
@property {Array} [sip_caps] <i>{name,value}</i> pairs defining the SIP capabilities associated to this session. The capabilities are added to the Contact header. Please refer to <a href="http://tools.ietf.org/html/rfc3840">rfc3840</a> and <a href="http://tools.ietf.org/html/rfc3841">rfc3841</a> for more information.
@property {String} [from] Set the source uri string to be used in the <i>From</i> header (available since API version 1.2.170).
@property {Object} [bandwidth] Defines the maximum audio and video bandwidth to use. This will change the outhoing SDP to include a "b:AS=" attribute. Use <i>0</i> to let the browser negotiates the right value using RTCP-REMB and congestion control. A default value for all sessions could be defined at stack level.<br />
<i>Available since version 1.3.203</i>. <br />
Example: <i>{ audio:64, video:512 }</i>
@property {Object} [video_size] Defines the maximum and minimum video size to be used. All values are optional. The browser will try to find the best video size between <i>max</i> and <i>min</i> based on the camera capabilities. A default value for all sessions could be defined at stack level.<br />
<i>Available since version 1.3.203</i>. <br />
Example: <i>{ minWidth:640, minHeight:480, maxWidth:1920, maxHeight:1080 }</i>
@property {Array} [sip_headers] <i>{name,value,session}</i> trios defining the SIP headers associated to this session. <i>session</i> is a boolean defining whether the header have to be added to all outgoing request or not (initial only).
@example
var configuration = 
{
    expires: 200,
    audio_remote: document.getElementById('audio_remote'), // &lt;audio id="audio_remote" .../&gt;
    video_local: document.getElementById('video_local'),  // &lt;video id="video_local" .../&gt;
    video_remote: document.getElementById('video_remote'),  // &lt;video id="video_remote" .../&gt;
    sip_caps: [
                    {name: '+g.oma.sip-im'},
                    {name: '+sip.ice'},
                    {name: 'language', value: '\"en,fr\"'}
            ],
    sip_headers: [
                    {name: 'What', value: 'Audio/Video call', session: false}, 
                    {name: 'Organization', value: 'Doubango Telecom', session: false}
            ]
}
*/

/** 
Base (abstract) SIP session. You should never create an instance of this class by yourself. You have to use <a href="SIPml.Stack.html#newSession"> newSession()</a> to create a new instance.
This is a base class for <a href="SIPml.Session.Registration.html">SIPml.Session.Registration</a>, <a href="SIPml.Session.Call.html">SIPml.Session.Call</a> and <a href="SIPml.Session.Message.html">SIPml.Session.Message</a>.
@constructor
@extends SIPml.EventTarget
@param {tsip_session_t} session Private wrapped session object.
@param {SIPml.Session.Configuration} [configuration] Optional configuration object.
@throws {ERR_INVALID_PARAMETER_VALUE|ERR_INVALID_PARAMETER_TYPE} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_INVALID_PARAMETER_TYPE</font>
*/
SIPml.Session = function (o_session, o_conf) {
     SIPml.EventTarget.call(this);
    /*
        - o_configuration: []
        - o_session: tsip_session_xxx
    */
    if (!o_session) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: Invalid session value");
    }

    this.o_session = o_session;
    this.setConfiguration(o_conf);
}

SIPml.Session.prototype = Object.create(SIPml.EventTarget.prototype);
SIPml.Session.prototype.o_session = null;
SIPml.Session.prototype.o_session = null;
SIPml.Session.prototype.o_configuration = null;

/**
Gets the session unique identifier.
@returns {Integer} Read-only session unique identifier.
*/
SIPml.Session.prototype.getId = function(){
    return this.o_session.get_id();
}

/**
Updates or sets the session configuration.
@param {SIPml.Session.Configuration} configuration
*/
SIPml.Session.prototype.setConfiguration = function(o_conf){
    if(!o_conf){
        return;
    }

    var o_session = this.o_session;

    // event-listener: must be first to be defined as other configs could raise events
    if(o_conf.events_listener){
        this.addEventListener(o_conf.events_listener.events, o_conf.events_listener.listener);
    }

    if(this instanceof SIPml.Session.Call){
        // Bandwidth and video size
        o_session.set(
                    tsip_session.prototype.SetBandwidth(o_conf.bandwidth ? o_conf.bandwidth : { audio:undefined, video:undefined }),
                    tsip_session.prototype.SetVideoSize(o_conf.video_size ? o_conf.video_size : { minWidth:undefined, minHeight:undefined, maxWidth:undefined, maxHeight:undefined }),
                    tsip_session.prototype.SetAudioConstraints(o_conf.audio_constraints ? o_conf.audio_constraints : { googEchoCancellation: undefined, googNoiseSuppression: undefined, googAutoGainControl: undefined })
                );

        this.videoLocal = o_conf.video_local;
        this.videoRemote = o_conf.video_remote;
        this.audioRemote = o_conf.audio_remote;
        this.audioLocal = o_conf.audio_local;
        
        var _addStream = function (o_view, o_stream, b_audio){
            if(o_stream){
                if(!b_audio && o_stream.videoTracks.length > 0){
                    if (window.HTMLVideoElement && o_view instanceof window.HTMLVideoElement){
                        if (o_view.srcObject == o_stream){
                            return false; // unchanged
                        }
                        o_view.srcObject = o_stream;
                        if (o_stream){
                            o_view.play();
                        }
                    }
                    return true;
                }
                if(b_audio && o_stream.audioTracks.length > 0){
                    if (window.HTMLAudioElement && o_view instanceof window.HTMLAudioElement){
                        if (o_view.srcObject == o_stream){
                            return false; // unchanged
                        }
                        o_view.srcObject = o_stream;
                        if (o_stream){
                            o_view.play();
                        }
                    }
                    return true;
                }
            }
         }

        if(_addStream(this.videoLocal, o_session.get_stream_local(), false)){
            this.dispatchEvent({ s_type: 'm_stream_video_local_added', o_value: new SIPml.Session.Event(this, 'm_stream_video_local_added') });
        }
        if(_addStream(this.videoRemote, o_session.get_stream_remote(), false)){
            this.dispatchEvent({ s_type: 'm_stream_video_remote_added', o_value: new SIPml.Session.Event(this, 'm_stream_video_remote_added') });
        }
        if(_addStream(this.audioLocal, o_session.get_stream_local(), true)){
            this.dispatchEvent({ s_type: 'm_stream_audio_local_added', o_value: new SIPml.Session.Event(this, 'm_stream_audio_local_added') });
        }
        if(_addStream(this.audioRemote, o_session.get_stream_remote(), true)){
            this.dispatchEvent({ s_type: 'm_stream_audio_remote_added', o_value: new SIPml.Session.Event(this, 'm_stream_audio_remote_added') });
        }
    }

    
    // headers
    if (o_conf.sip_headers) {
        o_conf.sip_headers.forEach(function (o_header) {
            if (o_header && !tsk_string_is_null_or_empty(o_header.name) && (!o_header.value || tsk_string_is_string(o_header.value))) {
                o_session.set(
                    tsip_session.prototype.SetHeader(o_header.name, o_header.value)
                );
            }
        });
    }
    // caps
    if (o_conf.sip_caps) {
        o_conf.sip_caps.forEach(function (o_cap) {
            if (o_cap && !tsk_string_is_null_or_empty(o_cap.name) && (!o_cap.value || tsk_string_is_string(o_cap.value))) {
                o_session.set(
                    tsip_session.prototype.SetCaps(o_cap.name, o_cap.value)
                );
            }
        });
    }
    // expires
    if (o_conf.expires) {
        o_session.set(tsip_session.prototype.SetExpires(o_conf.expires));
    }
    // from
    if (o_conf.from) {
        o_session.set(tsip_session.prototype.SetFromStr(o_conf.from));
    }
}

/**
Gets the remote party SIP Uri (e.g. sip:john.doe@example.com). This Uri could be used a match an incoming call to a contact from your address book.
@returns {String} The remote party SIP Uri.
@see <a href="#getRemoteFriendlyName">getRemoteFriendlyName</a>
*/
SIPml.Session.prototype.getRemoteUri = function(){
    return (this.o_session.b_local ? this.o_session.o_uri_to : this.o_session.o_uri_from).toString();
}

/**
Gets the remote party friendly name (e.g. 'John Doe').
@returns {String} The remote party friendly name.
@see <a href="#getRemoteUri">getRemoteUri</a>
*/
SIPml.Session.prototype.getRemoteFriendlyName = function(){
    var o_uri = this.o_session.b_local ? this.o_session.o_uri_to : this.o_session.o_uri_from;
    return o_uri.s_display_name ? o_uri.s_display_name : o_uri.s_user_name;
}

/**
Rejects an incoming SIP MESSAGE (SMS-like) or audio/video call.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_NOT_READY} <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.prototype.reject = function (o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.reject();
}

/**
Accepts an incoming SIP MESSAGE (SMS-like) or audio/video call.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_NOT_READY} <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.prototype.accept = function (o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.accept();
}



// ================================== SIPml.Session.Event ==================================


/** 
SIP session event object. You should never create an instance of this class by yourself.
@constructor
@extends SIPml.Event
@param {SIPml.Session} [session] The session type would be <a href="SIPml.Session.Registration.html">SIPml.Session.Registration</a>, <a href="SIPml.Session.Call.html">SIPml.Session.Call</a> or <a href="SIPml.Session.Message.html">SIPml.Session.Message</a>.
@param {String} type The event type or identifier. Please check <a href="SIPml.EventTarget.html#SIPml.EventTarget.Session">this link</a> for more information about all supported session event types.
@param {tsip_event} [event] Private wrapped session object.
@property {SIPml.Session} session Session associated to this event. Would be <a href="SIPml.Session.Registration.html">SIPml.Session.Registration</a>, <a href="SIPml.Session.Call.html">SIPml.Session.Call</a> or <a href="SIPml.Session.Message.html">SIPml.Session.Message</a>.
*/
SIPml.Session.Event = function (o_session, s_type, o_event) {
    SIPml.Event.call(this, s_type, o_event);
    this.session = o_session;
}

SIPml.Session.Event.prototype = Object.create(SIPml.Event.prototype);


/**
Gets the name of destination for the current call transfer. 
@returns {String} The name of destination for the current call transfer (e.g. 'John Doe').
*/
SIPml.Session.Event.prototype.getTransferDestinationFriendlyName = function () {
    var o_message = this.o_event ? this.o_event.get_message() : null;
    if (o_message) {
        var o_hdr_Refer_To = o_message.get_header(tsip_header_type_e.Refer_To);
        if(o_hdr_Refer_To && o_hdr_Refer_To.o_uri){
            return (o_hdr_Refer_To.s_display_name ? o_hdr_Refer_To.s_display_name : o_hdr_Refer_To.o_uri.s_user_name);
        }
    }
    return null;
}

// ================================== SIPml.Registration ==================================

/**
SIP session registration class. You should never create an instance of this class by yourself.
Please use <a href="SIPml.Stack.html#newSession">stack.newSession()</a> function to create a new registration session.
@constructor
@extends SIPml.Session
@param {tsip_session} session Private wrapped session object
@param {SIPml.Session.Configuration} [configuration] Configuration value.
*/
SIPml.Session.Registration = function (o_session, o_configuration) {
    SIPml.Session.call(this, o_session, o_configuration);
}

SIPml.Session.Registration.prototype = Object.create(SIPml.Session.prototype);

/**
Sends SIP REGISTER request to login the user. Refreshing requests will be automatically done based on the expiration time.
@param {SIPml.Session.Configuration} [configuration] Optional configuration value.
@example
var session = <a href="SIPml.Stack.html#newSession">stack.newSession</a>('register', {
                            expires: 200,
                            events_listener: { events: '*', listener: onSipEventSession },
                            sip_caps: [
                                        { name: '+g.oma.sip-im', value: null },
                                        { name: '+audio', value: null },
                                        { name: 'language', value: '\"en,fr\"' }
                                ]
                        });
session.register();

@see <a href="#unregister">unregister</a>
@throws {ERR_INVALID_STATE} <font color="red">ERR_INVALID_STATE</font>
*/
SIPml.Session.Registration.prototype.register = function (o_conf) {
    // FIXME: apply o_configuration
    // FIXME: raise error if stack not started
    this.setConfiguration(o_conf);
    return this.o_session.register();
}

/**
Sends SIP REGISTER (expires=0) request to logout the user.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@see <a href="#register">register</a>
@throws {ERR_INVALID_STATE} <font color="red">ERR_INVALID_STATE</font>
*/
SIPml.Session.Registration.prototype.unregister = function (o_conf) {
    // FIXME: raise error if stack not started
    this.setConfiguration(o_conf);
    return this.o_session.unregister();
}

// ================================== SIPml.Call ==========================================

/** 
SIP audio/video/screenshare call session class. You should never create an instance of this class by yourself.
Please use <a href="SIPml.Stack.html#newSession">stack.newSession()</a> function to create a new audio/video/screenshare session.
@constructor
@extends SIPml.Session
@param {tsip_session} session Private wrapped session object
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@example
var listenerFunc = function(e){
    console.info('session event = ' + e.type);
}
var session = <a href="SIPml.Stack.html#newSession">stack.newSession</a>('call-audiovideo', {
            video_local: document.getElementById('video-local'), // &lt;video id="video-local" .../&gt;
            video_remote: document.getElementById('video-remote'), // &lt;video id="video-remote" .../&gt;
            audio_remote: document.getElementById('audio-remote'), // &lt;audio id="audio-remote" .../&gt;
            events_listener: { events: '*', listener: listenerFunc },
            sip_caps: [
                            { name: '+g.oma.sip-im' },
                            { name: '+sip.ice' },
                            { name: 'language', value: '\"en,fr\"' }
                        ]
        });
@throws {ERR_INVALID_PARAMETER_VALUE} <font color="red">ERR_INVALID_PARAMETER_VALUE</font>
*/
SIPml.Session.Call = function (o_session, o_conf) {
    SIPml.Session.call(this, o_session, o_conf);

    switch (o_session.s_type) {
        case 'call-audio': this.mediaType = tmedia_type_e.AUDIO; break;
        case 'call-audiovideo': this.mediaType = tmedia_type_e.AUDIO_VIDEO; break;
        case 'call-video': this.mediaType = tmedia_type_e.VIDEO; break;
        case 'call-screenshare': this.mediaType = tmedia_type_e.SCREEN_SHARE; break;
    }
}

SIPml.Session.Call.prototype = Object.create(SIPml.Session.prototype);
SIPml.Session.Call.prototype.videoLocal = null;
SIPml.Session.Call.prototype.videoRemote = null;

/**
Makes audio/video call.
@param {String} to Destination name, uri, phone number or identifier (e.g. 'sip:johndoe@example.com' or 'johndoe' or '+33600000000').
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@example
var listenerFunc = function(e){
    console.info('session event = ' + e.type);
}
var session = <a href="SIPml.Stack.html#newSession">stack.newSession</a>('call-audiovideo');
session.call('johndoe', {
            video_local: document.getElementById('video-local'), // &lt;video id="video-local" .../&gt;
            video_remote: document.getElementById('video-remote'), // &lt;video id="video-remote" .../&gt;
            audio_remote: document.getElementById('audio-remote'), // &lt;audio id="audio-remote" .../&gt;
            events_listener: { events: '*', listener: listenerFunc },
            sip_caps: [
                            { name: '+g.oma.sip-im' },
                            { name: '+sip.ice' },
                            { name: 'language', value: '\"en,fr\"' }
                        ]
        });

@throws {ERR_INVALID_PARAMETER_VALUE | ERR_NOT_READY} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Call.prototype.call = function (s_to, o_conf) {
    if (tsk_string_is_null_or_empty(s_to)) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: 'to' must not be null");
    }
    if (!SIPml.haveMediaStream()) {
        throw new Error("ERR_NOT_READY: Media engine not ready yet");
    }
    // set destination
    this.o_session.set(tsip_session.prototype.SetToStr(s_to));
    // set conf
    this.setConfiguration(o_conf);
    // make call
    return this.o_session.call(this.mediaType);
}

/**
Terminates the audio/video call.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_NOT_READY} <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Call.prototype.hangup = function (o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.hangup();
}

/**
Holds the audio/video call.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_NOT_READY} <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Call.prototype.hold = function (o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.hold(this.mediaType);
}

/**
Resumes the audio/video call.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_NOT_READY} <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Call.prototype.resume = function (o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.resume(this.mediaType);
}

/**
Sends SIP INFO message.
@param {Object|String} [content] SIP INFO request content.
@param {String} [contentType] Content Type.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@example
session.info('Device orientation: portrait', 'doubango/device-orientation.xml');
@throws {ERR_NOT_READY} <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Call.prototype.info = function (o_content, s_content_type, o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.info(o_content, s_content_type);
}

/**
Sends a SIP DTMF digit.
@param {Char} [digit] The digit to send.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@example
session.dtmf('#');
@throws {ERR_INVALID_PARAMETER_VALUE | ERR_NOT_READY} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Call.prototype.dtmf = function (c_digit, o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.dtmf(c_digit);
}

/**
Transfers the call to a new destination.
@param {String} to Transfer destination name, uri, phone number or identifier (e.g. 'sip:johndoe@example.com' or 'johndoe' or '+33600000000').
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@example
session.transfer('johndoe');
@throws {ERR_INVALID_PARAMETER_VALUE | ERR_NOT_READY} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Call.prototype.transfer = function (s_to, o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.transfer(s_to);
}

/**
Accepts incoming transfer request.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_NOT_READY} <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Call.prototype.acceptTransfer = function (o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.transfer_accept();
}

/**
Rejects incoming transfer request.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_NOT_READY} <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Call.prototype.rejectTransfer = function (o_conf) {
    this.setConfiguration(o_conf);
    return this.o_session.transfer_reject();
}

// ================================== SIPml.Session.Message ==========================================

/** 
SIP MESSAGE (SMS) session class. You should never create an instance of this class by yourself.
Please use <a href="SIPml.Stack.html#newSession">stack.newSession()</a> function to create a messaging/IM session.
@constructor
@param {tsip_session} session Private session object.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@example
var session = <a href="SIPml.Stack.html#newSession">stack.newSession</a>('message');
*/
SIPml.Session.Message = function (o_session, o_conf) {
    SIPml.Session.call(this, o_session, o_conf);

}

SIPml.Session.Message.prototype = Object.create(SIPml.Session.prototype);

/**
Sends a SIP MESSAGE (SMS-like) request.
@param {String} to Destination name, uri, phone number or identifier (e.g. 'sip:johndoe@example.com' or 'johndoe' or '+33600000000').
@param {Object|String} [content] The message content.
@param {String} [contentType] The content type.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@example
var session = <a href="SIPml.Stack.html#newSession">stack.newSession</a>('message');
session.send('johndoe', 'P&ecirc;che &agrave; la moule', 'text/plain;charset=utf8',{
    sip_caps: [
                                    { name: '+g.oma.sip-im' },
                                    { name: '+sip.ice' },
                                    { name: 'language', value: '\"en,fr\"' }
                            ],
    sip_headers: [
                            { name: 'What', value: 'Sending SMS' },
                            { name: 'My-Organization', value: 'Doubango Telecom' }
                    ]
});
@throws {ERR_INVALID_PARAMETER_VALUE | ERR_NOT_READY} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_NOT_READY</font>
*/
SIPml.Session.Message.prototype.send = function (s_to, o_content, s_content_type, o_conf){
    if (tsk_string_is_null_or_empty(s_to)) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: 'to' must not be null");
    }

    // apply configuration values
    this.setConfiguration(o_conf);
    // set destination
    this.o_session.set(tsip_session.prototype.SetToStr(s_to));
    // sends the message
    return this.o_session.send(o_content, s_content_type);
}



// ================================== SIPml.Session.Publish ==========================================


/** 
SIP PUBLISH (for presence status publication) session class.You should never create an instance of this class by yourself.
Please use <a href="SIPml.Stack.html#newSession">stack.newSession()</a> function to create a new presence publication session.
@constructor
@extends SIPml.Session
@since version 1.1.0
@param {tsip_session} session Private session object.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@example
var session = <a href="SIPml.Stack.html#newSession">stack.newSession</a>('publish', {
                            expires: 200,
                            events_listener: { events: '*', listener: function(e){} },
                            sip_headers: [
                                          { name: 'Event', value: 'presence' } // very important
                                ],
                            sip_caps: [
                                        { name: '+g.oma.sip-im', value: null },
                                        { name: '+audio', value: null },
                                        { name: 'language', value: '\"en,fr\"' }
                                ]
                        });
*/
SIPml.Session.Publish = function (o_session, o_conf) {
    SIPml.Session.call(this, o_session, o_conf);
    // set destination to ourself (https://groups.google.com/forum/#!topic/doubango/XKWTQ9TgjPU)
    o_session.set(tsip_session.prototype.SetToUri(o_session.get_stack().identity.o_uri_impu));
}

SIPml.Session.Publish.prototype = Object.create(SIPml.Session.prototype);

/**
Sends a SIP PUBLISH (for presence status publication) request.
@since version 1.1.0
@param {Object|String} [content] The request content.
@param {String} [contentType] The content type.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@example
var session = <a href="SIPml.Stack.html#newSession">stack.newSession</a>('publish');
var contentType = 'application/pidf+xml';
var content = '&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n' +
                '&lt;presence xmlns=\"urn:ietf:params:xml:ns:pidf\"\n' +
                    ' xmlns:im=\"urn:ietf:params:xml:ns:pidf:im\"' +
             	    ' entity=\"sip:bob@example.com\"&gt;\n' +
                    '&lt;tuple id=\"s8794\"&gt;\n' +
                    '&lt;status&gt;\n'+
                    '   &lt;basic>open&lt;/basic&gt;\n' +
                    '   &lt;im:im>away&lt;/im:im&gt;\n' +
                    '&lt;/status&gt;\n' +
                    '&lt;contact priority=\"0.8\"&gt;tel:+33600000000&lt;/contact&gt;\n' +
                    '&lt;note  xml:lang=\"fr\"&gt;Bonjour de Paris :)&lt;/note&gt;\n' +
                    '&lt;/tuple&gt;\n' +
   	            '&lt;/presence&gt;';

session.publish(content, contentType,{
    expires: 200,
    sip_caps: [
                                    { name: '+g.oma.sip-im' },
                                    { name: '+sip.ice' },
                                    { name: 'language', value: '\"en,fr\"' }
                            ],
    sip_headers: [
                            { name: 'Event', value: 'presence' },
                            { name: 'Organization', value: 'Doubango Telecom' }
                    ]
});
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_INVALID_PARAMETER_VALUE | ERR_NOT_READY} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_NOT_READY</font>
@see <a href="#unpublish">unpublish</a>
*/
SIPml.Session.Publish.prototype.publish = function (o_content, s_content_type, o_conf){
    // apply configuration values
    this.setConfiguration(o_conf);
    // sends the PUBLISH request
    return this.o_session.publish(o_content, s_content_type);
}

/**
Remove/unpublish presence data from the server.
@since version 1.1.0
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@throws {ERR_INVALID_PARAMETER_VALUE | ERR_NOT_READY} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_NOT_READY</font>
@see <a href="#publish">publish</a>
*/
SIPml.Session.Publish.prototype.unpublish = function (o_conf){
    // apply configuration values
    this.setConfiguration(o_conf);
    // sends the PUBLISH request (expires = 0)
    return this.o_session.unpublish();
}





// ================================== SIPml.Session.Subscribe ==========================================


/** 
SIP SUBSCRIBE (for presence status subscription) session class.You should never create an instance of this class by yourself.
Please use <a href="SIPml.Stack.html#newSession">stack.newSession()</a> function to create a new presence subscription session.
@constructor
@extends SIPml.Session
@since version 1.1.0
@param {tsip_session} session Private session object.
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@example
var session = <a href="SIPml.Stack.html#newSession">stack.newSession</a>('subscribe', {
                expires: 200,
                events_listener: { events: '*', listener: function(e){} },
                sip_headers: [
                                { name: 'Event', value: 'presence' },
                                { name: 'Accept', value: 'application/pidf+xml' }
                    ],
                sip_caps: [
                            { name: '+g.oma.sip-im', value: null },
                            { name: '+audio', value: null },
                            { name: 'language', value: '\"en,fr\"' }
                    ]
            });
*/
SIPml.Session.Subscribe = function (o_session, o_conf) {
    SIPml.Session.call(this, o_session, o_conf);

}

SIPml.Session.Subscribe.prototype = Object.create(SIPml.Session.prototype);

/**
Sends a SIP SUBSCRIBE (for presence status subscription) request.
@since version 1.1.0
@param {String} to Destination name, uri, phone number or identifier (e.g. 'sip:johndoe@example.com' or 'johndoe' or '+33600000000').
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@example
var onEvent = function(e){
    if(e.type == 'i_notify'){
        // process incoming NOTIFY request
    }
}
var session = <a href="SIPml.Stack.html#newSession">stack.newSession</a>('subscribe', {
                expires: 200,
                events_listener: { events: '*', listener: onEvent },
                sip_headers: [
                                { name: 'Event', value: 'presence' },
                                { name: 'Accept', value: 'application/pidf+xml' }
                    ],
                sip_caps: [
                            { name: '+g.oma.sip-im', value: null },
                            { name: '+audio', value: null },
                            { name: 'language', value: '\"en,fr\"' }
                    ]
            });
session.subscribe('johndoe'); // watch for johndoe's presence status

@throws {ERR_INVALID_PARAMETER_VALUE | ERR_NOT_READY} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_NOT_READY</font>
@see <a href="#unsubscribe">unsubscribe</a>
*/
SIPml.Session.Subscribe.prototype.subscribe = function (s_to, o_conf){
     if (tsk_string_is_null_or_empty(s_to)) {
        throw new Error("ERR_INVALID_PARAMETER_VALUE: 'to' must not be null");
    }
    // set destination
    this.o_session.set(tsip_session.prototype.SetToStr(s_to));
    // apply configuration values
    this.setConfiguration(o_conf);
    // sends the PUBLISH request
    return this.o_session.subscribe();
}

/**
Unsubscribe.
@since version 1.1.0
@param {SIPml.Session.Configuration} [configuration] Configuration value.
@returns {Integer} 0 if successful; otherwise nonzero
@throws {ERR_INVALID_PARAMETER_VALUE | ERR_NOT_READY} <font color="red">ERR_INVALID_PARAMETER_VALUE</font> | <font color="red">ERR_NOT_READY</font>
@see <a href="#subscribe">subscribe</a>
*/
SIPml.Session.Subscribe.prototype.unsubscribe = function (o_conf){
    // apply configuration values
    this.setConfiguration(o_conf);
    // sends the SUBSCRIBE request (expires = 0)
    return this.o_session.unsubscribe();
}
